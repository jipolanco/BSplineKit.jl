var documenterSearchIndex = {"docs":
[{"location":"collocation/#collocation-api","page":"Collocation tools","title":"Collocation tools","text":"","category":"section"},{"location":"collocation/#Collocation-points","page":"Collocation tools","title":"Collocation points","text":"","category":"section"},{"location":"collocation/#Point-selection-methods","page":"Collocation tools","title":"Point selection methods","text":"","category":"section"},{"location":"collocation/#Matrices","page":"Collocation tools","title":"Matrices","text":"","category":"section"},{"location":"collocation/#Internals","page":"Collocation tools","title":"Internals","text":"","category":"section"},{"location":"collocation/#BSplineKit.Collocation.collocation_points","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_points","text":"collocation_points(\n    B::AbstractBSplineBasis,\n    method::SelectionMethod = default_method(B),\n)\n\nDefine and return adapted collocation points for evaluation of splines.\n\nThe number of returned collocation points is equal to the number of functions in the basis.\n\nNote that if B is a RecombinedBSplineBasis (adapted for boundary value problems), collocation points are not included at the boundaries, since the boundary conditions are implicitly satisfied by the basis.\n\nIn principle, the choice of collocation points is not unique. The selection method can be chosen via the method argument. For now, the following  methods are accepted:\n\nCollocation.AvgKnots();\nCollocation.SameAsKnots(), which requires the length of the basis to be equal to the number of knots.\n\nThe former is the default, except for periodic B-spline bases (PeriodicBSplineBasis) of even order k, for which SameAsKnots is the default. (Note that for odd-order B-splines, this can lead to non-invertible collocation matrices.)\n\nSee also collocation_points!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.collocation_points!","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_points!","text":"collocation_points!(\n    x::AbstractVector, B::AbstractBSplineBasis,\n    method::SelectionMethod = default_method(B),\n)\n\nFill vector with collocation points for evaluation of splines.\n\nSee collocation_points for details.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.SelectionMethod","page":"Collocation tools","title":"BSplineKit.Collocation.SelectionMethod","text":"SelectionMethod\n\nAbstract type defining a method for choosing collocation points from spline knots.\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.AvgKnots","page":"Collocation tools","title":"BSplineKit.Collocation.AvgKnots","text":"AvgKnots <: SelectionMethod\n\nEach collocation point is chosen as a sliding average over k - 1 knots:\n\nx_i = frac1k - 1 _j = 1^k - 1 t_i + j\n\nThe resulting collocation points are sometimes called Greville sites (de Boor 2001).\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.SameAsKnots","page":"Collocation tools","title":"BSplineKit.Collocation.SameAsKnots","text":"SameAsKnots <: SelectionMethod\n\nCollocation points are chosen to match B-spline knots.\n\nNote that this only makes sense when the number of degrees of freedom of the B-spline basis (i.e. the length of the basis) matches the number of knots, which is generally not the case.\n\nSome examples of bases that satisfy this condition are:\n\nrecombined B-spline bases (RecombinedBSplineBasis) with Natural boundary conditions;\nperiodic B-spline bases (PeriodicBSplineBasis).\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.CollocationMatrix","page":"Collocation tools","title":"BSplineKit.Collocation.CollocationMatrix","text":"CollocationMatrix{T} <: AbstractBandedMatrix{T}\n\nB-spline collocation matrix, defined by\n\nC_ij = b_j(x_i)\n\nwhere bmx is a set of collocation points.\n\nProvides an efficient LU factorisation without pivoting adapted from de Boor (1978). The factorisation takes advantage of the total positivity of spline collocation matrices (de Boor 2001, p. 175).\n\nFactorisation\n\nCollocationMatrix supports in-place LU factorisation using lu!, as well as out-of-place factorisation using lu. LU decomposition may also be performed via factorize.\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.collocation_matrix","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_matrix","text":"collocation_matrix(\n    B::AbstractBSplineBasis,\n    x::AbstractVector,\n    [deriv::Derivative = Derivative(0)],\n    [MatrixType = CollocationMatrix{Float64}];\n    clip_threshold = eps(eltype(MatrixType)),\n)\n\nReturn collocation matrix mapping B-spline coefficients to spline values at the collocation points x.\n\nExtended help\n\nThe matrix elements are given by the B-splines evaluated at the collocation points:\n\nC_ij = b_j(x_i) quad textfor quad\ni  1 N_x text and  j  1 N_b\n\nwhere Nx = length(x) is the number of collocation points, and Nb = length(B) is the number of B-splines in B.\n\nTo obtain a matrix associated to the B-spline derivatives, set the deriv argument to the order of the derivative.\n\nGiven the B-spline coefficients u_j 1  j  N_b, one can recover the values (or derivatives) of the spline at the collocation points as v = C * u. Conversely, if one knows the values v_i at the collocation points, the coefficients u of the spline passing by the collocation points may be obtained by inversion of the linear system u = C \\ v.\n\nThe clip_threshold argument allows one to ignore spurious, negligible values obtained when evaluating B-splines. These values are typically unwanted, as they artificially increase the number of elements (and sometimes the bandwidth) of the matrix. They may appear when a collocation point is located on a knot. By default, clip_threshold is set to the machine epsilon associated to the matrix element type (see eps in the Julia documentation). Set it to zero to disable this behaviour.\n\nMatrix types\n\nThe MatrixType optional argument allows to select the type of returned matrix.\n\nDue to the compact support of B-splines, the collocation matrix is banded if the collocation points are properly distributed.\n\nSupported matrix types\n\nCollocationMatrix{T}: similar to a BandedMatrix{T}, with efficient LU factorisations without pivoting (see CollocationMatrix for details). This option performs much better than sparse matrices for inversion of linear systems. On the other hand, for matrix-vector or matrix-matrix multiplications, SparseMatrixCSC may perform better, especially when using OpenBLAS (see BandedMatrices issue). May fail with an error for non-square matrix shapes, or if the distribution of collocation points is not adapted. In these cases, the effective bandwidth of the matrix may be larger than the expected bandwidth.\nSparseMatrixCSC{T}: regular sparse matrix; correctly handles all matrix shapes.\nMatrix{T}: a regular dense matrix. Generally performs worse than the alternatives, especially for large problems.\n\nnote: Periodic B-spline bases\nThe default matrix type is CollocationMatrix{T}, except for periodic bases (PeriodicBSplineBasis), in which case the collocation matrix has a few out-of-bands entries due to periodicity. For cubic periodic bases, the Collocation.CyclicTridiagonalMatrix matrix type is used, which implements efficient solution of linear problems. For non-cubic periodic bases, SparseMatrixCSC is the default. Note that this may change in the future.\n\nSee also collocation_matrix!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.collocation_matrix!","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_matrix!","text":"collocation_matrix!(\n    C::AbstractMatrix{T}, B::AbstractBSplineBasis, x::AbstractVector,\n    [deriv::Derivative = Derivative(0)]; clip_threshold = eps(T))\n\nFill preallocated collocation matrix.\n\nSee collocation_matrix for details.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#LinearAlgebra.lu","page":"Collocation tools","title":"LinearAlgebra.lu","text":"LinearAlgebra.lu(C::CollocationMatrix, pivot = NoPivot(); check = true)\n\nReturns LU factorisation of collocation matrix.\n\nSee also lu!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#LinearAlgebra.lu!","page":"Collocation tools","title":"LinearAlgebra.lu!","text":"LinearAlgebra.lu!(C::CollocationMatrix, pivot = Val(false); check = true)\n\nPerform in-place LU factorisation of collocation matrix without pivoting.\n\nTakes advantage of the totally positive property of collocation matrices appearing in spline calculations (de Boor 1978).\n\nThe code is ported from Carl de Boor's BANFAC routine in FORTRAN77, via its FORTRAN90 version by John Burkardt.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.CyclicTridiagonalMatrix","page":"Collocation tools","title":"BSplineKit.Collocation.CyclicTridiagonalMatrix","text":"CyclicTridiagonalMatrix{T} <: AbstractMatrix{T}\n\nRepresents an almost tridiagonal matrix with non-zero values at the lower-left and upper-right corners.\n\nThis kind of matrix appears when working with periodic splines.\n\nLinear systems involving this matrix can be efficiently solved using a combination of the Thomas algorithm (for regular tridiagonal matrices) and of the Sherman–Morrison formula.\n\n\n\n\n\n","category":"type"},{"location":"collocation/#LinearAlgebra.ldiv!","page":"Collocation tools","title":"LinearAlgebra.ldiv!","text":"LinearAlgebra.ldiv!(x::AbstractVector, A::CyclicTridiagonalMatrix, y::AbstractVector)\n\nSolve cyclic tridiagonal linear system Ax = y.\n\nNote that all three arrays are modified by this function, with the result being stored in x.\n\nUses the algorithm described in Wikipedia based on the Sherman–Morrison formula.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#basis-recombination-api","page":"Basis recombination","title":"Basis recombination","text":"","category":"section"},{"location":"recombination/#Recombined-bases","page":"Basis recombination","title":"Recombined bases","text":"","category":"section"},{"location":"recombination/#Recombination-matrix","page":"Basis recombination","title":"Recombination matrix","text":"","category":"section"},{"location":"recombination/#Internals","page":"Basis recombination","title":"Internals","text":"","category":"section"},{"location":"recombination/#BSplineKit.Recombinations","page":"Basis recombination","title":"BSplineKit.Recombinations","text":"Recombinations\n\nBasis recombination module.\n\nDefines RecombinedBSplineBasis and RecombineMatrix types.\n\n\n\n\n\n","category":"module"},{"location":"recombination/#BSplineKit.Recombinations.RecombinedBSplineBasis","page":"Basis recombination","title":"BSplineKit.Recombinations.RecombinedBSplineBasis","text":"RecombinedBSplineBasis{k, T}\n\nFunctional basis defined from the recombination of a BSplineBasis in order to satisfy certain homogeneous boundary conditions (BCs).\n\nExtended help\n\nThe basis recombination technique is a common way of applying BCs in Galerkin methods. It is described for instance in Boyd 2000 (ch. 6), in the context of a Chebyshev basis. In this approach, the original basis, b_i(x) 1  i  N, is \"recombined\" into a new basis, ϕ_j(x) 1  j  M, so that each basis function ϕ_j individually satisfies the chosen BCs.\n\nThe length M of the recombined basis is always smaller than the length N of the original basis. The difference, δ = N - M, is equal to the number of boundary conditions. In the simplest (and most common) case, a single BC is applied on each boundary, leading to δ = 2. More generally, as described further below, it is possible to simultaneously impose different BCs, which further decreases the number of degrees of freedom (increasing δ).\n\nThanks to the local support of B-splines, basis recombination involves only a little portion of the original B-spline basis. For instance, since there is only one B-spline that is non-zero at each boundary, removing that function from the basis is enough to apply homogeneous Dirichlet BCs. Imposing BCs for derivatives is slightly more complex, but still possible.\n\nNote that, when combining basis recombination with collocation methods, there must be no collocation points at the boundaries, or the resulting collocation matrices may not be invertible.\n\nOrder of the boundary condition\n\nIn this section, we consider the simplest case where a single homogeneous boundary condition, mathrmd^n u  mathrmdx^n = 0, is to be satisfied by the basis.\n\nThe recombined basis requires the specification of a Derivative object determining the order of the homogeneous BCs to be applied at the two boundaries. Linear combinations of Derivatives are also supported. The order of the B-spline needs to be k  n + 1, since a B-spline of order k is a C^k - 1-continuous function (except on the knots where it is C^k - 1 - p, with p the knot multiplicity).\n\nSome usual choices are:\n\nDerivative(0) sets homogeneous Dirichlet BCs (u = 0 at the boundaries) by removing the first and last B-splines, i.e. ϕ_1 = b_2;\nDerivative(1) sets homogeneous Neumann BCs (u = 0 at the boundaries) by adding the two first (and two last) B-splines, i.e. ϕ_1 = b_1 + b_2.\nmore generally, α Derivative(0) + β Derivative(1) sets homogeneous Robin BCs by defining ϕ_1 as a linear combination of b_1 and b_2. Here it's important to note that Derivative(1) denotes the normal derivative at the boundary, fracun, which is equal to -fracux on the left boundary.\n\nHigher order BCs are also possible. For instance, Derivative(2) recombines the first three B-splines into two basis functions that satisfy ϕ_1 = ϕ_2 = 0 at the left boundary, while ensuring that lower and higher-order derivatives keep degrees of freedom at the boundary. Note that simply adding the first three B-splines, as in ϕ_1 = b_1 + b_2 + b_3, makes the first derivative vanish as well as the second one, which is unwanted.\n\nFor Derivative(2), the chosen solution is to set ϕ_i = α_i b_i + β_i b_i + 1 for i  1 2. The α_i and β_i coefficients are chosen such that ϕ_i = 0 at the boundary. Moreover, they satisfy the (somewhat arbitrary) constraint α_i + β_i = 2 for each i, for consistency with the Neumann case described above. This generalises to higher order BCs. Note that, since each boundary function ϕ_i is defined from only two neighbouring B-splines, its local support stays minimal, hence preserving the small bandwidth of the resulting matrices.\n\nFinally, note that in the current implementation, it is not possible to impose different boundary conditions on both boundaries.\n\nMultiple boundary conditions\n\nAs an option, the recombined basis may simultaneously satisfy homogeneous BCs of different orders. In this case, a tuple of Derivatives must be passed.\n\nFor more details on the supported combinations of BCs, see the different RecombinedBSplineBasis constructors documented further below.\n\n\n\nRecombinedBSplineBasis(B::BSplineBasis, op::AbstractDifferentialOp)\nRecombinedBSplineBasis(B::BSplineBasis, op_left, op_right)\n\nConstruct RecombinedBSplineBasis from B-spline basis B, satisfying homogeneous boundary conditions (BCs) associated to the given differential operator.\n\nThe second case allows setting different BCs on each boundary.\n\nFor instance, op = Derivative(0) and op = Derivative(1) correspond to homogeneous Dirichlet and Neumann BCs, respectively.\n\nLinear combinations of differential operators are also supported. For instance, op = Derivative(0) + λ Derivative(1) corresponds to homogeneous Robin BCs.\n\nHigher-order derivatives are also allowed, being only limited by the order of the B-spline basis.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.2:1)\n13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n\njulia> R_neumann = RecombinedBSplineBasis(B, Derivative(1))\n11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{1},)\n BCs right: (D{1},)\n\njulia> R_robin = RecombinedBSplineBasis(B, Derivative(0) + 3Derivative(1))\n11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{0} + 3 * D{1},)\n BCs right: (D{0} + 3 * D{1},)\n\n\n\nRecombinedBSplineBasis(B::BSplineBasis, ops)\nRecombinedBSplineBasis(B::BSplineBasis, ops_left, ops_right)\n\nConstruct RecombinedBSplineBasis simultaneously satisfying homogeneous BCs associated to multiple differential operators.\n\nCurrently, the following cases are supported:\n\nall derivatives up to order m:\n ops = (Derivative(0), ..., Derivative(m))\nThis boundary condition is obtained by removing the first m + 1 B-splines from the original basis.\nFor instance, if (Derivative(0), Derivative(1)) is passed, then the basis simultaneously satisfies homogeneous Dirichlet and Neumann BCs at the two boundaries. The resulting basis is ϕ_1 = b_3 ϕ_2 = b_4  ϕ_N - 4 = b_N - 2.\nan extension of the above, with an additional differential operator of order n at the end:\n ops = (Derivative(0), ..., Derivative(m), D(n))\nThe operator D(n) may be a Derivative, or a linear combination of derivatives. The only restriction is that its maximum degree must satisfy n ≥ m + 1.\nOne example is the combination of homogeneous Dirichlet BCs, u = 0 on the boundaries, with Robin BCs for the derivative, u + λ u = 0, which corresponds to ops = (Derivative(0), Derivative(1) + λ Derivative(2)).\ngeneralised natural boundary conditions:\n ops = Natural()\nThis is equivalent to ops = (Derivative(2), Derivative(3), ..., Derivative(k ÷ 2)) where k is the spline order (which must be even). See Natural for details.\n\"free\" boundary conditions can simply be obtained by passing an empty tuple or nothing:\n ops = ()\n ops = nothing\nThis means that no recombination will be performed. Therefore, if applied at the two boundaries, the resulting basis will be identical to the original basis, which is not very useful. In practice it can make sense to apply this on one of the boundaries, complemented by an actual boundary condition on the other end.\n\nIn the first two cases, the degrees of the differential operators must be in increasing order. For instance, ops = (Derivative(1), Derivative(0)) fails with an error.\n\nExamples\n\njulia> ops = (Derivative(0), Derivative(1));\n\n\njulia> R1 = RecombinedBSplineBasis(B, ops)\n9-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{0}, D{1})\n BCs right: (D{0}, D{1})\n\njulia> ops = (Derivative(0), Derivative(1) - 4Derivative(2));\n\n\njulia> R2 = RecombinedBSplineBasis(B, ops)\n9-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{0}, D{1} + -4 * D{2})\n BCs right: (D{0}, D{1} + -4 * D{2})\n\njulia> R3 = RecombinedBSplineBasis(B, Natural())\n11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{2},)\n BCs right: (D{2},)\n\n\n\n\n\n","category":"type"},{"location":"recombination/#Base.parent-Tuple{RecombinedBSplineBasis}","page":"Basis recombination","title":"Base.parent","text":"parent(R::RecombinedBSplineBasis)\n\nGet original B-spline basis.\n\n\n\n\n\n","category":"method"},{"location":"recombination/#Base.length-Tuple{RecombinedBSplineBasis}","page":"Basis recombination","title":"Base.length","text":"length(R::RecombinedBSplineBasis)\n\nReturns the number of functions in the recombined basis.\n\n\n\n\n\n","category":"method"},{"location":"recombination/#BSplineKit.Recombinations.constraints","page":"Basis recombination","title":"BSplineKit.Recombinations.constraints","text":"constraints(R::AbstractBSplineBasis) -> (left, right)\nconstraints(A::RecombineMatrix) -> (left, right)\n\nReturn the constraints (homogeneous boundary conditions) that the basis satisfies on each boundary.\n\nConstraints are returned as a tuple (left, right) indicating the BCs that are satisfied on each boundary. Each element is a tuple of differential operators specifying the BCs.\n\nFor example, if both Dirichlet and Neumann BCs are satisfied on the left boundary, then left = (Derivative(0), Derivative(1)).\n\nFor non-recombined bases such as BSplineBasis, this returns a tuple of empty tuples: ((), ()), since no BCs are satisfied on either boundary.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.num_constraints","page":"Basis recombination","title":"BSplineKit.Recombinations.num_constraints","text":"num_constraints(R::AbstractBSplineBasis) -> (Int, Int)\nnum_constraints(A::RecombineMatrix) -> (Int, Int)\n\nReturns the number of constraints (number of BCs to satisfy) on each boundary.\n\nFor instance, if R simultaneously satisfies Dirichlet and Neumann boundary conditions on each boundary, this returns (2, 2).\n\nNote that for non-recombined bases such as BSplineBasis, the number of constraints is zero, and this returns (0, 0).\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.num_recombined","page":"Basis recombination","title":"BSplineKit.Recombinations.num_recombined","text":"num_recombined(R::AbstractBSplineBasis) -> (Int, Int)\nnum_recombined(A::RecombineMatrix) -> (Int, Int)\n\nReturns the number of recombined functions in the recombined basis for each boundary.\n\nFor instance, if R satisfies Neumann boundary conditions on both boundaries, then only the first and last basis functions are different from the original B-spline basis, e.g. ϕ_1 = b_1 + b_2, and this returns (1, 1).\n\nFor non-recombined bases such as BSplineBasis, this returns zero.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.recombination_matrix","page":"Basis recombination","title":"BSplineKit.Recombinations.recombination_matrix","text":"recombination_matrix(R::AbstractBSplineBasis)\n\nGet RecombineMatrix associated to the recombined basis.\n\nFor non-recombined bases such as BSplineBasis, this returns the identity matrix (LinearAlgebra.I).\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.RecombineMatrix","page":"Basis recombination","title":"BSplineKit.Recombinations.RecombineMatrix","text":"RecombineMatrix{T} <: AbstractMatrix{T}\n\nMatrix for transformation from coefficients of the recombined basis, to the corresponding B-spline basis coefficients.\n\nExtended help\n\nThe transformation matrix M is defined by\n\nϕ_j = M_ij b_i\n\nwhere b_j(x) and ϕ_i(x) are elements of the B-spline and recombined bases, respectively.\n\nThis matrix allows to pass from known coefficients u_j in the recombined basis ϕ_j, to the respective coefficients v_i in the B-spline basis b_i:\n\nbmv = mathbfM bmu\n\nNote that the matrix is not square: it has dimensions N  M, where N is the length of the B-spline basis, and M = N - δ is that of the recombined basis (see RecombinedBSplineBasis for details).\n\nDue to the local support of B-splines, basis recombination can be performed by combining just a small set of B-splines near the boundaries (as discussed in RecombinedBSplineBasis). This leads to a recombination matrix which is almost a diagonal of ones, plus a few extra super- and sub-diagonal elements in the upper left and lower right corners, respectively. The matrix is stored in a memory-efficient way that also allows fast access to its elements.\n\nEfficient implementations of matrix-vector products (using the * operator or LinearAlgebra.mul!) and of left division of vectors (using \\ or LinearAlgebra.ldiv!) are included. These two operations can be used to transform between coefficients in the original and recombined bases.\n\nNote that, since the recombined basis forms a subspace of the original basis (which is related to the rectangular shape of the matrix), it is generally not possible to obtain recombined coefficients from original coefficients, unless the latter already satisfy the constraints encoded in the recombined basis. The left division operation will throw a NoUniqueSolutionError if that is not the case.\n\n\n\nRecombineMatrix(ops::Tuple{Vararg{AbstractDifferentialOp}}, B::BSplineBasis, [T])\nRecombineMatrix(ops_left, ops_right, B::BSplineBasis, [T])\n\nConstruct recombination matrix describing a B-spline basis recombination.\n\nIn the first case, ops is the boundary condition (BC) to be applied on both boundaries. The second case allows to set different BCs on each boundary.\n\nThe default element type T is generally Float64, except for specific differential operators which yield a matrix of zeroes and ones, for which Bool is the default.\n\nSee the RecombinedBSplineBasis constructor for details on the ops argument.\n\n\n\n\n\n","category":"type"},{"location":"recombination/#BSplineKit.Recombinations.nzrows","page":"Basis recombination","title":"BSplineKit.Recombinations.nzrows","text":"nzrows(A::RecombineMatrix, col::Integer) -> UnitRange{Int}\n\nReturns the range of row indices i such that A[i, col] is non-zero.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.NoUniqueSolutionError","page":"Basis recombination","title":"BSplineKit.Recombinations.NoUniqueSolutionError","text":"NoUniqueSolutionError <: Exception\n\nException thrown when solving linear system using RecombineMatrix, when the system has no unique solution.\n\n\n\n\n\n","category":"type"},{"location":"recombination/#BSplineKit.Recombinations.parent_coefficients","page":"Basis recombination","title":"BSplineKit.Recombinations.parent_coefficients","text":"parent_coefficients(R::RecombinedBSplineBasis, coefs::AbstractVector)\n\nReturns the coefficients associated to the parent B-spline basis, from the coefficients coefs in the recombined basis.\n\nNote that this function doesn't allocate, since it returns a lazy concatenation of two StaticArrays and a view of the coefs vector.\n\n\n\n\n\n","category":"function"},{"location":"generated/interpolation/#interpolation-example","page":"Spline interpolations","title":"Spline interpolations","text":"","category":"section"},{"location":"generated/interpolation/#Interpolating-data","page":"Spline interpolations","title":"Interpolating data","text":"BSplineKit can interpolate evenly and unevenly-distributed data.\n\nFor example, we can try interpolating random data on randomly-distributed data points:\n\nusing Random\nrng = MersenneTwister(42)\n\nNdata = 20\nxs = range(0, 1; length = Ndata) .+ 0.01 .* randn(rng, Ndata)\nsort!(xs)  # make sure coordinates are sorted\nxs[begin] = 0; xs[end] = 1;   # not strictly necessary; just to set the data limits\nys = sinpi.(xs) .+ 0.02 .* randn(rng, Ndata);\nnothing #hide\n\nLet's start by plotting the generated data:\n\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")  # hide\nscatter(xs, ys; label = \"Data\", color = :black)\n\nTo interpolate the data using splines, we may choose any arbitrary B-spline order k (in particular, k = 4 corresponds to cubic splines). The main interpolation function is interpolate.\n\nusing BSplineKit\nS = interpolate(xs, ys, BSplineOrder(4))\n\nLet's plot the result:\n\nlines!(0..1, S; label = \"k = 4\", color = Cycled(4 - 3))\ncurrent_figure()  # hide\n\nWe can also choose other interpolation orders for comparison:\n\nfor k ∈ (5, 6, 8)\n    local S = interpolate(xs, ys, BSplineOrder(k))\n    lines!(0..1, S; label = \"k = $k\", color = Cycled(k - 3))\nend\naxislegend()\ncurrent_figure()  # hide\n\nWe see larger and larger oscillations, especially near the boundaries, as the spline order increases. We can try to fix this using natural splines, which impose some derivatives to be zero at the boundaries.","category":"section"},{"location":"generated/interpolation/#Natural-splines","page":"Spline interpolations","title":"Natural splines","text":"Natural splines usually refer to cubic splines (order k = 4) with the additional constraint S(a) = S(b) = 0 at the boundaries (x  a b).\n\nIn BSplineKit, this concept is generalised for all even spline orders k, by setting all derivatives of order 2 3  k  2 to be zero at the boundaries. For instance, for k = 6 (quintic splines), the constraint is S = S = 0. We achieve this by using basis recombination to implicitly impose the wanted boundary conditions.\n\nThe natural boundary condition not only allows to suppress oscillations near the boundaries, but is also quite convenient for interpolations, as it reduces the number of degrees of freedom such that the number of unique spline knots is equal to the number of data points. This simply means that one can set the knots to be equal to the data points. All of this is done internally when using this boundary condition.\n\nTo impose natural boundary conditions, one just needs to pass Natural to interpolate, as illustrated below.\n\nk = 8\nS = interpolate(xs, ys, BSplineOrder(k))  # without BCs\nSnat = interpolate(xs, ys, BSplineOrder(k), Natural())  # with natural BCs\n\nLet's look at the result:\n\nscatter(xs, ys; label = \"Data\", color = :black)\nlines!(0..1, S; label = \"k = $k (original)\", linewidth = 2)\nlines!(0..1, Snat; label = \"k = $k (natural)\", linestyle = :dash, linewidth = 4)\naxislegend()\ncurrent_figure()  # hide\n\nClearly, the spurious oscillations are strongly suppressed near the boundaries.","category":"section"},{"location":"generated/interpolation/#smoothing-example","page":"Spline interpolations","title":"Smoothing cubic splines","text":"One can use smoothing splines to fit noisy data. A smoothing spline is a curve which passes close to the input data, while avoiding strong fluctuations due to possible noise. The smoothing strength is controlled by a regularisation parameter λ. Setting λ = 0 corresponds to a regular interpolation (the obtained spline passes through all the points), while increasing λ leads to a smoother curve which roughly approximates the data.\n\nGiven a set of data points (x_i y_i), the idea is to construct a spline S(x) that minimises:\n\n_i = 1^N w_i y_i - S(x_i)^2 + λ _x_1^x_N left S(x) right^2  mathrmdx\n\nHere w_i are optional weights that may be used to give \"priority\" to certain data points.\n\nNote that only cubic splines (order k = 4) are currently supported.\n\nrng = MersenneTwister(42)\nNdata = 20\nxs = sort!(rand(rng, Ndata))\nxs[begin] = 0; xs[end] = 1;   # not strictly necessary; just to set the data limits\nys = cospi.(2 .* xs) .+ 0.04 .* randn(rng, Ndata);\nnothing #hide\n\nCreate smoothing spline from data:\n\nλ = 1e-3\nS_fit = fit(BSplineOrder(4), xs, ys, λ)\n\nPassing BSplineOrder(4) is mandatory, even if it's the only allowed value currently.\n\nIf we want the spline to pass very near a single data point, we can assign a larger weight to that point:\n\nweights = fill!(similar(xs), 1)\nweights[12] = 100  # larger weight to point i = 12\nS_fit_weight = fit(BSplineOrder(4), xs, ys, λ; weights)\n\nPlot results and compare with natural cubic spline interpolation:\n\nS_interp = interpolate(xs, ys, BSplineOrder(4), Natural())\n\nscatter(xs, ys; label = \"Data\", color = :black)\nlines!(0..1, S_interp; label = \"Interpolation\", linewidth = 2)\nlines!(0..1, S_fit; label = \"Fit (λ = $λ)\", linewidth = 2)\nlines!(0..1, S_fit_weight; label = \"Fit (λ = $λ) with weight\", linestyle = :dash, linewidth = 2)\naxislegend(position = (0.5, 1))\ncurrent_figure()  # hide","category":"section"},{"location":"generated/interpolation/#extrapolation-example","page":"Spline interpolations","title":"Extrapolations","text":"One can use extrapolation to evaluate splines outside of their domain of definition. A few different extrapolation strategies are implemented in BSplineKit. See Extrapolation methods for details.\n\nBelow we compare a few possible extrapolation strategies included in BSplineKit.\n\nFirst, we generate and interpolate new data:\n\nxs = 0.2:0.2:1.2\nys = 2 * cospi.(xs)\nS = interpolate(xs, ys, BSplineOrder(4))\n\nOne can directly evaluate these interpolations outside of the domain 0 1, but the result will always be zero:\n\nS(-0.32)\n\nTo enable extrapolations, one must call extrapolate with the desired extrapolation strategy (see Extrapolation methods for a list). Here we compare both Flat and Smooth methods:\n\nE_flat   = extrapolate(S, Flat())\nE_linear = extrapolate(S, Linear())\nE_smooth = extrapolate(S, Smooth())\n\nfig = Figure(size = (600, 400))\nax = Axis(fig[1, 1])\nscatter!(ax, xs, ys; label = \"Data\", color = :black)\nlines!(ax, -0.5..1.5, S; label = \"No extrapolation\", linewidth = 2)\nlines!(ax, -0.5..1.5, E_smooth; label = \"Smooth\", linestyle = :dash, linewidth = 2)\nlines!(ax, -0.5..1.5, E_linear; label = \"Linear\", linestyle = :dashdot, linewidth = 2)\nlines!(ax, -0.5..1.5, E_flat; label = \"Flat\", linestyle = :dot, linewidth = 2)\naxislegend(ax)\nfig","category":"section"},{"location":"generated/interpolation/#interpolation-periodic-example","page":"Spline interpolations","title":"Periodic data","text":"It is also possible to interpolate or fit data which is expected to result from a periodic function, such that f(x + L) = f(x) for some period L. For this, one can pass Periodic(L) as a boundary condition to interpolate or fit.\n\nThe following example starts from data at points x_j within the -1 1 interval, and assumes the resulting spline can be extended periodically outside of this interval.\n\nWe start by generating some data:\n\nN = 40\nf_slow(x) = cospi(x)\nf_fast(x) = 0.2 * sinpi(40x)\nxs = [-cospi(n / N) for n = 0:(N - 1)]  # in [-1, 1) // NOTE: the endpoint (x = 1) must be excluded!!\nys = @. f_slow(xs) + f_fast(xs);\nnothing #hide\n\nInterpolate the data:\n\nL = 2\nS_interp = interpolate(xs, copy(ys), BSplineOrder(4), Periodic(L))\n\nCreate a periodic cubic smoothing spline. Note that BSplineOrder(4) is assumed (it's currently the only supported choice). We also compare with a smoothing spline which doesn't assume periodic boundary conditions.\n\nλ = 0.001  # smoothing parameter\nS_fit_natural = fit(BSplineOrder(4), [xs; xs[begin] + L], [ys; ys[begin]], λ)  # for comparison, compute a natural spline (no implied periodicity)\nS_fit_periodic = fit(BSplineOrder(4), xs, ys, λ, Periodic(L))\n\nPlot the results:\n\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, xs, ys; label = \"Data\")\nlines!(ax, -1..1, S_interp; label = \"Interpolation\", color = (:grey, 0.5))\nlines!(ax, -1..1, S_fit_periodic; linewidth = 3, label = \"Smoothing (periodic)\")\nlines!(ax, -1..1, S_fit_natural; linewidth = 3, linestyle = :dash, label = \"Smoothing (natural)\")\naxislegend(ax)\nfig\n\nAs can be expected, the smoothing spline with periodic boundary conditions mostly differs from the \"natural\" smoothing spline near the boundaries. In particular, the natural smoothing spline simply does not satisfy periodic boundary conditions (even at the level of the zero-th derivative!), so it's not very adapted for constructing periodic functions.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/heat/#Heat-equation","page":"Heat equation","title":"Heat equation","text":"In this example, we numerically solve the 1D heat equation\n\nfracθt = ν frac^2 θx^2\n\nin a bounded domain x  -1 1 with homogeneous Neumann boundary conditions, _x θ(1 t) = 0.","category":"section"},{"location":"generated/heat/#Defining-a-B-spline-basis","page":"Heat equation","title":"Defining a B-spline basis","text":"The general idea is to approximate the unknown solution by a spline of order k. For this, we first define a B-spline basis  b_i(x)  i = 1  N , such that the solution at a given time t is approximated by\n\nθ(x t) = _i = 1^N v_i(t) b_i(x)\n\nwhere the v_i are the B-spline coefficients.\n\nA B-spline basis is uniquely defined by its order k and by a choice of knot locations within the spatial domain, which form the spatial grid.\n\nFor this example, we take a uniform repartition of knots in -1 1.\n\nknots_in = range(-1, 1; length = 11)\n\nWe then create a B-spline basis of order k = 4 using these knots.\n\nusing BSplineKit\nB = BSplineBasis(BSplineOrder(4), knots_in)\n\nNote that the generated basis includes an augmented set of knots, in which each boundary is repeated k times:\n\nknots(B)\n\nIn other words, the boundary knots have multiplicity k, while interior knots have multiplicity 1. This is common practice in bounded domains, and translates the fact that the solution does not need to be continuous at the boundaries. This provides additional degrees of freedom notably for the boundary conditions. This behaviour can be disabled via the augment argument of BSplineBasis.\n\nWe can now plot the knot locations (crosses) and the generated B-spline basis:\n\nusing CairoMakie\nusing LaTeXStrings\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 2.0)\n\nfunction plot_knots!(ax, ts; knot_offset = 0.05, kws...)\n    ys = zero(ts)\n    # Add offset to distinguish knots with multiplicity > 1\n    for i in eachindex(ts)[(begin + 1):end]\n        if ts[i] == ts[i - 1]\n            ys[i] = ys[i - 1] + knot_offset\n        end\n    end\n    scatter!(ax, ts, ys; marker = '×', markersize = 24, color = :gray, kws...)\n    ax\nend\n\nfunction plot_basis!(ax, B; eval_args = (), kws...)\n    cmap = cgrad(:tab20)\n    N = length(B)\n    ts = knots(B)\n    hlines!(ax, 0; color = :gray)\n    for (n, bi) in enumerate(B)\n        color = cmap[(n - 1) / (N - 1)]\n        i, j = extrema(support(bi))\n        lines!(ax, ts[i]..ts[j], x -> bi(x, eval_args...); color, linewidth = 2.5)\n    end\n    plot_knots!(ax, ts; kws...)\n    ax\nend\n\nfig = Figure()\nax = Axis(\n    fig[1, 1];\n    xlabel = rich(\"x\"; font = :italic),\n    ylabel = rich(\"b\", subscript(\"i\"), rich(\"(x)\"; offset = (0.1, 0.0)); font = :italic),\n)\nplot_basis!(ax, B)\nfig","category":"section"},{"location":"generated/heat/#Imposing-boundary-conditions","page":"Heat equation","title":"Imposing boundary conditions","text":"In BSplineKit, the recommended approach for solving boundary value problems is to use the basis recombination method. That is, to expand the solution onto a new basis consisting on linear combinations of B-splines b_i(x), such that each recombined basis function ϕ_j(x) individually satisfies the required homogeneous boundary conditions (BCs). Thanks to the local support of B-splines, basis recombination only involves a small number of B-splines near the boundaries.\n\nUsing the RecombinedBSplineBasis type, we can easily define such recombined bases for many different BCs. In this example we generate a basis satisfying homogeneous Neumann BCs:\n\nR = RecombinedBSplineBasis(B, Derivative(1))\n\nfig = Figure()\nax = Axis(\n    fig[1, 1];\n    xlabel = rich(\"x\"; font = :italic),\n    ylabel = rich(\"ϕ\", subscript(\"i\"), rich(\"(x)\"; offset = (0.1, 0.0)); font = :italic),\n)\nplot_basis!(ax, R)\nfig\n\nWe notice that, on each of the two boundaries, the two initial (or final) B-splines of the original basis have been combined to produce a single basis function that has zero derivative at each respective boundary. To verify this, we can plot the basis function derivatives:\n\nfig = Figure()\nax = Axis(\n    fig[1, 1];\n    xlabel = rich(\"x\"; font = :italic),\n    ylabel = rich(\"ϕ′\", subscript(\"i\"; offset = (-0.3, 0.0)), rich(\"(x)\"; offset = (0.1, 0.0)); font = :italic),\n)\nplot_basis!(ax, R; eval_args = (Derivative(1), ), knot_offset = 0.4)\nfig\n\nNote that the new basis has two less functions than the original one, reflecting a loss of two degrees of freedom corresponding to the new constraints on each boundary:\n\nlength(B), length(R)","category":"section"},{"location":"generated/heat/#Recombination-matrix","page":"Heat equation","title":"Recombination matrix","text":"As stated above, the basis recombination approach consists in performing linear combinations of B-splines b_i to obtain a derived basis of functions ϕ_j satisfying certain boundary conditions. This can be conveniently expressed using a transformation matrix mathbfT relating the two bases:\n\nϕ_j(x) = _i = 1^N T_ij b_i(x)\nquad textfor  j = 1 2  M\n\nwhere N is the number of B-splines b_i, and M  N is the number of ϕ_j functions (in this example, M = N - 2).\n\nThe recombination matrix associated to the generated basis can be obtained using recombination_matrix:\n\nT = recombination_matrix(R)\n\nNote that the matrix is almost an identity matrix, since most B-splines are kept intact in the new basis. This simple structure allows for very efficient computations using this matrix. The first and last columns indicate that Neumann BCs are imposed by adding the two first (and two last) B-splines, i.e.\n\nϕ_1(x) = b_1(x) + b_2(x)\nqquad\nϕ_M(x) = b_N - 1(x) + b_N(x)","category":"section"},{"location":"generated/heat/#Representation-of-the-solution","page":"Heat equation","title":"Representation of the solution","text":"Note that the solution θ(x t) can be represented in the original and in the recombined B-spline bases as\n\nθ(x t) = _i = 1^N v_i(t) b_i(x) = _j = 1^M u_j(t) ϕ_j(x)\n\nwhere the u_j are the coefficients in the recombined basis.\n\nThe recombination matrix introduced above can be used to transform between the coefficients u_j and v_i in both bases, via the linear relation bmv = mathbfT bmu.","category":"section"},{"location":"generated/heat/#Initial-condition","page":"Heat equation","title":"Initial condition","text":"We come back now to our problem. We want to impose the following initial condition:\n\nθ(x 0) = θ_0(x) = 1 + cos(π x)\n\nFirst, we approximate this initial condition in the recombined B-spline basis that we have just constructed. This may be easily done using approximate:\n\nθ₀(x) = 1 + cos(π * x)\nθ₀_spline = approximate(θ₀, R, MinimiseL2Error())\n\nTo see that everything went well, we can plot the exact initial condition and its spline approximation, which show no important differences.\n\nfig = Figure(size = (800, 400))\nlet ax = Axis(fig[1, 1]; xlabel = rich(\"x\"; font = :italic), ylabel = rich(\"θ\"; font = :italic))\n    lines!(ax, -1..1, θ₀; label = rich(\"θ\", subscript(\"0\"), rich(\"(x)\"; offset = (0.1, 0.0)); font = :italic), color = :blue)\n    lines!(ax, -1..1, θ₀_spline; label = \"Approximation\", color = :orange, linestyle = :dash)\n    axislegend(ax; position = :cb)\nend\nlet ax = Axis(fig[1, 2]; xlabel = rich(\"x\"; font = :italic), ylabel = \"Difference\")\n    lines!(ax, -1..1, x -> θ₀(x) - θ₀_spline(x))\n    plot_knots!(ax, knots(R); knot_offset = 0)\nend\nfig\n\nNote that we have access to the recombined B-spline coefficients u_j associated to the initial condition, which we will use further below:\n\nu_init = coefficients(θ₀_spline)","category":"section"},{"location":"generated/heat/#Solving-the-heat-equation","page":"Heat equation","title":"Solving the heat equation","text":"To solve the governing equation, the strategy is to project the unknown solution onto the chosen recombined basis. That is, we approximate the solution as\n\nθ(x t) = sum_j = 1^M u_j(t)  ϕ_j(x)\n\nPlugging this representation into the heat equation, we find\n\nnewcommandddmathrmd\n_j fracdd u_jdd t  ϕ_j(x) = ν _j u_j  ϕ_j(x)\n\nwhere primes denote spatial derivatives.\n\nWe can now use the method of mean weighted residuals to find the coefficients u_j, by projecting the above equation onto a chosen set of test functions φ_i:\n\n_j fracmathrmd u_jmathrmd t  φ_i ϕ_j = ν _j u_j  φ_i ϕ_j\n\nwhere  f g  = _-1^1 f(x)  g(x)  mathrmd x is the inner product between functions.\n\nBy choosing M different test functions φ_i, the above problem can be written as the linear system\n\nmathbfA fracmathrmd bmu(t)mathrmd t =\nν mathbfL bmu(t)\n\nwhere the matrices are defined by A_ij =  φ_i ϕ_j  and L_ij =  φ_i ϕ_j .\n\nTwo of the most common choices of test functions φ_i are:\n\nφ_i(x) = δ(x - x_i), where δ is Dirac's delta, and x_i are a set of collocation points where the equation will be satisfied. This approach is known as the collocation method.\nφ_i(x) = ϕ_i(x), in which case this is the Galerkin method.\n\nWe describe the solution using both methods in the following.","category":"section"},{"location":"generated/heat/#Collocation-method","page":"Heat equation","title":"Collocation method","text":"For the collocation method, we need to choose a set of M grid points x_j. Since the basis functions implicitly satisfy the boundary conditions, these points must be chosen inside of the domain.\n\nThe collocation points may be automatically generated by calling collocation_points. Note that, since we pass the recombined basis R, the boundaries are not included in the chosen points:\n\nxcol = collocation_points(R)\n\nWe can now construct the matrices mathbfA and mathbfL associated to the collocation method. By definition, these matrices simply contain the evaluations of all basis functions ϕ_j and their derivatives at the collocation points: A_ij = ϕ_j(x_i) and L_ij = ϕ_j(x_i). Both these matrices can be constructed in BSplineKit using collocation_matrix. Note that both matrices are of type CollocationMatrix, which wrap matrices defined in BandedMatrices.jl.\n\nAcol = collocation_matrix(R, xcol)\nLcol = collocation_matrix(R, xcol, Derivative(2))\n\nFor convenience and performance, we can incorporate the heat diffusivity ν in the mathbfL matrix:\n\nν = 0.01\nLcol *= ν\n\nFinally, for the time integration, we use OrdinaryDiffEqTsit5.jl from the DifferentialEquations.jl suite.\n\nusing LinearAlgebra\nusing OrdinaryDiffEqTsit5\n\nfunction heat_rhs!(du, u, params, t)\n    mul!(du, params.L, u)    # du = ν * L * u\n    ldiv!(du, params.A, du)  # du = A \\ (ν * L * u)\n    du\nend\n\n# Solver parameters\nparams_col = (\n    A = lu(Acol),  # we pass the factorised matrix A for performance\n    L = Lcol,\n)\n\ntspan = (0.0, 10.0)\nprob = ODEProblem(heat_rhs!, u_init, tspan, params_col)\nprob = ODEProblem{true}(heat_rhs!, u_init, tspan, params_col)\nsol_collocation = solve(prob, Tsit5(); saveat = 0.5)\n\nfunction plot_heat_solution(sol, R)\n    fig = Figure()\n    ax = Axis(fig[1, 1]; xlabel = rich(\"x\"; font = :italic), ylabel = rich(\"θ(x,t)\"; font = :italic))\n    colormap = cgrad(:viridis)\n    tspan = sol.prob.tspan\n    Δt = tspan[2] - tspan[1]\n    for (u, t) in tuples(sol)\n        S = Spline(R, u)\n        color = colormap[(t - tspan[1]) / Δt]\n        lines!(ax, -1..1, S; label = string(t), color, linewidth = 2)\n    end\n    Colorbar(fig[1, 2]; colormap, limits = tspan, label = \"Time\")\n    fig\nend\n\n# NOTE: there's an issue in CairoMakie 0.11.10 when saving SVGs with colourbars, so we fall\n# back to PNG output.\n# See https://github.com/MakieOrg/Makie.jl/issues/3016\nCairoMakie.activate!(type = \"png\", px_per_unit = 2.0)\nplot_heat_solution(sol_collocation, R)","category":"section"},{"location":"generated/heat/#Galerkin-method","page":"Heat equation","title":"Galerkin method","text":"We start by constructing the Galerkin matrices mathbfA and mathbfL. The first of these matrices, A_ij =  ϕ_i ϕ_j , is usually known as the mass matrix of the system. It is a positive definite symmetric matrix, which enables the use of Cholesky factorisation to solve the resulting linear system. Moreover, here it is banded thanks to the local support of the B-splines. The mass matrix can be constructed by calling galerkin_matrix:\n\nAgal = galerkin_matrix(R)\n\nNote that, unlike the collocation method, in the Galerkin method we don't need to specify a set of grid points, as functions are not evaluated at collocation points (they are instead integrated over the whole domain). The integration is performed using Gauss–Legendre quadrature, which can be made exact up to numerical precision, taking advantage of the fact that the product of two B-splines is a piecewise polynomial.\n\nAs for the matrix mathbfL representing the second derivative operator, we can write it using integration by parts as\n\nL_ij =  ϕ_i ϕ_j \n= - ϕ_i ϕ_j  + left ϕ_i ϕ_j right_-1^1  = -R_ij\n\nwhere R_ij =  ϕ_i ϕ_j  is a positive definite symmetric matrix. Note that the boundary terms all vanish since all basis functions individually satisfy homogeneous Neumann boundary conditions, ϕ_i(1) = 0. (The same result would be obtained with homogeneous Dirichlet boundary conditions.)\n\nAs can be seen above, one well-known advantage of the Galerkin method is that the basis functions can satisfy weaker continuity conditions than in the collocation method, as high-order derivatives can be reduced using integration by parts.\n\nThe matrix mathbfR can be constructed using galerkin_matrix:\n\nRgal = galerkin_matrix(R, (Derivative(1), Derivative(1)))\n\nNote that, instead, we could have constructed the original matrix mathbfL, which, as expected, is equal to mathbfR up to a sign:\n\nLgal = galerkin_matrix(R, (Derivative(0), Derivative(2)))\n\nAs in the collocation example, we include the heat diffusivity ν in the mathbfR matrix:\n\nparent(Rgal) .*= -ν  # we can't directly multiply Rgal, as it's a Hermitian wrapper\n\nWe finally solve using DifferentialEquations.jl. Note that not much is changed compared to the collocation example. The only difference is that we use a Cholesky factorisation for the mass matrix mathbfA.\n\nparams_gal = (\n    A = cholesky(Agal),\n    L = Rgal,\n)\n\nprob = ODEProblem{true}(heat_rhs!, u_init, tspan, params_gal)\nsol_galerkin = solve(prob, Tsit5(); saveat = 0.5)\n\nplot_heat_solution(sol_galerkin, R)","category":"section"},{"location":"generated/heat/#Result-comparison","page":"Heat equation","title":"Result comparison","text":"The solution of the Galerkin method looks very similar to the one obtained with the collocation method. However, as seen below, there are non-negligible differences between the two.\n\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 2.0)  # hide\nfig = Figure(size = (800, 400))\nlet ax = Axis(fig[1, 1]; xlabel = rich(\"x\"; font = :italic), ylabel = rich(\"θ(x, t = $(tspan[end]))\"; font = :italic))\n    for pair in (\n            \"Collocation\" => sol_collocation,\n            \"Galerkin\" => sol_galerkin,\n        )\n        label, sol = pair\n        u = last(sol.u)\n        S = Spline(R, u)\n        lines!(ax, -1..1, S; label, linewidth = 2)\n    end\n    axislegend(ax; position = :cb)\nend\nlet ax = Axis(fig[1, 2]; xlabel = rich(\"x\"; font = :italic), ylabel = \"Difference\")\n    Sc = Spline(R, last(sol_collocation.u))\n    Sg = Spline(R, last(sol_galerkin.u))\n    lines!(ax, -1..1, x -> Sc(x) - Sg(x); linewidth = 2)\nend\nfig\n\nCompared to the Galerkin method, there seems to be some additional dissipation in the domain interior when using the collocation method. This hints at the presence of numerical dissipation introduced by this method.\n\nTo finish, we compare the two solutions to a solution at a higher resolution, using a higher number of B-spline knots and a higher B-spline order. This last solution is obtained using the collocation method to allow for better comparisons between both methods.\n\nhi_res = let\n    knots_in = range(-1, 1; length = 101)\n    B = BSplineBasis(BSplineOrder(6), knots_in)\n    R = RecombinedBSplineBasis(B, Derivative(1))\n    θ₀_spline = approximate(θ₀, R)\n    u_init = coefficients(θ₀_spline)\n    xcol = collocation_points(R)\n    Acol = collocation_matrix(R, xcol)\n    Lcol = ν .* collocation_matrix(R, xcol, Derivative(2))\n    params_col = (A = lu(Acol), L = Lcol)\n    prob = ODEProblem{true}(heat_rhs!, u_init, tspan, params_col)\n    sol = solve(prob, Tsit5(); saveat = 0.5)\n    (; R, sol)\nend\n\nfig = Figure(size = (800, 400))\nlet ax = Axis(fig[1, 1])\n    ax.xlabel = rich(\"x\"; font = :italic)\n    ax.ylabel = rich(\"θ(x, t = $(tspan[end]))\"; font = :italic)\n    for pair in (\n            \"Collocation\" => sol_collocation,\n            \"Galerkin\" => sol_galerkin,\n        )\n        label, sol = pair\n        u = last(sol.u)\n        S = Spline(R, u)\n        lines!(ax, -1..1, S; label, linewidth = 2)\n    end\n    let u = last(hi_res.sol.u)\n        S = Spline(hi_res.R, u)\n        lines!(ax, -1..1, S; label = \"Hi-res\", linewidth = 2, linestyle = :dash, color = :gray)\n    end\n    axislegend(ax; position = :cb)\nend\nlet ax = Axis(fig[1, 2]; ylabel = \"Difference with hi-res solution\")\n    ax.xlabel = rich(\"x\"; font = :italic)\n    Sc = Spline(R, last(sol_collocation.u))\n    Sg = Spline(R, last(sol_galerkin.u))\n    S_hi = Spline(hi_res.R, last(hi_res.sol.u))\n    lines!(ax, -1..1, x -> Sc(x) - S_hi(x); label = rich(\"Collocation\"), linewidth = 2)\n    lines!(ax, -1..1, x -> Sg(x) - S_hi(x); label = rich(\"Galerkin\"), linewidth = 2)\n    axislegend(ax; position = :rb)\nend\nfig\n\nWe see that the low-resolution solution with the Galerkin method matches the high-resolution solution. This confirms that the Galerkin method provides higher accuracy than the collocation method when both are used at the same resolution.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"interpolation/#interpolation-api","page":"Data interpolation","title":"Data interpolation","text":"High-level interpolation and fitting of gridded data using B-splines.","category":"section"},{"location":"interpolation/#Functions","page":"Data interpolation","title":"Functions","text":"","category":"section"},{"location":"interpolation/#Types","page":"Data interpolation","title":"Types","text":"","category":"section"},{"location":"interpolation/#BSplineKit.SplineInterpolations.interpolate","page":"Data interpolation","title":"BSplineKit.SplineInterpolations.interpolate","text":"interpolate(x, y, BSplineOrder(k), [bc = nothing])\n\nInterpolate values y at locations x using B-splines of order k.\n\nGrid points x must be real-valued and are assumed to be in increasing order.\n\nReturns a SplineInterpolation which can be evaluated at any intermediate point.\n\nOptionally, one may pass one of the boundary conditions listed in the Boundary conditions section. Currently, the Natural and Periodic boundary conditions are available.\n\nSee also interpolate!.\n\nnote: Periodic boundary conditions\nPeriodic boundary conditions should be used if the interpolated data is supposed to represent a periodic signal. In this case, pass bc = Period(L), where L is the period of the x-axis. Note that the endpoint x[begin] + L should not be included in the x vector.\n\nnote: Cubic periodic splines\nCubic periodic splines (BSplineOrder(4)) are particularly well optimised compared to periodic splines of other orders. Just note that interpolations using cubic periodic splines modify their input (including x and y values).\n\nExamples\n\njulia> xs = -1:0.1:1;\n\njulia> ys = cospi.(xs);\n\njulia> S = interpolate(xs, ys, BSplineOrder(4))\nSplineInterpolation containing the 21-element Spline{Float64}:\n basis: 21-element BSplineBasis of order 4, domain [-1.0, 1.0]\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3  …  0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1.0, 1.0, 1.0, 1.0]\n coefficients: [-1.0, -1.00111, -0.8975, -0.597515, -0.314147, 1.3265e-6, 0.314142, 0.597534, 0.822435, 0.96683  …  0.96683, 0.822435, 0.597534, 0.314142, 1.3265e-6, -0.314147, -0.597515, -0.8975, -1.00111, -1.0]\n interpolation points: -1.0:0.1:1.0\n\njulia> S(-1)\n-1.0\n\njulia> (Derivative(1) * S)(-1)\n-0.01663433622896893\n\njulia> (Derivative(2) * S)(-1)\n10.527273287554928\n\njulia> Snat = interpolate(xs, ys, BSplineOrder(4), Natural())\nSplineInterpolation containing the 21-element Spline{Float64}:\n basis: 21-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0], BCs {left => (D{2},), right => (D{2},)}\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4  …  0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0]\n coefficients: [-0.833333, -0.647516, -0.821244, -0.597853, -0.314057, -2.29076e-5, 0.314148, 0.597532, 0.822435, 0.96683  …  0.96683, 0.822435, 0.597532, 0.314148, -2.29076e-5, -0.314057, -0.597853, -0.821244, -0.647516, -0.833333]\n interpolation points: -1.0:0.1:1.0\n\njulia> Snat(-1)\n-1.0\n\njulia> (Derivative(1) * Snat)(-1)\n0.2872618670889516\n\njulia> (Derivative(2) * Snat)(-1)\n-3.33066907387547e-14\n\n\nPeriodic boundary conditions\n\nInterpolate f(x) = cos(πx) for x  -1 1). Note that the period is L = 2 and that the endpoint (x = 1) must not be included in the data points.\n\njulia> xp = -1:0.1:0.9;\n\njulia> yp = cospi.(xp);\n\njulia> Sper = interpolate(xp, yp, BSplineOrder(4), Periodic(2))\nSplineInterpolation containing the 20-element Spline{Float64}:\n basis: 20-element PeriodicBSplineBasis of order 4, domain [-1.0, 1.0), period 2.0\n order: 4\n knots: [..., -1.2, -1.1, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3  …  0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, ...]\n coefficients: [..., -1.01659, -0.96683, -0.822435, -0.597534, -0.314142, 1.10589e-17, 0.314142, 0.597534, 0.822435, 0.96683, 1.01659, 0.96683, 0.822435, 0.597534, 0.314142, 1.51788e-17, -0.314142, -0.597534, -0.822435, -0.96683, ...]\n interpolation points: -1.0:0.1:0.9\n\nAs expected, the periodic spline does a better job at approximating the periodic function f(x) = cos(πx) near the boundaries than the other interpolations:\n\njulia> x = -0.99; cospi(x), Sper(x), Snat(x), S(x)\n(-0.9995065603657316, -0.9995032595823043, -0.9971071640321145, -0.9996420091470221)\n\njulia> x = 0.998; cospi(x), Sper(x), Snat(x), S(x)\n(-0.9999802608561371, -0.9999801044078943, -0.9994253145274461, -1.0000122303614758)\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#BSplineKit.SplineInterpolations.interpolate!","page":"Data interpolation","title":"BSplineKit.SplineInterpolations.interpolate!","text":"interpolate!(I::SplineInterpolation, y::AbstractVector)\n\nUpdate spline interpolation with new data.\n\nThis function allows to reuse a SplineInterpolation returned by a previous call to interpolate, using new data on the same locations x.\n\nSee interpolate for details.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#StatsAPI.fit","page":"Data interpolation","title":"StatsAPI.fit","text":"fit(BSplineOrder(4), xs, ys, λ::Real, [bc = Natural()]; [weights = nothing])\n\nFit a cubic smoothing spline to the given data.\n\nReturns a cubic spline which roughly passes through the data (points (xs[i], ys[i])) given some smoothing parameter λ. Note that λ = 0 means no smoothing and the results are equivalent to all the data.\n\nOne can optionally pass a weights vector if one desires to give different weights to different data points (e.g. if one wants the curve to pass as close as possible to a specific point). By default all weights are w_i = 1.\n\nMore precisely, the returned spline S(x) minimises:\n\n_i = 1^N w_i y_i - S(x_i)^2 + λ _x_1^x_N left S(x) right^2  mathrmdx\n\nOnly cubic splines (BSplineOrder(4)) are currently supported. One must explicitly pass BSplineOrder(4) as a first argument to avoid collisions with other implementations of StatsAPI.fit.\n\nThe boundary condition (bc) must be Periodic for a periodic spline or Natural otherwise (this is the default). (Currently, the periodic case can be much slower than the default natural condition.)\n\nExamples\n\njulia> xs = (0:0.01:1).^2;\n\njulia> ys = @. cospi(2 * xs) + 0.1 * sinpi(200 * xs);  # smooth + highly fluctuating components\n\njulia> λ = 0.001;  # smoothing parameter\n\njulia> S = fit(BSplineOrder(4), xs, ys, λ)\n101-element Spline{Float64}:\n basis: 101-element RecombinedBSplineBasis of order 4, domain [0.0, 1.0], BCs {left => (D{2},), right => (D{2},)}\n order: 4\n knots: [0.0, 0.0, 0.0, 0.0, 0.0001, 0.0004, 0.0009, 0.0016, 0.0025, 0.0036  …  0.8836, 0.9025, 0.9216, 0.9409, 0.9604, 0.9801, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.946872, 0.631018, 1.05101, 1.04986, 1.04825, 1.04618, 1.04366, 1.04067, 1.03722, 1.03331  …  0.437844, 0.534546, 0.627651, 0.716043, 0.798813, 0.875733, 0.947428, 1.01524, 0.721199, 0.954231]\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#BSplineKit.SplineInterpolations.SplineInterpolation","page":"Data interpolation","title":"BSplineKit.SplineInterpolations.SplineInterpolation","text":"SplineInterpolation\n\nSpline interpolation.\n\nThis is the type returned by interpolate.\n\nA SplineInterpolation I can be evaluated at any point x using the I(x) syntax.\n\nIt can also be updated with new data on the same data points using interpolate!.\n\n\n\nSplineInterpolation(undef, B::AbstractBSplineBasis, x::AbstractVector, [T = eltype(x)])\n\nInitialise a SplineInterpolation from B-spline basis and a set of interpolation (or collocation) points x.\n\nNote that the length of x must be equal to the number of B-splines.\n\nUse interpolate! to actually interpolate data known on the x locations.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplines-api","page":"B-splines","title":"B-splines","text":"","category":"section"},{"location":"bsplines/#B-spline-bases","page":"B-splines","title":"B-spline bases","text":"","category":"section"},{"location":"bsplines/#Periodic-B-spline-bases","page":"B-splines","title":"Periodic B-spline bases","text":"","category":"section"},{"location":"bsplines/#Basis-functions","page":"B-splines","title":"Basis functions","text":"","category":"section"},{"location":"bsplines/#Internals","page":"B-splines","title":"Internals","text":"","category":"section"},{"location":"bsplines/#BSplineKit.BSplines","page":"B-splines","title":"BSplineKit.BSplines","text":"BSplines\n\nModule defining B-spline bases and B-spline related functions.\n\n\n\n\n\n","category":"module"},{"location":"bsplines/#BSplineKit.BSplines.AbstractBSplineBasis","page":"B-splines","title":"BSplineKit.BSplines.AbstractBSplineBasis","text":"AbstractBSplineBasis{k,T}\n\nAbstract type defining a B-spline basis, or more generally, a functional basis defined from B-splines.\n\nThe basis is represented by a B-spline order k and a knot element type T.\n\n\n\n(B::AbstractBSplineBasis)(\n    x::Real, [op = Derivative(0)], [T = float(typeof(x))];\n    [ileft = nothing],\n) -> (i, bs)\n\nEvaluates all basis functions which are non-zero at x.\n\nThis is a convenience alias for evaluate_all. See evaluate_all for details on optional arguments and on the returned values.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.1:1)\n23-element BSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4  …  0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0]\n\njulia> i, bs = B(0.42)\n(18, (0.0013333333333333268, 0.28266666666666657, 0.6306666666666667, 0.08533333333333339))\n\njulia> sum(bs)\n1.0\n\njulia> bs[1] - B[i](0.42)\n0.0\n\njulia> bs[2] - B[i - 1](0.42)\n-5.551115123125783e-17\n\njulia> B(0.44; ileft = i)\n(18, (0.01066666666666666, 0.4146666666666667, 0.5386666666666665, 0.03599999999999999))\n\njulia> B(0.42, Float32)\n(18, (0.0013333336f0, 0.28266668f0, 0.6306667f0, 0.085333325f0))\n\njulia> B(0.42, Derivative(1))\n(18, (0.19999999999999937, 6.4, -3.3999999999999977, -3.200000000000001))\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.BSplineBasis","page":"B-splines","title":"BSplineKit.BSplines.BSplineBasis","text":"BSplineBasis{k, T}\n\nB-spline basis for splines of order k and knot element type T <: Real.\n\nThe basis is defined by a set of knots and by the B-spline order.\n\n\n\nBSplineBasis(order::BSplineOrder{k}, ts::AbstractVector; augment = Val(true))\nBSplineBasis(order::BSplineOrder{k}, ts::NTuple; augment = Val(true))\n\nCreate B-spline basis of order k with breakpoints ts.\n\nIf augment = Val(true), breakpoints will be \"augmented\" so that boundary knots have multiplicity k. Note that, if they are passed as a regular Vector, the input may be modified. See augment_knots! for details.\n\nExamples\n\njulia> breaks = range(-1, 1; length = 21)\n-1.0:0.1:1.0\n\njulia> B = BSplineBasis(BSplineOrder(5), breaks)\n24-element BSplineBasis of order 5, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5  …  0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0, 1.0]\n\nNote that first and last knots are repeated k = 5 times.\n\nIf augment = Val(false), input breakpoints are taken without modification as the knots t_i of the B-spline basis. Note that the valid domain is reduced to -06 06. The domain is always defined as the range t_k t_N + 1, where N is the length of the basis (below, N = 16).\n\njulia> Bn = BSplineBasis(5, breaks, augment = Val(false))\n16-element BSplineBasis of order 5, domain [-0.6, 0.6]\n knots: -1.0:0.1:1.0\n\nStatically-sized bases\n\nTo define a basis with static size (i.e. size known at compile time), the breakpoints ts should be passed as a tuple or as an SVector (from the StaticArrays package):\n\njulia> breaks = (0.0, 0.1, 0.2, 0.6, 1.0);\n\njulia> B = BSplineBasis(BSplineOrder(3), breaks)\n6-element BSplineBasis of order 3, domain [0.0, 1.0]\n knots: [0.0, 0.0, 0.0, 0.1, 0.2, 0.6, 1.0, 1.0, 1.0]\n\njulia> knots(B)\n9-element StaticArraysCore.SVector{9, Float64} with indices SOneTo(9):\n 0.0\n 0.0\n 0.0\n 0.1\n 0.2\n 0.6\n 1.0\n 1.0\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.boundaries","page":"B-splines","title":"BSplineKit.BSplines.boundaries","text":"boundaries(B::AbstractBSplineBasis)\n\nReturns (xmin, xmax) tuple with the boundaries of the domain supported by the basis.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.order","page":"B-splines","title":"BSplineKit.BSplines.order","text":"order(::Type{AbstractBSplineBasis}) -> Int\norder(::AbstractBSplineBasis) -> Int\norder(::Type{Spline}) -> Int\norder(::BSplineOrder) -> Int\n\nReturns order of B-splines as an integer.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.knots","page":"B-splines","title":"BSplineKit.BSplines.knots","text":"knots(B::AbstractBSplineBasis)\nknots(g::Spline)\n\nReturns the knots of the B-spline basis.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Base.getindex","page":"B-splines","title":"Base.getindex","text":"getindex(B::AbstractBSplineBasis, i, [T = Float64])\n\nGet i-th basis function.\n\nThis is an alias for BasisFunction(B, i, T) (see BasisFunction for details).\n\nThe returned object can be evaluated at any point within the boundaries defined by the basis.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.1:1)\n23-element BSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4  …  0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0]\n\njulia> B[6]\nBasis function i = 6\n  from 23-element BSplineBasis of order 4, domain [-1.0, 1.0]\n  support: [-0.8, -0.4) (knots 6:10)\n\njulia> B[6](-0.5)\n0.16666666666666666\n\njulia> B[6, Float32](-0.5)\n0.16666667f0\n\njulia> B[6](-0.5, Derivative(1))\n-5.000000000000001\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Base.length-Tuple{BSplineBasis}","page":"B-splines","title":"Base.length","text":"length(g::BSplineBasis) -> Int\n\nReturns the number of B-splines composing a spline.\n\n\n\n\n\n","category":"method"},{"location":"bsplines/#BSplineKit.BSplines.isindomain","page":"B-splines","title":"BSplineKit.BSplines.isindomain","text":"isindomain(B::AbstractBSplineBasis, x::Real)\n\nCheck if the coordinate x is within the boundaries of the domain.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.PeriodicBSplineBasis","page":"B-splines","title":"BSplineKit.BSplines.PeriodicBSplineBasis","text":"PeriodicBSplineBasis{k, T}\n\nB-spline basis for splines of order k and knot element type T <: Real.\n\nThe basis is defined by a set of knots and by the B-spline order.\n\n\n\nPeriodicBSplineBasis(order::BSplineOrder{k}, ts::AbstractVector)\n\nCreate periodic B-spline basis of order k with knots ts.\n\nThe knot period is taken to be L = ts[end] - ts[begin].\n\nExamples\n\nCreate B-spline basis on periodic domain with period L = 2.\n\njulia> ts = range(-1, 1; length = 11)\n-1.0:0.2:1.0\n\njulia> B = PeriodicBSplineBasis(BSplineOrder(4), ts)\n10-element PeriodicBSplineBasis of order 4, domain [-1.0, 1.0), period 2.0\n knots: [..., -1.4, -1.2, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, ...]\n\njulia> period(B)\n2.0\n\njulia> length(B)\n10\n\njulia> boundaries(B)\n(-1.0, 1.0)\n\njulia> B(-0.42)\n(5, (0.12150000000000002, 0.6571666666666667, 0.22116666666666668, 0.00016666666666666563))\n\njulia> B(-0.42 + 2)\n(15, (0.12150000000000015, 0.6571666666666667, 0.22116666666666657, 0.00016666666666666674))\n\njulia> knots(B)\n14-element PeriodicKnots{Float64, 4, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}:\n -1.4\n -1.2\n -1.0\n -0.8\n -0.6\n -0.4\n -0.2\n  0.0\n  0.2\n  0.4\n  0.6\n  0.8\n  1.0\n  1.2\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.PeriodicKnots","page":"B-splines","title":"BSplineKit.BSplines.PeriodicKnots","text":"PeriodicKnots{T} <: AbstractVector{T}\n\nDescribes an infinite vector of knots with periodicity L.\n\n\n\nPeriodicKnots(ξs::AbstractVector{T}, ::BSplineOrder{k})\n\nConstruct a periodic knot sequence from breakpoints ξs.\n\nThe knot period is taken to be L = ξs[end] - ξs[begin]. In other words, the breakpoints ξs are expected to include the endpoint ξs[begin] + L.\n\nThe breakpoints should be given in non-decreasing order.\n\nNote that the indices of the returned knots ts are offset with respect to the input ξs according to ts[i] = ξs[i + offset] where offset = k ÷ 2.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BoundaryConditions.period","page":"B-splines","title":"BSplineKit.BoundaryConditions.period","text":"period(bc::Periodic) -> Real\nperiod(B::PeriodicBSplineBasis) -> Real\nperiod(ts::PeriodicKnots) -> Real\n\nReturns the period L associated to a periodic boundary condition or B-spline basis.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.BasisFunction","page":"B-splines","title":"BSplineKit.BSplines.BasisFunction","text":"BasisFunction{B <: AbstractBSplineBasis, T}\n\nDescribes a single basis function.\n\nThe basis function may belong to a BSplineBasis (in which case it's effectively a B-spline), or to a basis derived from a B-spline basis (such as a RecombinedBSplineBasis).\n\n\n\nBasisFunction(basis::AbstractBSplineBasis, i::Int, [T = Float64])\n\nConstruct i-th basis function of the given basis.\n\nThe constructed function can be evaluated as b(x), returning a value of type T.\n\n\n\n(b::BasisFunction)(x, [op::AbstractDifferentialOp])\n\nEvaluate basis function at coordinate x.\n\nTo evaluate a derivative, pass Derivative(n) as the op argument, with n the derivative order.\n\nTo evaluate multiple derivatives, pass a derivative range Derivative(m:n). In particular, Derivative(m:n) evaluates the basis function itself and its first n derivatives.\n\nMore general differential operators, such as Derivative(n) + λ Derivative(m), are also supported.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.support","page":"B-splines","title":"BSplineKit.BSplines.support","text":"support(b::BasisFunction) -> UnitRange{Int}\n\nGet range of knots supported by the basis function.\n\nReturns the knot range i:j such that the basis function support is t  t_i t_j).\n\n\n\n\n\nsupport(B::AbstractBSplineBasis, i::Integer) -> UnitRange{Int}\n\nGet range of knots supported by the i-th basis function.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.common_support","page":"B-splines","title":"BSplineKit.BSplines.common_support","text":"common_support(b1::BasisFunction, b2::BasisFunction, ...) -> UnitRange{Int}\n\nGet range of knots commonly supported by different basis functions.\n\nIf the supports don't intersect, an empty range is returned (e.g. 6:5), following the behaviour of intersect. The lack of intersection can be checked using isempty, which returns true for such a range.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.find_knot_interval","page":"B-splines","title":"BSplineKit.BSplines.find_knot_interval","text":"find_knot_interval(ts::AbstractVector, x::Real, [ileft = nothing]) -> (i, zone)\n\nFinds the index i corresponding to the knot interval t_i t_i + 1 that should be used to evaluate B-splines at location x.\n\nThe knot vector is assumed to be sorted in non-decreasing order.\n\nIt also returns a zone integer, which is:\n\n0  if x is within the knot domain (ts[begin] ≤ x ≤ ts[end]),\n-1 if x < ts[begin],\n1  if x > ts[end].\n\nThis function is functionally equivalent to de Boor's INTERV routine (de Boor 2001, p. 74).\n\nIf one already knows the location i associated to the knot interval, then one can pass it as the optional ileft argument, in which case only the zone needs to be computed.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate_all","page":"B-splines","title":"BSplineKit.BSplines.evaluate_all","text":"evaluate_all(\n    B::AbstractBSplineBasis, x::Real,\n    [op = Derivative(0)], [T = float(typeof(x))];\n    [ileft = nothing],\n) -> i, bs\n\nEvaluate all B-splines which are non-zero at coordinate x.\n\nReturns a tuple (i, bs), where i is an index identifying the basis functions that were computed, and bs is a tuple with the actual values.\n\nMore precisely:\n\ni is the index of the first B-spline knot t_i when going from x towards the left. In other words, it is such that t_i  x  t_i + 1.\nIt can be effectively computed as i = searchsortedlast(knots(B), x). If the correct value of i is already known, one can avoid this computation by manually passing this index via the optional ileft keyword argument.\nbs is a tuple of B-splines evaluated at x:\n(b_i(x) b_i - 1(x)  b_i - k + 1(x))\nIt contains k values, where k is the order of the B-spline basis. Note that values are returned in backwards order starting from the i-th B-spline.\n\nComputing derivatives\n\nOne can pass the optional op argument to compute B-spline derivatives instead of the actual B-spline values.\n\nExamples\n\nSee AbstractBSplineBasis for some examples using the alternative evaluation syntax B(x, [op], [T]; [ileft]), which calls this function.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate","page":"B-splines","title":"BSplineKit.BSplines.evaluate","text":"evaluate(B::AbstractBSplineBasis, i::Integer, x,\n         [op::AbstractDifferentialOp], [T=Float64])\n\nEvaluate i-th basis function in the given basis at x (can be a coordinate or a vector of coordinates).\n\nTo evaluate a derivative, pass Derivative(n) as the op argument, with n the derivative order.\n\nMore general differential operators, such as Derivative(n) + λ Derivative(m), are also supported.\n\nSee also evaluate!.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate!","page":"B-splines","title":"BSplineKit.BSplines.evaluate!","text":"evaluate!(b::AbstractVector, B::BSplineBasis, i::Integer,\n          x::AbstractVector, args...)\n\nEvaluate i-th basis function at positions x and write result to b.\n\nSee also evaluate.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.nonzero_in_segment","page":"B-splines","title":"BSplineKit.BSplines.nonzero_in_segment","text":"nonzero_in_segment(B::AbstractBSplineBasis, n::Int) -> UnitRange{Int}\n\nReturns the range of basis functions that are non-zero in a given knot segment.\n\nThe n-th knot segment is defined by Ω_n = t_n t_n + 1.\n\nFor BSplineBasis and RecombinedBSplineBasis, the number of non-zero functions in any given segment is generally equal to the B-spline order k. This number decreases near the borders, but this is not significant when B-spline knots have multiplicity k there (as is the default).\n\nFor B-spline bases, and excepting the borders, the non-zero B-splines are left b_i right_i = n - k + 1^n. This function thus returns (n - k + 1):N when B is a BSplineBasis.\n\nSee also support for the inverse operation.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.BSplineOrder","page":"B-splines","title":"BSplineKit.BSplines.BSplineOrder","text":"BSplineOrder(k::Integer)\n\nSpecifies the B-spline order k.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.AugmentedKnots","page":"B-splines","title":"BSplineKit.BSplines.AugmentedKnots","text":"AugmentedKnots{T,k} <: AbstractVector{T}\n\nPads from both sides a vector of B-spline breakpoints, making sure that the first and last values are repeated k times.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.augment_knots!","page":"B-splines","title":"BSplineKit.BSplines.augment_knots!","text":"augment_knots!(breaks::AbstractVector, k::Union{Integer,BSplineOrder})\n\nModifies the input breakpoints to make sure that the first and last knot have multiplicity k for splines of order k.\n\nTo prevent allocations, this function will modify the input when this is a standard Vector. Otherwise, the input will be wrapped inside an AugmentedKnots object.\n\nIt is assumed that the input breakpoints have multiplicity 1 at the borders. That is, border coordinates should not be repeated in the input.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.basis_to_array_index","page":"B-splines","title":"BSplineKit.BSplines.basis_to_array_index","text":"basis_to_array_index(B::AbstractBSplineBasis, axs, i::Int) -> Int\n\nConverts from a basis index i (for basis function b_i) to a valid index in an array A with indices axs, where axs is typically the result of axes(A, dim) for a given dimension dim.\n\nThis is mainly relevant for periodic bases, in which case i may be outside of the \"main\" period of the basis.\n\nIt is assumed that length(B) == length(axs) (this is not checked by this function).\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.has_parent_basis","page":"B-splines","title":"BSplineKit.BSplines.has_parent_basis","text":"has_parent_basis(::Type{<:AbstractBSplineBasis}) -> Bool\nhas_parent_basis(::AbstractBSplineBasis) -> Bool\n\nTrait determining whether a basis has a parent B-spline basis.\n\nThis is notably the case for RecombinedBSplineBasis, which are derived from regular B-spline bases.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.static_length","page":"B-splines","title":"BSplineKit.BSplines.static_length","text":"static_length(::Type{<:AbstractBSplineBasis}) -> Union{Int, Nothing}\nstatic_length(::AbstractBSplineBasis) -> Union{Int, Nothing}\n\nReturn the basis' length if it is statically known (i.e. at compile time); return nothing otherwise.\n\nTypically, bases with statically-known length are those constructed using an SVector (from the StaticArrays package) to describe the basis breakpoints.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.multiplicity","page":"B-splines","title":"BSplineKit.BSplines.multiplicity","text":"multiplicity(knots, i)\n\nDetermine multiplicity of knot knots[i].\n\n\n\n\n\n","category":"function"},{"location":"diffops/#Differential-operators","page":"Differential operators","title":"Differential operators","text":"","category":"section"},{"location":"diffops/#Operators","page":"Differential operators","title":"Operators","text":"","category":"section"},{"location":"diffops/#Projections","page":"Differential operators","title":"Projections","text":"","category":"section"},{"location":"diffops/#BSplineKit.DifferentialOps","page":"Differential operators","title":"BSplineKit.DifferentialOps","text":"DifferentialOps\n\nModule defining types describing differential operators and compositions thereof.\n\n\n\n\n\n","category":"module"},{"location":"diffops/#BSplineKit.DifferentialOps.AbstractDifferentialOp","page":"Differential operators","title":"BSplineKit.DifferentialOps.AbstractDifferentialOp","text":"AbstractDifferentialOp\n\nRepresents a general differential operator.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.Derivative","page":"Differential operators","title":"BSplineKit.DifferentialOps.Derivative","text":"Derivative{n} <: AbstractDifferentialOp\n\nSpecifies the n-th derivative of a function.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.DerivativeUnitRange","page":"Differential operators","title":"BSplineKit.DifferentialOps.DerivativeUnitRange","text":"DerivativeUnitRange{m, n} <: AbstractDifferentialOp\n\nSpecifies a range of derivatives.\n\nExamples\n\nTwo ways of constructing derivative ranges:\n\njulia> Derivative(2):Derivative(4)\nDerivative(2:4)\n\njulia> Derivative(2:4)\nDerivative(2:4)\n\njulia> Tuple(Derivative(2:4))\n(D{2}, D{3}, D{4})\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.ScaledDerivative","page":"Differential operators","title":"BSplineKit.DifferentialOps.ScaledDerivative","text":"ScaledDerivative{n} <: AbstractDifferentialOp\n\nn-th derivative of a function scaled by a constant coefficient.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.DifferentialOpSum","page":"Differential operators","title":"BSplineKit.DifferentialOps.DifferentialOpSum","text":"DifferentialOpSum <: AbstractDifferentialOp\n\nSum of two differential operators.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.max_order","page":"Differential operators","title":"BSplineKit.DifferentialOps.max_order","text":"max_order(op::AbstractDifferentialOp)\nmax_order(ops...)\n\nGet maximum derivative order of one or more differential operators.\n\n\n\n\n\n","category":"function"},{"location":"diffops/#BSplineKit.DifferentialOps.AbstractNormalDirection","page":"Differential operators","title":"BSplineKit.DifferentialOps.AbstractNormalDirection","text":"AbstractNormalDirection\n\nRepresents the normal direction on a given domain boundary.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.LeftNormal","page":"Differential operators","title":"BSplineKit.DifferentialOps.LeftNormal","text":"LeftNormal <: AbstractNormalDirection\n\nSpecifies the normal direction on the left boundary of a 1D domain.\n\nThe left normal direction goes opposite to the coordinate axis.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.RightNormal","page":"Differential operators","title":"BSplineKit.DifferentialOps.RightNormal","text":"RightNormal <: AbstractNormalDirection\n\nSpecifies the normal direction on the right boundary of a 1D domain.\n\nThe right normal direction is equal to that of the coordinate axis.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#LinearAlgebra.dot-Tuple{BSplineKit.DifferentialOps.AbstractDifferentialOp, BSplineKit.DifferentialOps.AbstractNormalDirection}","page":"Differential operators","title":"LinearAlgebra.dot","text":"dot(op::AbstractDifferentialOp, dir::AbstractNormalDirection) -> AbstractDifferentialOp\n\nProject derivative along a normal direction.\n\nThis should be used to convert from a normal derivative at the boundaries, to a derivative along the coordinate axes of the domain.\n\nIn practice, this returns op for RightNormal. For LeftNormal, it multiplies the odd-order derivatives by -1.\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#boundary-conditions-api","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions/#BSplineKit.BoundaryConditions","page":"Boundary conditions","title":"BSplineKit.BoundaryConditions","text":"BSplineKit.BoundaryConditions\n\nContains some boundary condition definitions.\n\n\n\n\n\n","category":"module"},{"location":"boundary_conditions/#BSplineKit.BoundaryConditions.Natural","page":"Boundary conditions","title":"BSplineKit.BoundaryConditions.Natural","text":"Natural <: BoundaryCondition\n\nGeneralised natural boundary condition.\n\nThis boundary condition is convenient for spline interpolations, as it provides extra constraints enabling to equate the number of unique B-spline knots to the number of data points.\n\nFor cubic splines (order k = 4), this corresponds to natural cubic splines, imposing the second derivatives to be zero at the boundaries (S(a) = S(b) = 0).\n\nFor higher-order splines, this boundary condition generalises the standard natural cubic splines, by setting derivatives of order 2 3  k2 to be zero at the boundaries. For instance, for k = 6 (quintic splines), this imposes S = S = 0. In practice, BSplineKit.jl achieves this by using basis recombination.\n\nNote that, for symmetry reasons, only even-order splines are supported by this BC.\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#BSplineKit.BoundaryConditions.Periodic","page":"Boundary conditions","title":"BSplineKit.BoundaryConditions.Periodic","text":"Periodic <: BoundaryCondition\n\nRepresents periodic boundary conditions with a given period L.\n\n\n\nPeriodic(L::Real)\n\nConstructs periodic boundary conditions with period L.\n\n\n\n\n\n","category":"type"},{"location":"galerkin/#galerkin-api","page":"Galerkin tools","title":"Galerkin tools","text":"","category":"section"},{"location":"galerkin/#Projections","page":"Galerkin tools","title":"Projections","text":"","category":"section"},{"location":"galerkin/#Matrices","page":"Galerkin tools","title":"Matrices","text":"","category":"section"},{"location":"galerkin/#Banded-3D-tensors","page":"Galerkin tools","title":"Banded 3D tensors","text":"","category":"section"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_projection","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_projection","text":"galerkin_projection(\n    f, B::AbstractBSplineBasis,\n    [deriv = Derivative(0)], [VectorType = Vector{Float64}],\n)\n\nPerform Galerkin projection of a function f onto the given basis.\n\nBy default, returns a vector with values\n\nφ_i =  b_i f \n= _a^b b_i(x)  f(x)  mathrmdx\n\nwhere a and b are the boundaries of the B-spline basis  b_i _i = 1^N.\n\nThe integrations are performed using Gauss–Legendre quadrature. The number of quadrature nodes is chosen so that the result is exact when f is a polynomial of degree k - 1 (or, more generally, a spline belonging to the space spanned by the basis B). Here k is the order of the B-spline basis. In the more general case, this function returns a quadrature approximation of the projection.\n\nSee also galerkin_projection! for the in-place operation, and galerkin_matrix for more details.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_projection!","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_projection!","text":"galerkin_projection!(\n    f, φ::AbstractVector, B::AbstractBSplineBasis, [deriv = Derivative(0)],\n)\n\nCompute Galerkin projection φ_i =  b_i f .\n\nSee galerkin_projection for details.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_matrix","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_matrix","text":"galerkin_matrix(\n    [f::Function],\n    B::AbstractBSplineBasis,\n    [derivatives = (Derivative(0), Derivative(0))],\n    [MatrixType = BandedMatrix{Float64}];\n    [quadrature = default_quadrature((B, B))],\n)\n\nCompute Galerkin mass or stiffness matrix, as well as more general variants of these.\n\nExtended help\n\nThe Galerkin mass matrix is defined as\n\nM_ij =  ϕ_i ϕ_j  quad textfor quad\ni  1 N text and  j  1 N\n\nwhere ϕ_i(x) is the i-th basis function and N = length(B) is the number of functions in the basis B. Here, f g is the L^2 inner product between functions f and g.\n\nSince products of B-splines are themselves piecewise polynomials, integrals can be computed exactly using Gaussian quadrature rules. To do this, we use Gauss–Legendre quadratures via the FastGaussQuadrature package.\n\nMatrix layout and types\n\nThe mass matrix is banded with 2k - 1 bands. Moreover, the matrix is symmetric and positive definite, and only k bands are needed to fully describe the matrix. Hence, a Hermitian view of an underlying matrix is returned.\n\nBy default, the underlying matrix holding the data is a BandedMatrix that defines the upper part of the symmetric matrix. Other types of container are also supported, including regular sparse matrices (SparseMatrixCSC) and dense arrays (Matrix). See collocation_matrix for a discussion on matrix types.\n\nnote: Periodic B-spline bases\nThe default matrix type is BandedMatrix, except for periodic bases (PeriodicBSplineBasis), in which case the Galerkin matrix has a few out-of-bands entries due to periodicity. For periodic bases, SparseMatrixCSC is the default. Note that this may change in the future.\n\nDerivatives of basis functions\n\nGalerkin matrices associated to the derivatives of basis functions may be constructed using the optional derivatives parameter. For instance, if derivatives = (Derivative(0), Derivative(2)), the matrix  ϕ_i ϕ_j  is constructed, where primes denote derivatives. Note that, if the derivative orders are different, the resulting matrix is not symmetric, and a Hermitian view is not returned in those cases.\n\nCombining different bases\n\nMore generally, it is possible to compute matrices of the form  ψ_i^(n) ϕ_j^(m) , where n and m are derivative orders, and ψ_i and ϕ_j belong to two different (but related) bases B₁ and B₂. For this, instead of the B parameter, one must pass a tuple of bases (B₁, B₂). The restriction is that the bases must have the same parent B-spline basis. That is, they must share the same set of B-spline knots and be of equal polynomial order.\n\nNote that, if both bases are different, the matrix will not be symmetric, and will not even be square if the bases have different lengths.\n\nIn practice, this feature may be used to combine a B-spline basis B, with a recombined basis R generated from B (see Basis recombination).\n\nIntegrating more general functions\n\nSay we wanted to integrate the more general term\n\nL_ij =  f(x) ϕ_i(x) ϕ_j(x)  = _a^b f(x) ϕ_i(x) ϕ_j(x)  mathrmdx\n\nTo obtain an approximation of this matrix, one would pass the f(x) function as a first positional argument to galerkin_matrix (or galerkin_matrix!). This can also be combined with the derivatives argument if one wants to consider derivatives of ϕ_i or ϕ_j.\n\nNote that, in this case, the computation of the integrals is not guaranteed to be exact, since Gauss–Legendre quadratures are only \"exact\" when the integrand is a polynomial (the product of two B-splines is a piecewise polynomial). To improve accuracy, one may want to increase the number n of quadrature nodes. For this, pass quadrature = Galerkin.gausslegendre(Val(n)) as a keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_matrix!","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_matrix!","text":"galerkin_matrix!(\n    [f::Function], A::AbstractMatrix, B::AbstractBSplineBasis, [deriv = (Derivative(0), Derivative(0))];\n    [quadrature],\n)\n\nFill preallocated Galerkin matrix.\n\nThe matrix may be a Hermitian view, in which case only one half of the matrix will be filled. Note that, for the matrix to be symmetric, both derivative orders in deriv must be the same.\n\nMore generally, it is possible to combine different functional bases by passing a tuple of AbstractBSplineBasis as B.\n\nSee galerkin_matrix for details on arguments.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_tensor","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_tensor","text":"galerkin_tensor(\n    B::AbstractBSplineBasis,\n    (D₁::Derivative, D₂::Derivative, D₃::Derivative),\n    [T = Float64],\n)\n\nCompute 3D banded tensor appearing from quadratic terms in Galerkin method.\n\nAs with galerkin_matrix, it is also possible to combine different functional bases by passing, instead of B, a tuple (B₁, B₂, B₃) of three AbstractBSplineBasis. For now, the first two bases, B₁ and B₂, must have the same length.\n\nThe tensor is efficiently stored in a BandedTensor3D object.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_tensor!","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_tensor!","text":"galerkin_tensor!(\n    A::BandedTensor3D,\n    B::AbstractBSplineBasis,\n    (D₁::Derivative, D₂::Derivative, D₃::Derivative),\n)\n\nCompute 3D Galerkin tensor in-place.\n\nSee galerkin_tensor for details.\n\n\n\n\n\n","category":"function"},{"location":"generated/approximation/#function-approximation-example","page":"Function approximation","title":"Function approximation","text":"The objective of this example is to approximate a known function f by a spline.","category":"section"},{"location":"generated/approximation/#Exact-function","page":"Function approximation","title":"Exact function","text":"We consider the function f(x) = e^-x cos(8πx) in the interval x  0 1.\n\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 2.0)\n\nx_interval = 0..1\nf(x) = exp(-x) * cospi(8x)\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = rich(\"x\"; font = :italic))\nlines!(ax, x_interval, f)\nfig","category":"section"},{"location":"generated/approximation/#Approximation-space","page":"Function approximation","title":"Approximation space","text":"To approximate this function using a spline, we first need to define a B-spline basis  b_i _i = 1^N describing a spline space. The approximating spline can then be written as\n\ng(x) = _i = 1^N c_i b_i(x)\n\nwhere the c_i are the B-spline coefficients describing the spline. The objective is thus to find the coefficients c_i that result in the best possible approximation of the function f.\n\nHere we use splines of order k = 4 (polynomial degree d = 3, i.e. cubic splines). For simplicity, we choose the B-spline knots to be uniformly distributed.\n\nusing BSplineKit\n\nξs = range(x_interval; length = 15)\nB = BSplineBasis(BSplineOrder(4), ξs)\n\nWe plot below the knots and the basis functions describing the spline space. Note that knots are represented by grey crosses.\n\nfunction plot_knots!(ax, ts; ybase = 0, knot_offset = 0.03, kws...)\n    ys = zero(ts) .+ ybase\n    # Add offset to distinguish knots with multiplicity > 1\n    if knot_offset !== nothing\n        for i in eachindex(ts)[(begin + 1):end]\n            if ts[i] == ts[i - 1]\n                ys[i] = ys[i - 1] + knot_offset\n            end\n        end\n    end\n    scatter!(ax, ts, ys; marker = '×', color = :gray, markersize = 24, kws...)\n    ax\nend\n\nfunction plot_basis!(ax, B; eval_args = (), kws...)\n    cmap = cgrad(:tab20)\n    N = length(B)\n    ts = knots(B)\n    hlines!(ax, 0; color = :gray)\n    for (n, bi) in enumerate(B)\n        color = cmap[(n - 1) / (N - 1)]\n        i, j = extrema(support(bi))\n        lines!(ax, ts[i]..ts[j], x -> bi(x, eval_args...); color, linewidth = 2.5)\n    end\n    plot_knots!(ax, ts; kws...)\n    ax\nend\n\nfig = Figure()\nax = Axis(\n    fig[1, 1];\n    xlabel = rich(\"x\"; font = :italic),\n    ylabel = rich(\"b\", subscript(\"i\"), rich(\"(x)\"; offset = (0.1, 0.0)); font = :italic),\n)\nplot_basis!(ax, B; knot_offset = 0.05)\nfig","category":"section"},{"location":"generated/approximation/#Approximating-the-function","page":"Function approximation","title":"Approximating the function","text":"Three different methods are implemented in BSplineKit to approximate functions. In increasing order of accuracy and complexity, these are:","category":"section"},{"location":"generated/approximation/#1.-[VariationDiminishing](@ref)","page":"Function approximation","title":"1. VariationDiminishing","text":"Implements Schoenberg's variation diminishing approximation. This simply consists on estimating the spline coefficients as c_i = f(x_i), where the x_i are the Greville sites. These are obtained by window-averaging the B-spline knots t_j:\n\nx_i = frac1k - 1 _j = 1^k - 1 t_i + j\n\nThis approximation is expected to preserve the shape of the function. However, as shown below, it is usually very inaccurate as an actual approximation, and should only be used when a qualitative estimation of f is sufficient.\n\nS_vd = approximate(f, B, VariationDiminishing())","category":"section"},{"location":"generated/approximation/#2.-[ApproxByInterpolation](@ref)","page":"Function approximation","title":"2. ApproxByInterpolation","text":"Approximates the original function by interpolating on a discrete set of interpolation points. In other words, the resulting spline exactly matches f at those points.\n\nBy default, the interpolation points are chosen as the Greville sites associated to the B-spline basis (using collocation_points; see also Collocation.AvgKnots). For more control, the interpolation points may also be directly set via the ApproxByInterpolation constructor.\n\nIn the below example, we pass the B-spline basis to the ApproxByInterpolation constructor, which automatically determines the collocation points as explained above.\n\nS_interp = approximate(f, B, ApproxByInterpolation(B))  # or simply approximate(f, B)","category":"section"},{"location":"generated/approximation/#3.-[MinimiseL2Error](@ref)","page":"Function approximation","title":"3. MinimiseL2Error","text":"Approximates the function by minimising the L^2 distance between f and its spline approximation g.\n\nIn other words, it minimises\n\nmathcalLg = leftlVert f - g rightrVert^2 = left f - g f - g right\n\nwhere\n\nleft u v right = _a^b u(x)  v(x)  mathrmdx\n\nis the inner product between two functions, and a and b are the boundaries of the prescribed B-spline basis.\n\nOne can show that the optimal coefficients c_i minimising the L^2 error are the solution to the linear system bmM bmc = bmφ, where M_ij = left b_i b_j right and φ_i = left b_i f right. These two terms are respectively computed by galerkin_matrix and galerkin_projection.\n\nIndeed, this can be shown by taking the differential\n\nδmathcalLg = mathcalLg + δg - mathcalLg\n= 2 left δg g - f right\n\nwhere δg is a small perturbation of the spline g. The optimal spline g^*, minimising the L^2 distance, is such that δmathcalLg^* = 0.\n\nNoting that g = c_i b_i (where summing is implicitly performed over repeated indices), the perturbation is given by δg = δc_i b_i, as the B-spline basis is assumed fixed. The optimal spline then satisfies\n\nleft b_i g^* - f right δc_i\n= left left b_i b_j right c_j^* - left b_i f right right δc_i\n= left M_ij c_j^* - φ_i right δc_i\n= 0\n\nfor all perturbations δbmc, leading to the linear system stated above.\n\nAs detailed in galerkin_projection, integrals are computed via Gauss–Legendre quadratures, in a way that ensures that the result is exact when f is a polynomial of degree up to k - 1 (or more generally, a spline belonging to the space spanned by the chosen B-spline basis).\n\nS_minL2 = approximate(f, B, MinimiseL2Error())","category":"section"},{"location":"generated/approximation/#Method-comparison","page":"Function approximation","title":"Method comparison","text":"Below, the approximations using the three methods are compared to the actual function f.\n\nfig = Figure(size = (950, 750))\ncolours = theme(fig.scene).palette.color[]\nstyle_vd = (color = colours[3], label = \"Variation diminishing\")\nstyle_interp = (color = colours[2], label = \"Interpolation\")\nstyle_minL2 = (color = colours[1], label = \"L² minimisation\")\nlet ax = Axis(fig[1:2, 1]; xlabel = rich(\"x\"; font = :italic), ylabel = \"Approximation\")\n    plot_knots!(ax, knots(B); knot_offset = nothing)\n    lines!(ax, x_interval, f; color = :black, linewidth = 2, label = \"Original\")\n    lines!(ax, x_interval, S_vd; style_vd...)\n    lines!(ax, x_interval, S_interp; style_interp...)\n    lines!(ax, x_interval, S_minL2; style_minL2...)\n    axislegend(ax)\nend\nlet ax = Axis(fig[1, 2]; ylabel = \"Difference with original\")\n    plot_knots!(ax, knots(B); knot_offset = nothing)\n    lines!(ax, x_interval, x -> S_interp(x) - f(x); style_interp...)\n    lines!(ax, x_interval, x -> S_minL2(x) - f(x); style_minL2...)\n    hidexdecorations!(ax; grid = false)\n    axislegend(ax; position = :rt, orientation = :horizontal)\nend\nlet ax = Axis(fig[2, 2]; xlabel = rich(\"x\"; font = :italic), ylabel = \"Squared difference\", yscale = log10)\n    ylims!(1e-8, 1e-2)\n    plot_knots!(ax, knots(B); knot_offset = nothing, ybase = 1e-6)\n    lines!(ax, x_interval, x -> abs2(S_interp(x) - f(x)); style_interp...)\n    lines!(ax, x_interval, x -> abs2(S_minL2(x) - f(x)); style_minL2...)\nend\nfig\n\nAs seen above, the variation diminishing approximation, while capturing the shape of the original function, doesn't really provide an accurate approximation of it.\n\nThe other two methods are much more accurate. On the right half of the figure, a detailed comparison of the two is provided, by plotting the difference between each approximation and the actual f function.\n\nThe interpolation method works pretty well, matching exactly the actual function at the interpolation points. Note that, in this example, most interpolation points match the spline knots. This is because we're using splines of even degree (k = 4) and because knots are uniformly spaced.\n\nNevertheless, when looking at the global error, the L^2 minimisation method works best, as expected. In particular, as seen above, it reduces the maximum approximation error (i.e. the L^ distance, leftlVert f - g rightrVert_ = max f(x) - g(x)) compared to the interpolation approach.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"extrapolation/#extrapolation-api","page":"Extrapolation","title":"Extrapolation","text":"Extrapolation of splines. See here for some examples.","category":"section"},{"location":"extrapolation/#Functions","page":"Extrapolation","title":"Functions","text":"","category":"section"},{"location":"extrapolation/#Extrapolation-methods","page":"Extrapolation","title":"Extrapolation methods","text":"","category":"section"},{"location":"extrapolation/#Internals","page":"Extrapolation","title":"Internals","text":"","category":"section"},{"location":"extrapolation/#BSplineKit.SplineExtrapolations.extrapolate","page":"Extrapolation","title":"BSplineKit.SplineExtrapolations.extrapolate","text":"extrapolate(S::Union{Spline, SplineWrapper}, method::AbstractExtrapolationMethod)\n\nConstruct a SplineExtrapolation from the given spline S (which can also be the result of an interpolation).\n\n\n\n\n\n","category":"function"},{"location":"extrapolation/#BSplineKit.SplineExtrapolations.Flat","page":"Extrapolation","title":"BSplineKit.SplineExtrapolations.Flat","text":"Flat <: AbstractExtrapolationMethod\n\nRepresents a flat extrapolation: spline values at domain limits are extended to the left and to the right.\n\n\n\n\n\n","category":"type"},{"location":"extrapolation/#BSplineKit.SplineExtrapolations.Linear","page":"Extrapolation","title":"BSplineKit.SplineExtrapolations.Linear","text":"Linear <: AbstractExtrapolationMethod\n\nRepresents a linear extrapolation: splines values extend linearly beyond the left and right boundaries.\n\n\n\n\n\n","category":"type"},{"location":"extrapolation/#BSplineKit.SplineExtrapolations.Smooth","page":"Extrapolation","title":"BSplineKit.SplineExtrapolations.Smooth","text":"Smooth <: AbstractExtrapolationMethod\n\nRepresents a smooth extrapolation: derivatives up to order k - 2 are continuous at the boundaries.\n\n\n\n\n\n","category":"type"},{"location":"extrapolation/#BSplineKit.SplineExtrapolations.AbstractExtrapolationMethod","page":"Extrapolation","title":"BSplineKit.SplineExtrapolations.AbstractExtrapolationMethod","text":"AbstractExtrapolationMethod\n\nAbstract type representing an extrapolation method.\n\n\n\n\n\n","category":"type"},{"location":"extrapolation/#BSplineKit.SplineExtrapolations.SplineExtrapolation","page":"Extrapolation","title":"BSplineKit.SplineExtrapolations.SplineExtrapolation","text":"SplineExtrapolation\n\nRepresents a spline which can be evaluated outside of its limits according to a given extrapolation method.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#banded-tensors-api","page":"Banded tensors","title":"Banded tensors","text":"","category":"section"},{"location":"tensors/#Banded-tensors","page":"Banded tensors","title":"Banded tensors","text":"","category":"section"},{"location":"tensors/#Slices","page":"Banded tensors","title":"Slices","text":"","category":"section"},{"location":"tensors/#Linear-algebra","page":"Banded tensors","title":"Linear algebra","text":"","category":"section"},{"location":"tensors/#BSplineKit.BandedTensors.BandedTensor3D","page":"Banded tensors","title":"BSplineKit.BandedTensors.BandedTensor3D","text":"BandedTensor3D{T,b}\n\nThree-dimensional banded tensor with element type T.\n\nExtended help\n\nBand structure\n\nThe band structure is assumed to be symmetric, and is defined in terms of the band width b. For a cubic banded tensor of dimensions N  N  N, the element A_ijk may be non-zero only if i - j  b, i - k  b and j - k  b.\n\nStorage\n\nThe data is stored as a Vector of small matrices, each with size r  r, where r = 2b + 1 is the total number of bands. Each submatrix holds the non-zero values of a slice of the form A[:, :, k].\n\nFor b = 2, one of these matrices looks like the following, where dots indicate out-of-bands values (equal to zero):\n\n| x  x  x  ⋅  ⋅ |\n| x  x  x  x  ⋅ |\n| x  x  x  x  x |\n| ⋅  x  x  x  x |\n| ⋅  ⋅  x  x  x |\n\nThese submatrices are stored as static matrices (SMatrix).\n\nSetting elements\n\nTo define the elements of the tensor, each slice A[:, :, k] must be set at once. For instance:\n\nA = BandedTensor3D(undef, 20, Val(2))  # tensor of size 20×20×20 and band width b = 2\nfor k in axes(A, 3)\n    A[:, :, k] = rand(5, 5)\nend\n\nSee setindex! for more details.\n\nNon-cubic tensors\n\nA slight departure from cubic tensors is currently supported, with dimensions of the form N  N  M. Moreover, bands may be shifted along the third dimension by an offset δ. In this case, the bands are given by i - j  b, i - (k + δ)  b and j - (k + δ)  b.\n\n\n\nBandedTensor3D{T}(undef, (Ni, Nj, Nk), Val(b); [bandshift = (0, 0, 0)])\nBandedTensor3D{T}(undef, N, Val(b); ...)\n\nConstruct 3D banded tensor with band widths b.\n\nRight now, the first two dimension sizes Ni and Nj of the tensor must be equal. In the second variant, the tensor dimensions are N × N × N.\n\nThe tensor is constructed uninitialised. Each submatrix A[:, :, k] of size (2b + 1, 2b + 1), for k ∈ 1:Nk, should be initialised as in the following example:\n\nA[:, :, k] = rand(2b + 1, 2b + 1)\n\nThe optional bandshift argument should be a tuple of the form (δi, δj, δk) describing a band shift. Right now, band shifts are limited to δi = δj = 0, so this argument should actually look like (0, 0, δk).\n\n\n\n\n\n","category":"type"},{"location":"tensors/#BSplineKit.BandedTensors.bandshift","page":"Banded tensors","title":"BSplineKit.BandedTensors.bandshift","text":"bandshift(A::BandedTensor3D) -> (δi, δj, δk)\n\nReturn tuple with band shifts along each dimension.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#BandedMatrices.bandwidth","page":"Banded tensors","title":"BandedMatrices.bandwidth","text":"bandwidth(A::BandedTensor3D)\n\nGet band width b of BandedTensor3D.\n\nThe band width is defined here such that the element A[i, j, k] may be non-zero only if i - j  b, i - k  b and j - k  b. This definition is consistent with the specification of the upper and lower band widths in BandedMatrices.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#BSplineKit.BandedTensors.band_indices","page":"Banded tensors","title":"BSplineKit.BandedTensors.band_indices","text":"band_indices(A::BandedTensor3D, k)\n\nReturn the range of indices a:b for subarray A[:, :, k] where values may be non-zero.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#BSplineKit.BandedTensors.SubMatrix","page":"Banded tensors","title":"BSplineKit.BandedTensors.SubMatrix","text":"SubMatrix{T} <: AbstractMatrix{T}\n\nRepresents the submatrix A[:, :, k] of a BandedTensor3D A.\n\nWraps the SMatrix holding the submatrix.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#Base.setindex!","page":"Banded tensors","title":"Base.setindex!","text":"setindex!(A::BandedTensor3D, Ak::AbstractMatrix, :, :, k)\n\nSet submatrix A[:, :, k] to the matrix Ak.\n\nThe Ak matrix must have dimensions (r, r), where r = 2b + 1 is the total number of bands of A.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#LinearAlgebra.dot-Tuple{AbstractVector, BSplineKit.BandedTensors.SubMatrix, AbstractVector}","page":"Banded tensors","title":"LinearAlgebra.dot","text":"dot(x, Asub::SubMatrix, y)\n\nEfficient implementation of the generalised dot product dot(x, Asub * y).\n\nTo be used with a submatrix Asub = A[:, :, k] of a BandedTensor3D A.\n\n\n\n\n\n","category":"method"},{"location":"tensors/#BSplineKit.BandedTensors.muladd!","page":"Banded tensors","title":"BSplineKit.BandedTensors.muladd!","text":"muladd!(Y::AbstractMatrix, A::BandedTensor3D, b::AbstractVector)\n\nPerform contraction Y[i, j] += ∑ₖ A[i, j, k] * b[k].\n\nNote that the result is added to previously existent values of Y.\n\nAs an (allocating) alternative, one can use Y = A * b, which returns Y as a BandedMatrix.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Splines-api","page":"Splines","title":"Splines","text":"","category":"section"},{"location":"splines/#Splines","page":"Splines","title":"Splines","text":"","category":"section"},{"location":"splines/#Derivatives-and-integrals","page":"Splines","title":"Derivatives and integrals","text":"","category":"section"},{"location":"splines/#Spline-wrappers","page":"Splines","title":"Spline wrappers","text":"","category":"section"},{"location":"splines/#BSplineKit.Splines.Spline","page":"Splines","title":"BSplineKit.Splines.Spline","text":"Spline{T} <: Function\n\nRepresents a spline function.\n\n\n\nSpline(B::AbstractBSplineBasis, coefs::AbstractVector)\n\nConstruct a spline from a B-spline basis and a vector of B-spline coefficients.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.2:1);\n\njulia> coefs = rand(length(B));\n\njulia> S = Spline(B, coefs)\n13-element Spline{Float64}:\n basis: 13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.173575, 0.321662, 0.258585, 0.166439, 0.527015, 0.483022, 0.390663, 0.802763, 0.721983, 0.372347, 0.0301856, 0.0793339, 0.663758]\n\n\n\nSpline{T = Float64}(undef, B::AbstractBSplineBasis)\n\nConstruct a spline with uninitialised vector of coefficients.\n\n\n\n(S::Spline)(x)\n\nEvaluate spline at coordinate x.\n\n\n\n\n\n","category":"type"},{"location":"splines/#BSplineKit.Splines.coefficients","page":"Splines","title":"BSplineKit.Splines.coefficients","text":"coefficients(S::Spline)\n\nGet B-spline coefficients of the spline.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Base.eltype-Tuple{Spline}","page":"Splines","title":"Base.eltype","text":"eltype(::Type{<:Spline})\neltype(S::Spline)\n\nReturns type of element returned when evaluating the Spline.\n\n\n\n\n\n","category":"method"},{"location":"splines/#Base.length-Tuple{Spline}","page":"Splines","title":"Base.length","text":"length(S::Spline)\n\nReturns the number of coefficients in the spline.\n\nNote that this is equal to the number of basis functions, length(basis(S)).\n\n\n\n\n\n","category":"method"},{"location":"splines/#BSplineKit.BSplines.basis-Tuple{Spline}","page":"Splines","title":"BSplineKit.BSplines.basis","text":"basis(S::Spline) -> AbstractBSplineBasis\n\nReturns the associated B-spline basis.\n\n\n\n\n\n","category":"method"},{"location":"splines/#BSplineKit.Splines.PeriodicVector","page":"Splines","title":"BSplineKit.Splines.PeriodicVector","text":"PeriodicVector{T} <: AbstractVector{T}\n\nDescribes a periodic (or \"circular\") vector wrapping a regular vector.\n\nUsed to store the coefficients of periodic splines.\n\nThe vector has an effective length N associated to a single period, but it is possible to index it outside of this \"main\" interval.\n\nThis is similar to BSplines.PeriodicKnots. It is simpler though, since here there is no notion of coordinates or of a period L. Periodicity is only manifest in the indexation of the vector, e.g. a PeriodicVector vs satisfies vs[i + N] == vs[i].\n\n\n\nPeriodicVector(cs::AbstractVector)\n\nWraps coefficient vector cs such that it can be indexed in a periodic manner.\n\n\n\n\n\n","category":"type"},{"location":"splines/#Base.:*","page":"Splines","title":"Base.:*","text":"*(op::Derivative, S::Spline) -> Spline\n\nReturns N-th derivative of spline S as a new spline.\n\nSee also diff.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.2:1);\n\njulia> S = Spline(B, rand(length(B)))\n13-element Spline{Float64}:\n basis: 13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.173575, 0.321662, 0.258585, 0.166439, 0.527015, 0.483022, 0.390663, 0.802763, 0.721983, 0.372347, 0.0301856, 0.0793339, 0.663758]\n\njulia> Derivative(0) * S === S\ntrue\n\njulia> Derivative(1) * S\n12-element Spline{Float64}:\n basis: 12-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0]\n coefficients: [2.22131, -0.473071, -0.460734, 1.80288, -0.219964, -0.461794, 2.0605, -0.403899, -1.74818, -1.71081, 0.368613, 8.76636]\n\njulia> Derivative(2) * S\n11-element Spline{Float64}:\n basis: 11-element BSplineBasis of order 2, domain [-1.0, 1.0]\n order: 2\n knots: [-1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0]\n coefficients: [-26.9438, 0.0616849, 11.3181, -10.1142, -1.20915, 12.6114, -12.322, -6.72141, 0.186876, 10.3971, 83.9775]\n\n\n\n\n\n","category":"function"},{"location":"splines/#Base.diff","page":"Splines","title":"Base.diff","text":"diff(S::Spline, [op::Derivative = Derivative(1)]) -> Spline\n\nSame as op * S.\n\nReturns N-th derivative of spline S as a new spline.\n\n\n\n\n\n","category":"function"},{"location":"splines/#BSplineKit.Splines.integral","page":"Splines","title":"BSplineKit.Splines.integral","text":"integral(S::Spline)\n\nReturns an antiderivative of the given spline as a new spline.\n\nThe algorithm is described in de Boor 2001, p. 127.\n\nNote that the integral spline I returned by this function is defined up to a constant. By convention, here the returned spline I is zero at the left boundary of the domain. One usually cares about the integral of S from point a to point b, which can be obtained as I(b) - I(a).\n\nnote: Periodic splines\nNote that the integral of a periodic function is in general not periodic. For periodic splines (backed by a PeriodicBSplineBasis), this function returns a non-periodic spline (backed by a regular BSplineBasis).\n\n\n\n\n\n","category":"function"},{"location":"splines/#BSplineKit.Splines.SplineWrapper","page":"Splines","title":"BSplineKit.Splines.SplineWrapper","text":"SplineWrapper{S <: Spline} <: Function\n\nAbstract type representing a type that wraps a Spline.\n\nSuch a type implements all common operations on splines, including evaluation, differentiation, etc…\n\n\n\n\n\n","category":"type"},{"location":"splines/#BSplineKit.Splines.spline","page":"Splines","title":"BSplineKit.Splines.spline","text":"spline(w::SplineWrapper) -> Spline\n\nReturns the Spline wrapped by the object.\n\n\n\n\n\n","category":"function"},{"location":"approximation/#function-approximation-api","page":"Function approximation","title":"Function approximation","text":"Function approximation using splines.","category":"section"},{"location":"approximation/#Functions","page":"Function approximation","title":"Functions","text":"","category":"section"},{"location":"approximation/#Approximation-methods","page":"Function approximation","title":"Approximation methods","text":"","category":"section"},{"location":"approximation/#BSplineKit.SplineApproximations","page":"Function approximation","title":"BSplineKit.SplineApproximations","text":"SplineApproximations\n\nModule for function approximation using splines.\n\nThe general idea is to find the spline g(x) in a given spline space that best approximates a known function f(x). In other words, given a predefined BSplineBasis, the objective is to find some appropriate B-spline coefficients such that the resulting spline appropriately approximates f. Different approximation approaches are implemented, trading accuracy and speed.\n\n\n\n\n\n","category":"module"},{"location":"approximation/#BSplineKit.SplineApproximations.approximate","page":"Function approximation","title":"BSplineKit.SplineApproximations.approximate","text":"approximate(f, B::AbstractBSplineBasis, [method = ApproxByInterpolation(B)])\n\nApproximate function f in the given basis, using the chosen method.\n\nFrom lower to higher accuracy (and cost), the possible approximation methods are:\n\nVariationDiminishing,\nApproxByInterpolation,\nMinimiseL2Error.\n\nSee their respective documentations for details.\n\nNote that, once an approximation has been performed, it's possible to efficiently perform additional approximations (of other functions f) by calling the in-place interpolate!. This completely avoids allocations and strongly reduces computation time.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(3), -1:0.4:1);\n\njulia> S_interp = approximate(sin, B)\nSplineApproximation containing the 7-element Spline{Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [-0.841471, -0.731727, -0.39727, 2.85767e-17, 0.39727, 0.731727, 0.841471]\n approximation method: interpolation at [-1.0, -0.8, -0.4, 0.0, 0.4, 0.8, 1.0]\n\njulia> sin(0.3), S_interp(0.3)\n(0.29552020666133955, 0.2959895327282942)\n\njulia> approximate!(exp, S_interp)\nSplineApproximation containing the 7-element Spline{Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [0.367879, 0.440373, 0.65701, 0.980127, 1.46223, 2.18111, 2.71828]\n approximation method: interpolation at [-1.0, -0.8, -0.4, 0.0, 0.4, 0.8, 1.0]\n\njulia> exp(0.3), S_interp(0.3)\n(1.3498588075760032, 1.3491015490105396)\n\njulia> S_fast = approximate(exp, B, VariationDiminishing())\nSplineApproximation containing the 7-element Spline{Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [0.367879, 0.449329, 0.67032, 1.0, 1.49182, 2.22554, 2.71828]\n approximation method: VariationDiminishing()\n\njulia> S_opt = approximate(exp, B, MinimiseL2Error())\nSplineApproximation containing the 7-element Spline{Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [0.368074, 0.440342, 0.657077, 0.980279, 1.46216, 2.18201, 2.71669]\n approximation method: MinimiseL2Error()\n\njulia> x = 0.34; exp(x), S_opt(x), S_interp(x), S_fast(x)\n(1.4049475905635938, 1.4044530324752076, 1.4044149581073813, 1.4328668494041878)\n\n\n\n\n\n","category":"function"},{"location":"approximation/#BSplineKit.SplineApproximations.approximate!","page":"Function approximation","title":"BSplineKit.SplineApproximations.approximate!","text":"approximate!(f, A::SplineApproximation)\n\nApproximate function f reusing a previous Spline approximation in a given basis.\n\nSee approximate for details.\n\n\n\n\n\n","category":"function"},{"location":"approximation/#BSplineKit.SplineApproximations.AbstractApproxMethod","page":"Function approximation","title":"BSplineKit.SplineApproximations.AbstractApproxMethod","text":"AbstractApproxMethod\n\nAbstract type describing a type of approximation method.\n\n\n\n\n\n","category":"type"},{"location":"approximation/#BSplineKit.SplineApproximations.VariationDiminishing","page":"Function approximation","title":"BSplineKit.SplineApproximations.VariationDiminishing","text":"VariationDiminishing <: AbstractApproxMethod\n\nSchoenberg's variation diminishing spline approximation.\n\nApproximates a function f by setting the B-spline coefficients as c_i = f(x_i), where the locations x_i are chosen as the Greville sites:\n\nx_i = frac1k - 1 _j = 1^k - 1 t_i + j\n\nThis method is expected to preserve the shape of the function. However, it may be very inaccurate as an actual approximation of it.\n\nFor details, see e.g. de Boor 2001, chapter XI.\n\nwarning: Warning\nCurrently, this method is not guaranteed to work well with recombined B-spline bases (of type RecombinedBSplineBasis).\n\n\n\n\n\n","category":"type"},{"location":"approximation/#BSplineKit.SplineApproximations.ApproxByInterpolation","page":"Function approximation","title":"BSplineKit.SplineApproximations.ApproxByInterpolation","text":"ApproxByInterpolation <: AbstractApproxMethod\n\nApproximate function by a spline that passes through the given set of points.\n\nThe number of points must be equal to the length of the B-spline basis defining the approximation space.\n\nSee belows for different ways of specifying the interpolation points.\n\n\n\nApproxByInterpolation(xs::AbstractVector)\n\nSpecifies an approximation by interpolation at the given points xs.\n\n\n\nApproxByInterpolation(B::AbstractBSplineBasis)\n\nSpecifies an approximation by interpolation at an automatically-determined set of points, which are expected to be appropriate for the given basis.\n\nThe interpolation points are determined by calling collocation_points.\n\n\n\n\n\n","category":"type"},{"location":"approximation/#BSplineKit.SplineApproximations.MinimiseL2Error","page":"Function approximation","title":"BSplineKit.SplineApproximations.MinimiseL2Error","text":"MinimiseL2Error <: AbstractApproxMethod\n\nApproximate a given function f(x) by minimisation of the L^2 distance between f and its spline approximation g(x).\n\nExtended help\n\nMinimises the L^2 distance between the two functions:\n\nleftlVert f - g rightrVert^2 = left f - g f - g right\n\nwhere\n\nleft u v right = _a^b u(x)  v(x)  mathrmdx\n\nis the inner product between two functions, and a and b are the boundaries of the prescribed B-spline basis. Here, g is the spline g(x) = _i = 1^N c_i  b_i(x), and  b_i _i = 1^N is a prescribed B-spline basis.\n\nOne can show that the optimal coefficients c_i minimising the L^2 error are the solution to the linear system bmM bmc = bmφ, where M_ij = left b_i b_j right and φ_i = left b_i f right. These two terms are respectively computed by galerkin_matrix and galerkin_projection.\n\nThe integrals associated to bmM and bmφ are computed via Gauss–Legendre quadrature. The number of quadrature nodes is chosen as a function of the order k of the prescribed B-spline basis, ensuring that bmM is computed exactly (see also galerkin_matrix). In the particular case where f is a polynomial of degree k - 1, this also results in an exact computation of bmφ. In more general cases, as long as f is smooth enough, this is still expected to yield a very good approximation of the integral, and thus of the optimal coefficients c_i.\n\n\n\n\n\n","category":"type"},{"location":"#BSplineKit.jl","page":"Home","title":"BSplineKit.jl","text":"Tools for B-spline based Galerkin and collocation methods in Julia.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"This package provides:\n\nB-spline bases of arbitrary order on uniform and non-uniform grids;\nevaluation of splines and their derivatives and integrals;\nspline interpolations, smoothing splines and function approximation;\nperiodic splines;\nbasis recombination, for generating bases satisfying homogeneous boundary conditions using linear combinations of B-splines. Supported boundary conditions include Dirichlet, Neumann, Robin, and generalisations of these;\nbanded Galerkin and collocation matrices for solving differential equations, using B-spline and recombined bases;\nefficient \"banded\" 3D arrays as an extension of banded matrices. These can store 3D tensors associated to quadratic terms in Galerkin methods.","category":"section"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"The following is a very brief overview of some of the functionality provided by this package. See the examples in the sidebar for more details.\n\nInterpolate discrete data using cubic splines (B-spline order k = 4):\nxdata = (0:10).^2  # points don't need to be uniformly distributed\nydata = rand(length(xdata))\nitp = interpolate(xdata, ydata, BSplineOrder(4))\nitp(12.3)  # interpolation can be evaluated at any intermediate point\nCreate B-spline basis of order k = 6 (polynomial degree 5) from a given set of breakpoints:\nbreaks = log2.(1:16)  # breakpoints don't need to be uniformly distributed either\nB = BSplineBasis(BSplineOrder(6), breaks)\nApproximate known function by a spline in a previously constructed basis:\nf(x) = exp(-x) * sin(x)\nfapprox = approximate(f, B)\nf(2.3), fapprox(2.3)  # (0.07476354233090601, 0.0747642348243861)\nCreate derived basis satisfying homogeneous Robin boundary conditions on the two boundaries:\nbc = Derivative(0) + 3Derivative(1)\nR = RecombinedBSplineBasis(B, bc)  # satisfies u ∓ 3u' = 0 on the left/right boundary\nConstruct mass matrix and stiffness matrix for the Galerkin method in the recombined basis:\n# By default, M and L are Hermitian banded matrices\nM = galerkin_matrix(R)\nL = galerkin_matrix(R, (Derivative(1), Derivative(1)))\nConstruct banded 3D tensor associated to non-linear term of the Burgers equation:\nT = galerkin_tensor(R, (Derivative(0), Derivative(1), Derivative(0)))","category":"section"},{"location":"#Comparison-with-similar-packages","page":"Home","title":"Comparison with similar packages","text":"This project presents several similarities with the excellent BSplines package. This includes various types and functions which have the same names (e.g. BSplineBasis, Spline, knots, order). In most cases this is pure coincidence, even though some inspiration was later taken from that package (for instance, the idea of a Derivative type).\n\nSome design differences with the BSplines package include:\n\nin BSplineKit, the B-spline order k is considered a compile-time constant, as it is encoded in the BSplineBasis type. This leads to important performance gains when evaluating splines. It also enables the construction of efficient 3D banded structures based on stack-allocated StaticArrays;\nwe do not assume that knots are repeated k times at the boundaries, even though this is still the default when creating a B-spline basis. This is to allow the possibility of imposing periodic boundary conditions on the basis.\n\nIn addition to the common functionality, BSplineKit provides easy to use tools for solving boundary-value problems using B-splines. This includes the generation of bases satisfying a chosen set of boundary conditions (basis recombination), as well as the construction of arrays for solving such problems using collocation and Galerkin methods.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"C. de Boor, A Practical Guide to Splines. New York: Springer-Verlag, 1978.\nJ. P. Boyd, Chebyshev and Fourier Spectral Methods, Second Edition. Mineola, N.Y: Dover Publications, 2001.\nO. Botella and K. Shariff, B-spline Methods in Fluid Dynamics, Int. J. Comput. Fluid Dyn. 17, 133 (2003).","category":"section"}]
}
