var documenterSearchIndex = {"docs":
[{"location":"collocation/#collocation-api","page":"Collocation tools","title":"Collocation tools","text":"","category":"section"},{"location":"collocation/","page":"Collocation tools","title":"Collocation tools","text":"CurrentModule = BSplineKit.Collocation","category":"page"},{"location":"collocation/#Collocation-points","page":"Collocation tools","title":"Collocation points","text":"","category":"section"},{"location":"collocation/","page":"Collocation tools","title":"Collocation tools","text":"collocation_points\ncollocation_points!","category":"page"},{"location":"collocation/#BSplineKit.Collocation.collocation_points","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_points","text":"collocation_points(B::AbstractBSplineBasis; method=Collocation.AvgKnots())\n\nDefine and return adapted collocation points for evaluation of splines.\n\nThe number of returned collocation points is equal to the number of functions in the basis.\n\nNote that if B is a RecombinedBSplineBasis (adapted for boundary value problems), collocation points are not included at the boundaries, since the boundary conditions are implicitly satisfied by the basis.\n\nIn principle, the choice of collocation points is not unique. The selection method can be chosen via the method argument. For now, only a single method is accepted:\n\nCollocation.AvgKnots()\n\nSee also collocation_points!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.collocation_points!","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_points!","text":"collocation_points!(x::AbstractVector, B::AbstractBSplineBasis;\n                    method::SelectionMethod=AvgKnots())\n\nFill vector with collocation points for evaluation of splines.\n\nSee collocation_points for details.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#Point-selection-methods","page":"Collocation tools","title":"Point selection methods","text":"","category":"section"},{"location":"collocation/","page":"Collocation tools","title":"Collocation tools","text":"SelectionMethod\nAvgKnots","category":"page"},{"location":"collocation/#BSplineKit.Collocation.SelectionMethod","page":"Collocation tools","title":"BSplineKit.Collocation.SelectionMethod","text":"SelectionMethod\n\nAbstract type defining a method for choosing collocation points from spline knots.\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.AvgKnots","page":"Collocation tools","title":"BSplineKit.Collocation.AvgKnots","text":"AvgKnots <: SelectionMethod\n\nEach collocation point is chosen as a sliding average over k - 1 knots:\n\nx_i = frac1k - 1 _j = 1^k - 1 t_i + j\n\nThe resulting collocation points are sometimes called Greville sites (de Boor 2001).\n\n\n\n\n\n","category":"type"},{"location":"collocation/#Matrices","page":"Collocation tools","title":"Matrices","text":"","category":"section"},{"location":"collocation/","page":"Collocation tools","title":"Collocation tools","text":"CollocationMatrix\ncollocation_matrix\ncollocation_matrix!\nlu\nlu!","category":"page"},{"location":"collocation/#BSplineKit.Collocation.CollocationMatrix","page":"Collocation tools","title":"BSplineKit.Collocation.CollocationMatrix","text":"CollocationMatrix{T} <: AbstractBandedMatrix{T}\n\nB-spline collocation matrix, defined by\n\nC_ij = b_j(x_i)\n\nwhere bmx is a set of collocation points.\n\nWraps a BandedMatrix, providing an efficient LU factorisation without pivoting adapted from de Boor (1978). The factorisation takes advantage of the total positivity of spline collocation matrices (de Boor 2001, p. 175).\n\nFactorisation\n\nCollocationMatrix supports in-place LU factorisation using lu!, as well as out-of-place factorisation using lu. LU decomposition may also be performed via factorize.\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.collocation_matrix","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_matrix","text":"collocation_matrix(\n    B::AbstractBSplineBasis,\n    x::AbstractVector,\n    [deriv::Derivative = Derivative(0)],\n    [MatrixType = CollocationMatrix{Float64}];\n    clip_threshold = eps(eltype(MatrixType)),\n)\n\nReturn collocation matrix mapping B-spline coefficients to spline values at the collocation points x.\n\nExtended help\n\nThe matrix elements are given by the B-splines evaluated at the collocation points:\n\nC_ij = b_j(x_i) quad textfor quad\ni  1 N_x text and  j  1 N_b\n\nwhere Nx = length(x) is the number of collocation points, and Nb = length(B) is the number of B-splines in B.\n\nTo obtain a matrix associated to the B-spline derivatives, set the deriv argument to the order of the derivative.\n\nGiven the B-spline coefficients u_j 1  j  N_b, one can recover the values (or derivatives) of the spline at the collocation points as v = C * u. Conversely, if one knows the values v_i at the collocation points, the coefficients u of the spline passing by the collocation points may be obtained by inversion of the linear system u = C \\ v.\n\nThe clip_threshold argument allows one to ignore spurious, negligible values obtained when evaluating B-splines. These values are typically unwanted, as they artificially increase the number of elements (and sometimes the bandwidth) of the matrix. They may appear when a collocation point is located on a knot. By default, clip_threshold is set to the machine epsilon associated to the matrix element type (see eps in the Julia documentation). Set it to zero to disable this behaviour.\n\nMatrix types\n\nThe MatrixType optional argument allows to select the type of returned matrix.\n\nDue to the compact support of B-splines, the collocation matrix is banded if the collocation points are properly distributed. Therefore, it makes sense to store it in a BandedMatrix (from the BandedMatrices package), as this will lead to memory savings and especially to time savings if the matrix needs to be inverted.\n\nSupported matrix types\n\nCollocationMatrix{T}: thin wrapper over BandedMatrix{T}, with efficient LU factorisations without pivoting (see CollocationMatrix for details). This option performs much better than sparse matrices for inversion of linear systems. On the other hand, for matrix-vector or matrix-matrix multiplications, SparseMatrixCSC may perform better, especially when using OpenBLAS (see BandedMatrices issue). May fail with an error for non-square matrix shapes, or if the distribution of collocation points is not adapted. In these cases, the effective bandwidth of the matrix may be larger than the expected bandwidth.\nSparseMatrixCSC{T}: regular sparse matrix; correctly handles any matrix shape.\nMatrix{T}: a regular dense matrix. Generally performs worse than the alternatives, especially for large problems.\n\nSee also collocation_matrix!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.collocation_matrix!","page":"Collocation tools","title":"BSplineKit.Collocation.collocation_matrix!","text":"collocation_matrix!(\n    C::AbstractMatrix{T}, B::AbstractBSplineBasis, x::AbstractVector,\n    [deriv::Derivative = Derivative(0)]; clip_threshold = eps(T))\n\nFill preallocated collocation matrix.\n\nSee collocation_matrix for details.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#LinearAlgebra.lu","page":"Collocation tools","title":"LinearAlgebra.lu","text":"LinearAlgebra.lu(C::CollocationMatrix, pivot = NoPivot(); check = true)\n\nReturns LU factorisation of collocation matrix.\n\nSee also lu!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#LinearAlgebra.lu!","page":"Collocation tools","title":"LinearAlgebra.lu!","text":"LinearAlgebra.lu!(C::CollocationMatrix, pivot = Val(false); check = true)\n\nPerform in-place LU factorisation of collocation matrix without pivoting.\n\nTakes advantage of the totally positive property of collocation matrices appearing in spline calculations (de Boor 1978).\n\nThe code is ported from Carl de Boor's BANFAC routine in FORTRAN77, via its FORTRAN90 version by John Burkardt.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#basis-recombination-api","page":"Basis recombination","title":"Basis recombination","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"CurrentModule = BSplineKit.Recombinations","category":"page"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"Recombinations","category":"page"},{"location":"recombination/#BSplineKit.Recombinations","page":"Basis recombination","title":"BSplineKit.Recombinations","text":"Recombinations\n\nBasis recombination module.\n\nDefines RecombinedBSplineBasis and RecombineMatrix types.\n\n\n\n\n\n","category":"module"},{"location":"recombination/#Recombined-bases","page":"Basis recombination","title":"Recombined bases","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"RecombinedBSplineBasis\nparent(::RecombinedBSplineBasis)\nlength(::RecombinedBSplineBasis)\nconstraints\nnum_constraints\nnum_recombined\nrecombination_matrix","category":"page"},{"location":"recombination/#BSplineKit.Recombinations.RecombinedBSplineBasis","page":"Basis recombination","title":"BSplineKit.Recombinations.RecombinedBSplineBasis","text":"RecombinedBSplineBasis{k, T}\n\nFunctional basis defined from the recombination of a BSplineBasis in order to satisfy certain homogeneous boundary conditions (BCs).\n\nExtended help\n\nThe basis recombination technique is a common way of applying BCs in Galerkin methods. It is described for instance in Boyd 2000 (ch. 6), in the context of a Chebyshev basis. In this approach, the original basis, b_i(x) 1  i  N, is \"recombined\" into a new basis, ϕ_j(x) 1  j  M, so that each basis function ϕ_j individually satisfies the chosen BCs.\n\nThe length M of the recombined basis is always smaller than the length N of the original basis. The difference, δ = N - M, is equal to the number of boundary conditions. In the simplest (and most common) case, a single BC is applied on each boundary, leading to δ = 2. More generally, as described further below, it is possible to simultaneously impose different BCs, which further decreases the number of degrees of freedom (increasing δ).\n\nThanks to the local support of B-splines, basis recombination involves only a little portion of the original B-spline basis. For instance, since there is only one B-spline that is non-zero at each boundary, removing that function from the basis is enough to apply homogeneous Dirichlet BCs. Imposing BCs for derivatives is slightly more complex, but still possible.\n\nNote that, when combining basis recombination with collocation methods, there must be no collocation points at the boundaries, or the resulting collocation matrices may not be invertible.\n\nOrder of the boundary condition\n\nIn this section, we consider the simplest case where a single homogeneous boundary condition, mathrmd^n u  mathrmdx^n = 0, is to be satisfied by the basis.\n\nThe recombined basis requires the specification of a Derivative object determining the order of the homogeneous BCs to be applied at the two boundaries. Linear combinations of Derivatives are also supported. The order of the B-spline needs to be k  n + 1, since a B-spline of order k is a C^k - 1-continuous function (except on the knots where it is C^k - 1 - p, with p the knot multiplicity).\n\nSome usual choices are:\n\nDerivative(0) sets homogeneous Dirichlet BCs (u = 0 at the boundaries) by removing the first and last B-splines, i.e. ϕ_1 = b_2;\nDerivative(1) sets homogeneous Neumann BCs (u = 0 at the boundaries) by adding the two first (and two last) B-splines, i.e. ϕ_1 = b_1 + b_2.\nmore generally, α Derivative(0) + β Derivative(1) sets homogeneous Robin BCs by defining ϕ_1 as a linear combination of b_1 and b_2. Here it's important to note that Derivative(1) denotes the normal derivative at the boundary, fracun, which is equal to -fracux on the left boundary.\n\nHigher order BCs are also possible. For instance, Derivative(2) recombines the first three B-splines into two basis functions that satisfy ϕ_1 = ϕ_2 = 0 at the left boundary, while ensuring that lower and higher-order derivatives keep degrees of freedom at the boundary. Note that simply adding the first three B-splines, as in ϕ_1 = b_1 + b_2 + b_3, makes the first derivative vanish as well as the second one, which is unwanted.\n\nFor Derivative(2), the chosen solution is to set ϕ_i = α_i b_i + β_i b_i + 1 for i  1 2. The α_i and β_i coefficients are chosen such that ϕ_i = 0 at the boundary. Moreover, they satisfy the (somewhat arbitrary) constraint α_i + β_i = 2 for each i, for consistency with the Neumann case described above. This generalises to higher order BCs. Note that, since each boundary function ϕ_i is defined from only two neighbouring B-splines, its local support stays minimal, hence preserving the small bandwidth of the resulting matrices.\n\nFinally, note that in the current implementation, it is not possible to impose different boundary conditions on both boundaries.\n\nMultiple boundary conditions\n\nAs an option, the recombined basis may simultaneously satisfy homogeneous BCs of different orders. In this case, a tuple of Derivatives must be passed.\n\nFor more details on the supported combinations of BCs, see the different RecombinedBSplineBasis constructors documented further below.\n\n\n\nRecombinedBSplineBasis(op::AbstractDifferentialOp, B::BSplineBasis)\n\nConstruct RecombinedBSplineBasis from B-spline basis B, satisfying homogeneous boundary conditions associated to the given differential operator.\n\nFor instance, op = Derivative(0) and op = Derivative(1) correspond to homogeneous Dirichlet and Neumann BCs, respectively.\n\nLinear combinations of differential operators are also supported. For instance, op = Derivative(0) + λ Derivative(1) corresponds to homogeneous Robin BCs.\n\nHigher-order derivatives are also allowed, being only limited by the order of the B-spline basis.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.2:1)\n13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n\njulia> R_neumann = RecombinedBSplineBasis(Derivative(1), B)\n11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{1},)\n BCs right: (D{1},)\n\njulia> R_robin = RecombinedBSplineBasis(Derivative(0) + 3Derivative(1), B)\n11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{0} + 3 * D{1},)\n BCs right: (D{0} + 3 * D{1},)\n\n\n\nRecombinedBSplineBasis(ops, B::BSplineBasis)\n\nConstruct RecombinedBSplineBasis simultaneously satisfying homogeneous BCs associated to multiple differential operators.\n\nCurrently, the following cases are supported:\n\nall derivatives up to order m:\n ops = (Derivative(0), ..., Derivative(m))\nThis boundary condition is obtained by removing the first m + 1 B-splines from the original basis.\nFor instance, if (Derivative(0), Derivative(1)) is passed, then the basis simultaneously satisfies homogeneous Dirichlet and Neumann BCs at the two boundaries. The resulting basis is ϕ_1 = b_3 ϕ_2 = b_4  ϕ_N - 4 = b_N - 2.\nan extension of the above, with an additional differential operator of order n at the end:\n ops = (Derivative(0), ..., Derivative(m), D(n))\nThe operator D(n) may be a Derivative, or a linear combination of derivatives. The only restriction is that its maximum degree must satisfy n ≥ m + 1.\nOne example is the combination of homogeneous Dirichlet BCs, u = 0 on the boundaries, with Robin BCs for the derivative, u + λ u = 0, which corresponds to ops = (Derivative(0), Derivative(1) + λ Derivative(2)).\ngeneralised natural boundary conditions:\n ops = Natural()\nThis is equivalent to ops = (Derivative(2), Derivative(3), ..., Derivative(k ÷ 2)) where k is the spline order (which must be even). See Natural for details.\n\nIn the first two cases, the degrees of the differential operators must be in increasing order. For instance, ops = (Derivative(1), Derivative(0)) fails with an error.\n\nExamples\n\njulia> ops = (Derivative(0), Derivative(1));\n\n\njulia> R1 = RecombinedBSplineBasis(ops, B)\n9-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{0}, D{1})\n BCs right: (D{0}, D{1})\n\njulia> ops = (Derivative(0), Derivative(1) - 4Derivative(2));\n\n\njulia> R2 = RecombinedBSplineBasis(ops, B)\n9-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{0}, D{1} + -4 * D{2})\n BCs right: (D{0}, D{1} + -4 * D{2})\n\njulia> R3 = RecombinedBSplineBasis(Natural(), B)\n11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n BCs left:  (D{2},)\n BCs right: (D{2},)\n\n\n\n\n\n","category":"type"},{"location":"recombination/#Base.parent-Tuple{RecombinedBSplineBasis}","page":"Basis recombination","title":"Base.parent","text":"parent(R::RecombinedBSplineBasis)\n\nGet original B-spline basis.\n\n\n\n\n\n","category":"method"},{"location":"recombination/#Base.length-Tuple{RecombinedBSplineBasis}","page":"Basis recombination","title":"Base.length","text":"length(R::RecombinedBSplineBasis)\n\nReturns the number of functions in the recombined basis.\n\n\n\n\n\n","category":"method"},{"location":"recombination/#BSplineKit.Recombinations.constraints","page":"Basis recombination","title":"BSplineKit.Recombinations.constraints","text":"constraints(R::AbstractBSplineBasis) -> (left, right)\nconstraints(A::RecombineMatrix) -> (left, right)\n\nReturn the constraints (homogeneous boundary conditions) that the basis satisfies on each boundary.\n\nConstraints are returned as a tuple (left, right) indicating the BCs that are satisfied on each boundary. Each element is a tuple of differential operators specifying the BCs.\n\nFor example, if both Dirichlet and Neumann BCs are satisfied on the left boundary, then left = (Derivative(0), Derivative(1)).\n\nFor non-recombined bases such as BSplineBasis, this returns a tuple of empty tuples: ((), ()), since no BCs are satisfied on either boundary.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.num_constraints","page":"Basis recombination","title":"BSplineKit.Recombinations.num_constraints","text":"num_constraints(R::AbstractBSplineBasis) -> (Int, Int)\nnum_constraints(A::RecombineMatrix) -> (Int, Int)\n\nReturns the number of constraints (number of BCs to satisfy) on each boundary.\n\nFor instance, if R simultaneously satisfies Dirichlet and Neumann boundary conditions on each boundary, this returns (2, 2).\n\nNote that for non-recombined bases such as BSplineBasis, the number of constraints is zero, and this returns (0, 0).\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.num_recombined","page":"Basis recombination","title":"BSplineKit.Recombinations.num_recombined","text":"num_recombined(R::AbstractBSplineBasis) -> (Int, Int)\nnum_recombined(A::RecombineMatrix) -> (Int, Int)\n\nReturns the number of recombined functions in the recombined basis for each boundary.\n\nFor instance, if R satisfies Neumann boundary conditions on both boundaries, then only the first and last basis functions are different from the original B-spline basis, e.g. ϕ_1 = b_1 + b_2, and this returns (1, 1).\n\nFor non-recombined bases such as BSplineBasis, this returns zero.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.recombination_matrix","page":"Basis recombination","title":"BSplineKit.Recombinations.recombination_matrix","text":"recombination_matrix(R::AbstractBSplineBasis)\n\nGet RecombineMatrix associated to the recombined basis.\n\nFor non-recombined bases such as BSplineBasis, this returns the identity matrix (LinearAlgebra.I).\n\n\n\n\n\n","category":"function"},{"location":"recombination/#Recombination-matrix","page":"Basis recombination","title":"Recombination matrix","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"RecombineMatrix\nnzrows","category":"page"},{"location":"recombination/#BSplineKit.Recombinations.RecombineMatrix","page":"Basis recombination","title":"BSplineKit.Recombinations.RecombineMatrix","text":"RecombineMatrix{T} <: AbstractMatrix{T}\n\nMatrix for transformation from coefficients of the recombined basis, to the corresponding B-spline basis coefficients.\n\nExtended help\n\nThe transformation matrix M is defined by\n\nϕ_j = M_ij b_i\n\nwhere b_j(x) and ϕ_i(x) are elements of the B-spline and recombined bases, respectively.\n\nThis matrix allows to pass from known coefficients u_j in the recombined basis ϕ_j, to the respective coefficients v_i in the B-spline basis b_i:\n\nbmv = mathbfM bmu\n\nNote that the matrix is not square: it has dimensions N  M, where N is the length of the B-spline basis, and M = N - δ is that of the recombined basis (see RecombinedBSplineBasis for details).\n\nDue to the local support of B-splines, basis recombination can be performed by combining just a small set of B-splines near the boundaries (as discussed in RecombinedBSplineBasis). This leads to a recombination matrix which is almost a diagonal of ones, plus a few extra super- and sub-diagonal elements in the upper left and lower right corners, respectively. The matrix is stored in a memory-efficient way that also allows fast access to its elements.\n\nEfficient implementations of matrix-vector products (using the * operator or LinearAlgebra.mul!) and of left division of vectors (using \\ or LinearAlgebra.ldiv!) are included. These two operations can be used to transform between coefficients in the original and recombined bases.\n\nNote that, since the recombined basis forms a subspace of the original basis (which is related to the rectangular shape of the matrix), it is generally not possible to obtain recombined coefficients from original coefficients, unless the latter already satisfy the constraints encoded in the recombined basis. The left division operation will throw a NoUniqueSolutionError if that is not the case.\n\n\n\nRecombineMatrix(ops::Tuple{Vararg{AbstractDifferentialOp}},\n                B::BSplineBasis, [T])\n\nConstruct recombination matrix describing a B-spline basis recombination.\n\nThe default element type T is generally Float64, except for specific differential operators which yield a matrix of zeroes and ones, for which Bool is the default.\n\nSee the RecombinedBSplineBasis constructor for details on the ops argument.\n\n\n\n\n\n","category":"type"},{"location":"recombination/#BSplineKit.Recombinations.nzrows","page":"Basis recombination","title":"BSplineKit.Recombinations.nzrows","text":"nzrows(A::RecombineMatrix, col::Integer) -> UnitRange{Int}\n\nReturns the range of row indices i such that A[i, col] is non-zero.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#Internals","page":"Basis recombination","title":"Internals","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"NoUniqueSolutionError\nparent_coefficients","category":"page"},{"location":"recombination/#BSplineKit.Recombinations.NoUniqueSolutionError","page":"Basis recombination","title":"BSplineKit.Recombinations.NoUniqueSolutionError","text":"NoUniqueSolutionError <: Exception\n\nException thrown when solving linear system using RecombineMatrix, when the system has no unique solution.\n\n\n\n\n\n","category":"type"},{"location":"recombination/#BSplineKit.Recombinations.parent_coefficients","page":"Basis recombination","title":"BSplineKit.Recombinations.parent_coefficients","text":"parent_coefficients(R::RecombinedBSplineBasis, coefs::AbstractVector)\n\nReturns the coefficients associated to the parent B-spline basis, from the coefficients coefs in the recombined basis.\n\nNote that this function doesn't allocate, since it returns a lazy concatenation (via LazyArrays.jl) of two StaticArrays and a view of the coefs vector.\n\n\n\n\n\n","category":"function"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"EditURL = \"https://github.com/jipolanco/BSplineKit.jl/blob/master/examples/interpolation.jl\"","category":"page"},{"location":"generated/interpolation/#interpolation-example","page":"Spline interpolations","title":"Spline interpolations","text":"","category":"section"},{"location":"generated/interpolation/#Interpolating-data","page":"Spline interpolations","title":"Interpolating data","text":"","category":"section"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"BSplineKit can interpolate evenly and unevenly-distributed data.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"For example, we can try interpolating random data on randomly-distributed data points:","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"using Random\nrng = MersenneTwister(42)\n\nNdata = 20\nxs = range(0, 1; length = Ndata) .+ 0.01 .* randn(rng, Ndata)\nsort!(xs)  # make sure coordinates are sorted\nxs[begin] = 0; xs[end] = 1;   # not strictly necessary; just to set the data limits\nys = sinpi.(xs) .+ 0.02 .* randn(rng, Ndata);\nnothing #hide","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"Let's start by plotting the generated data:","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")  # hide\nscatter(xs, ys; label = \"Data\", color = :black)","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"To interpolate the data using splines, we may choose any arbitrary B-spline order k (in particular, k = 4 corresponds to cubic splines). The main interpolation function is interpolate.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"using BSplineKit\nS = interpolate(xs, ys, BSplineOrder(4))","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"Let's plot the result:","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"lines!(0..1, x -> S(x); label = \"k = 4\", color = Cycled(4 - 3))\ncurrent_figure()  # hide","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"We can also choose other interpolation orders for comparison:","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"for k ∈ (5, 6, 8)\n    S = interpolate(xs, ys, BSplineOrder(k))\n    lines!(0..1, x -> S(x); label = \"k = $k\", color = Cycled(k - 3))\nend\naxislegend()\ncurrent_figure()  # hide","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"We see larger and larger oscillations, especially near the boundaries, as the spline order increases. We can try to fix this using natural splines, which impose some derivatives to be zero at the boundaries.","category":"page"},{"location":"generated/interpolation/#Natural-splines","page":"Spline interpolations","title":"Natural splines","text":"","category":"section"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"Natural splines usually refer to cubic splines (order k = 4) with the additional constraint S(a) = S(b) = 0 at the boundaries (x  a b).","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"In BSplineKit, this concept is generalised for all even spline orders k, by setting all derivatives of order 2 3  k  2 to be zero at the boundaries. For instance, for k = 6 (quintic splines), the constraint is S = S = 0. We achieve this by using basis recombination to implicitly impose the wanted boundary conditions.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"The natural boundary condition not only allows to suppress oscillations near the boundaries, but is also quite convenient for interpolations, as it reduces the number of degrees of freedom such that the number of unique spline knots is equal to the number of data points. This simply means that one can set the knots to be equal to the data points. All of this is done internally when using this boundary condition.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"To impose natural boundary conditions, one just needs to pass Natural to interpolate, as illustrated below.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"k = 8\nS = interpolate(xs, ys, BSplineOrder(k))  # without BCs\nSnat = interpolate(xs, ys, BSplineOrder(k), Natural())  # with natural BCs","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"Let's look at the result:","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"scatter(xs, ys; label = \"Data\", color = :black)\nlines!(0..1, x -> S(x); label = \"k = $k (original)\", linewidth = 2)\nlines!(0..1, x -> Snat(x); label = \"k = $k (natural)\", linestyle = :dash, linewidth = 4)\naxislegend()\ncurrent_figure()  # hide","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"Clearly, the spurious oscillations are strongly suppressed near the boundaries.","category":"page"},{"location":"generated/interpolation/#Multidimensional-interpolations","page":"Spline interpolations","title":"Multidimensional interpolations","text":"","category":"section"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"Multidimensional interpolations are supported for data defined on rectilinear grids. This is done using tensor-product splines. This means that the returned N-dimensional spline belongs to the space spanned by the tensor product of N one-dimensional spline bases.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"In other words, if we consider the two-dimensional case for simplicity, the returned interpolator is of the form","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"f(x y) = _i = 1^N_x _j = 1^N_y\n      c_ij  b_i^X(x)  b_j^Y(y)","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"where the b_i^X and b_j^Y are the B-splines spanning two (generally different) spline bases B^X and B^Y. Note that the two bases are completely independent. In principle, they can have different orders, knot definitions and boundary conditions.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"All of the above also applies to (arbitrary) higher dimensions N. See interpolate for more details.","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"Let's finish with a simple example in 2D:","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"# Define non-uniform 2D grid\nNx, Ny = 20, 30\nrng = MersenneTwister(42)\n\nxs = range(0, 1; length = Nx) .+ 0.01 .* randn(rng, Nx)\nxs[begin] = 0\nxs[end] = 1\n\nys = range(0, 2π; length = Ny) .+ 0.02 .* randn(rng, Ny)\nys[begin] = 0\nys[end] = 2π\n\n# Generate some 2D data and interpolate\ndata = [exp(-x) * cos(y) + 0.01 * randn(rng) for x ∈ xs, y ∈ ys]\n\nS = interpolate((xs, ys), data, BSplineOrder(4), Natural())\n\n# Finally, let's plot the result on a finer grid\nxplot = range(0, 1; length = 4Nx)\nyplot = range(0, 2π; length = 4Ny)\nSdata = S.(xplot, yplot')\n\ncontourf(xplot, yplot, Sdata)\ncurrent_figure()  # hide","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"","category":"page"},{"location":"generated/interpolation/","page":"Spline interpolations","title":"Spline interpolations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"EditURL = \"https://github.com/jipolanco/BSplineKit.jl/blob/master/examples/heat.jl\"","category":"page"},{"location":"generated/heat/#Heat-equation","page":"Heat equation","title":"Heat equation","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"In this example, we numerically solve the 1D heat equation","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"fracθt = ν frac^2 θx^2","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"in a bounded domain x  -1 1 with homogeneous Neumann boundary conditions, _x θ(1 t) = 0.","category":"page"},{"location":"generated/heat/#Defining-a-B-spline-basis","page":"Heat equation","title":"Defining a B-spline basis","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"The general idea is to approximate the unknown solution by a spline of order k. For this, we first define a B-spline basis  b_i(x)  i = 1  N , such that the solution at a given time t is approximated by","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"θ(x t) = _i = 1^N v_i(t) b_i(x)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"where the v_i are the B-spline coefficients.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"A B-spline basis is uniquely defined by its order k and by a choice of knot locations within the spatial domain, which form the spatial grid.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"For this example, we take a uniform repartition of knots in -1 1.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"knots_in = range(-1, 1; length = 11)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We then create a B-spline basis of order k = 4 using these knots.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"using BSplineKit\nB = BSplineBasis(BSplineOrder(4), knots_in)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Note that the generated basis includes an augmented set of knots, in which each boundary is repeated k times:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"knots(B)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"In other words, the boundary knots have multiplicity k, while interior knots have multiplicity 1. This is common practice in bounded domains, and translates the fact that the solution does not need to be continuous at the boundaries. This provides additional degrees of freedom notably for the boundary conditions. This behaviour can be disabled via the augment argument of BSplineBasis.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We can now plot the knot locations (crosses) and the generated B-spline basis:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"using CairoMakie\nusing LaTeXStrings\nCairoMakie.activate!(type = \"svg\")\n\nfunction plot_knots!(ax, ts; knot_offset = 0.03, kws...)\n    ys = zero(ts)\n    # Add offset to distinguish knots with multiplicity > 1\n    for i in eachindex(ts)[(begin + 1):end]\n        if ts[i] == ts[i - 1]\n            ys[i] = ys[i - 1] + knot_offset\n        end\n    end\n    scatter!(ax, ts, ys; marker = :x, markersize = 20, color = :gray, kws...)\n    ax\nend\n\nfunction plot_basis!(ax, B; eval_args = (), kws...)\n    cmap = cgrad(:tab20)\n    N = length(B)\n    ts = knots(B)\n    hlines!(ax, 0; color = :gray)\n    for (n, bi) in enumerate(B)\n        color = cmap[(n - 1) / (N - 1)]\n        i, j = extrema(support(bi))\n        lines!(ax, ts[i]..ts[j], x -> bi(x, eval_args...); color, linewidth = 2.5)\n    end\n    plot_knots!(ax, ts; kws...)\n    ax\nend\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = L\"x\", ylabel = L\"b_i(x)\")\nplot_basis!(ax, B)\nfig","category":"page"},{"location":"generated/heat/#Imposing-boundary-conditions","page":"Heat equation","title":"Imposing boundary conditions","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"In BSplineKit, the recommended approach for solving boundary value problems is to use the basis recombination method. That is, to expand the solution onto a new basis consisting on linear combinations of B-splines b_i(x), such that each recombined basis function ϕ_j(x) individually satisfies the required homogeneous boundary conditions (BCs). Thanks to the local support of B-splines, basis recombination only involves a small number of B-splines near the boundaries.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Using the RecombinedBSplineBasis type, we can easily define such recombined bases for many different BCs. In this example we generate a basis satisfying homogeneous Neumann BCs:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"R = RecombinedBSplineBasis(Derivative(1), B)\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = L\"x\", ylabel = L\"ϕ_i(x)\")\nplot_basis!(ax, R)\nfig","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We notice that, on each of the two boundaries, the two initial (or final) B-splines of the original basis have been combined to produce a single basis function that has zero derivative at each respective boundary. To verify this, we can plot the basis function derivatives:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"fig = Figure()\nax = Axis(fig[1, 1]; xlabel = L\"x\", ylabel = L\"ϕ_i^′(x)\")\nplot_basis!(ax, R; eval_args = (Derivative(1), ), knot_offset = 0.4)\nfig","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Note that the new basis has two less functions than the original one, reflecting a loss of two degrees of freedom corresponding to the new constraints on each boundary:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"length(B), length(R)","category":"page"},{"location":"generated/heat/#Recombination-matrix","page":"Heat equation","title":"Recombination matrix","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"As stated above, the basis recombination approach consists in performing linear combinations of B-splines b_i to obtain a derived basis of functions ϕ_j satisfying certain boundary conditions. This can be conveniently expressed using a transformation matrix mathbfT relating the two bases:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"ϕ_j(x) = _i = 1^N T_ij b_i(x)\nquad textfor  j = 1 2  M","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"where N is the number of B-splines b_i, and M  N is the number of ϕ_j functions (in this example, M = N - 2).","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"The recombination matrix associated to the generated basis can be obtained using recombination_matrix:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"T = recombination_matrix(R)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Note that the matrix is almost an identity matrix, since most B-splines are kept intact in the new basis. This simple structure allows for very efficient computations using this matrix. The first and last columns indicate that Neumann BCs are imposed by adding the two first (and two last) B-splines, i.e.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"ϕ_1(x) = b_1(x) + b_2(x)\nqquad\nϕ_M(x) = b_N - 1(x) + b_N(x)","category":"page"},{"location":"generated/heat/#Representation-of-the-solution","page":"Heat equation","title":"Representation of the solution","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Note that the solution θ(x t) can be represented in the original and in the recombined B-spline bases as","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"θ(x t) = _i = 1^N v_i(t) b_i(x) = _j = 1^M u_j(t) ϕ_j(x)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"where the u_j are the coefficients in the recombined basis.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"The recombination matrix introduced above can be used to transform between the coefficients u_j and v_i in both bases, via the linear relation bmv = mathbfT bmu.","category":"page"},{"location":"generated/heat/#Initial-condition","page":"Heat equation","title":"Initial condition","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We come back now to our problem. We want to impose the following initial condition:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"θ(x 0) = θ_0(x) = 1 + cos(π x)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"First, we approximate this initial condition in the recombined B-spline basis that we have just constructed. This may be easily done using approximate:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"θ₀(x) = 1 + cos(π * x)\nθ₀_spline = approximate(θ₀, R, MinimiseL2Error())","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"To see that everything went well, we can plot the exact initial condition and its spline approximation, which show no important differences.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"fig = Figure(resolution = (800, 400))\nlet ax = Axis(fig[1, 1]; xlabel = L\"x\", ylabel = L\"\\theta\")\n    lines!(ax, -1..1, θ₀; label = L\"θ_0(x)\", color = :blue)\n    lines!(ax, -1..1, x -> θ₀_spline(x); label = \"Approximation\", color = :orange, linestyle = :dash)\n    axislegend(ax; position = :cb)\nend\nlet ax = Axis(fig[1, 2]; xlabel = L\"x\", ylabel = \"Difference\")\n    lines!(ax, -1..1, x -> θ₀(x) - θ₀_spline(x))\n    plot_knots!(ax, knots(R); knot_offset = 0)\nend\nfig","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Note that we have access to the recombined B-spline coefficients u_j associated to the initial condition, which we will use further below:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"u_init = coefficients(θ₀_spline)","category":"page"},{"location":"generated/heat/#Solving-the-heat-equation","page":"Heat equation","title":"Solving the heat equation","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"To solve the governing equation, the strategy is to project the unknown solution onto the chosen recombined basis. That is, we approximate the solution as","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"θ(x t) = sum_j = 1^M u_j(t)  ϕ_j(x)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Plugging this representation into the heat equation, we find","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"newcommandddmathrmd\n_j fracdd u_jdd t  ϕ_j(x) = ν _j u_j  ϕ_j(x)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"where primes denote spatial derivatives.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We can now use the method of mean weighted residuals to find the coefficients u_j, by projecting the above equation onto a chosen set of test functions φ_i:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"_j fracmathrmd u_jmathrmd t  φ_i ϕ_j = ν _j u_j  φ_i ϕ_j","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"where  f g  = _-1^1 f(x)  g(x)  mathrmd x is the inner product between functions.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"By choosing M different test functions φ_i, the above problem can be written as the linear system","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"mathbfA fracmathrmd bmu(t)mathrmd t =\nν mathbfL bmu(t)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"where the matrices are defined by A_ij =  φ_i ϕ_j  and L_ij =  φ_i ϕ_j .","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Two of the most common choices of test functions φ_i are:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"φ_i(x) = δ(x - x_i), where δ is Dirac's delta, and x_i are a set of collocation points where the equation will be satisfied. This approach is known as the collocation method.\nφ_i(x) = ϕ_i(x), in which case this is the Galerkin method.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We describe the solution using both methods in the following.","category":"page"},{"location":"generated/heat/#Collocation-method","page":"Heat equation","title":"Collocation method","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"For the collocation method, we need to choose a set of M grid points x_j. Since the basis functions implicitly satisfy the boundary conditions, these points must be chosen inside of the domain.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"The collocation points may be automatically generated by calling collocation_points. Note that, since we pass the recombined basis R, the boundaries are not included in the chosen points:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"xcol = collocation_points(R)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We can now construct the matrices mathbfA and mathbfL associated to the collocation method. By definition, these matrices simply contain the evaluations of all basis functions ϕ_j and their derivatives at the collocation points: A_ij = ϕ_j(x_i) and L_ij = ϕ_j(x_i). Both these matrices can be constructed in BSplineKit using collocation_matrix. Note that both matrices are of type CollocationMatrix, which wrap matrices defined in BandedMatrices.jl.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Acol = collocation_matrix(R, xcol)\nLcol = collocation_matrix(R, xcol, Derivative(2))","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"For convenience and performance, we can incorporate the heat diffusivity ν in the mathbfL matrix:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"ν = 0.01\nLcol *= ν","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Finally, for the time integration, we use OrdinaryDiffEq.jl from the DifferentialEquations.jl suite.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"using LinearAlgebra\nusing OrdinaryDiffEq\n\nfunction heat_rhs!(du, u, params, t)\n    mul!(du, params.L, u)    # du = ν * L * u\n    ldiv!(du, params.A, du)  # du = A \\ (ν * L * u)\n    du\nend\n\n# Solver parameters\nparams_col = (\n    A = lu(Acol),  # we pass the factorised matrix A for performance\n    L = Lcol,\n)\n\ntspan = (0.0, 10.0)\nprob = ODEProblem(heat_rhs!, u_init, tspan, params_col)\nsol_collocation = solve(prob, Tsit5(); saveat = 0.5)\n\nfunction plot_heat_solution(sol, R)\n    fig = Figure()\n    ax = Axis(fig[1, 1]; xlabel = L\"x\", ylabel = L\"θ(x, t)\")\n    colormap = cgrad(:viridis)\n    tspan = sol.prob.tspan\n    Δt = tspan[2] - tspan[1]\n    for (u, t) in tuples(sol)\n        S = Spline(R, u)\n        color = colormap[(t - tspan[1]) / Δt]\n        lines!(ax, -1..1, x -> S(x); label = string(t), color, linewidth = 2)\n    end\n    Colorbar(fig[1, 2]; colormap, limits = tspan, label = \"Time\")\n    fig\nend\n\nplot_heat_solution(sol_collocation, R)","category":"page"},{"location":"generated/heat/#Galerkin-method","page":"Heat equation","title":"Galerkin method","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We start by constructing the Galerkin matrices mathbfA and mathbfL. The first of these matrices, A_ij =  ϕ_i ϕ_j , is usually known as the mass matrix of the system. It is a positive definite symmetric matrix, which enables the use of Cholesky factorisation to solve the resulting linear system. Moreover, here it is banded thanks to the local support of the B-splines. The mass matrix can be constructed by calling galerkin_matrix:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Agal = galerkin_matrix(R)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Note that, unlike the collocation method, in the Galerkin method we don't need to specify a set of grid points, as functions are not evaluated at collocation points (they are instead integrated over the whole domain). The integration is performed using Gauss–Legendre quadrature, which can be made exact up to numerical precision, taking advantage of the fact that the product of two B-splines is a piecewise polynomial.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"As for the matrix mathbfL representing the second derivative operator, we can write it using integration by parts as","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"L_ij =  ϕ_i ϕ_j \n= - ϕ_i ϕ_j  + left ϕ_i ϕ_j right_-1^1  = -R_ij","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"where R_ij =  ϕ_i ϕ_j  is a positive definite symmetric matrix. Note that the boundary terms all vanish since all basis functions individually satisfy homogeneous Neumann boundary conditions, ϕ_i(1) = 0. (The same result would be obtained with homogeneous Dirichlet boundary conditions.)","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"As can be seen above, one well-known advantage of the Galerkin method is that the basis functions can satisfy weaker continuity conditions than in the collocation method, as high-order derivatives can be reduced using integration by parts.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"The matrix mathbfR can be constructed using galerkin_matrix:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Rgal = galerkin_matrix(R, (Derivative(1), Derivative(1)))","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Note that, instead, we could have constructed the original matrix mathbfL, which, as expected, is equal to mathbfR up to a sign:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Lgal = galerkin_matrix(R, (Derivative(0), Derivative(2)))","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"As in the collocation example, we include the heat diffusivity ν in the mathbfR matrix:","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"parent(Rgal) .*= -ν  # we can't directly multiply Rgal, as it's a Hermitian wrapper","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We finally solve using DifferentialEquations.jl. Note that not much is changed compared to the collocation example. The only difference is that we use a Cholesky factorisation for the mass matrix mathbfA.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"params_gal = (\n    A = cholesky(Agal),\n    L = Rgal,\n)\n\nprob = ODEProblem(heat_rhs!, u_init, tspan, params_gal)\nsol_galerkin = solve(prob, Tsit5(); saveat = 0.5)\n\nplot_heat_solution(sol_galerkin, R)","category":"page"},{"location":"generated/heat/#Result-comparison","page":"Heat equation","title":"Result comparison","text":"","category":"section"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"The solution of the Galerkin method looks very similar to the one obtained with the collocation method. However, as seen below, there are non-negligible differences between the two.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"fig = Figure(resolution = (800, 400))\nlet ax = Axis(fig[1, 1]; xlabel = L\"x\", ylabel = latexstring(\"θ(x, t = $(tspan[end]))\"))\n    for pair in (\n            \"Collocation\" => sol_collocation,\n            \"Galerkin\" => sol_galerkin,\n        )\n        label, sol = pair\n        u = last(sol.u)\n        S = Spline(R, u)\n        lines!(ax, -1..1, x -> S(x); label, linewidth = 2)\n    end\n    axislegend(ax; position = :cb)\nend\nlet ax = Axis(fig[1, 2]; xlabel = L\"x\", ylabel = \"Difference\")\n    Sc = Spline(R, last(sol_collocation.u))\n    Sg = Spline(R, last(sol_galerkin.u))\n    lines!(ax, -1..1, x -> Sc(x) - Sg(x); linewidth = 2)\nend\nfig","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"Compared to the Galerkin method, there seems to be some additional dissipation in the domain interior when using the collocation method. This hints at the presence of numerical dissipation introduced by this method.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"To finish, we compare the two solutions to a solution at a higher resolution, using a higher number of B-spline knots and a higher B-spline order. This last solution is obtained using the collocation method to allow for better comparisons between both methods.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"hi_res = let\n    knots_in = range(-1, 1; length = 101)\n    B = BSplineBasis(BSplineOrder(6), knots_in)\n    R = RecombinedBSplineBasis(Derivative(1), B)\n    θ₀_spline = approximate(θ₀, R)\n    u_init = coefficients(θ₀_spline)\n    xcol = collocation_points(R)\n    Acol = collocation_matrix(R, xcol)\n    Lcol = ν .* collocation_matrix(R, xcol, Derivative(2))\n    params_col = (A = lu(Acol), L = Lcol)\n    prob = ODEProblem(heat_rhs!, u_init, tspan, params_col)\n    sol = solve(prob, Tsit5(); saveat = 0.5)\n    (; R, sol)\nend\n\nfig = Figure(resolution = (800, 400))\nlet ax = Axis(fig[1, 1]; xlabel = L\"x\", ylabel = latexstring(\"θ(x, t = $(tspan[end]))\"))\n    for pair in (\n            \"Collocation\" => sol_collocation,\n            \"Galerkin\" => sol_galerkin,\n        )\n        label, sol = pair\n        u = last(sol.u)\n        S = Spline(R, u)\n        lines!(ax, -1..1, x -> S(x); label, linewidth = 2)\n    end\n    let u = last(hi_res.sol.u)\n        S = Spline(hi_res.R, u)\n        lines!(ax, -1..1, x -> S(x); label = \"Hi-res\", linewidth = 2, linestyle = :dash, color = :gray)\n    end\n    axislegend(ax; position = :cb)\nend\nlet ax = Axis(fig[1, 2]; xlabel = L\"x\", ylabel = \"Difference with hi-res solution\")\n    Sc = Spline(R, last(sol_collocation.u))\n    Sg = Spline(R, last(sol_galerkin.u))\n    S_hi = Spline(hi_res.R, last(hi_res.sol.u))\n    lines!(ax, -1..1, x -> Sc(x) - S_hi(x); label = \"Colloc.\", linewidth = 2)\n    lines!(ax, -1..1, x -> Sg(x) - S_hi(x); label = \"Galerkin\", linewidth = 2)\n    axislegend(ax; position = :rb)\nend\nfig","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"We see that the low-resolution solution with the Galerkin method matches the high-resolution solution. This confirms that the Galerkin method provides higher accuracy than the collocation method when both are used at the same resolution.","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"","category":"page"},{"location":"generated/heat/","page":"Heat equation","title":"Heat equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interpolation/#interpolation-api","page":"Data interpolation","title":"Data interpolation","text":"","category":"section"},{"location":"interpolation/","page":"Data interpolation","title":"Data interpolation","text":"CurrentModule = BSplineKit.SplineInterpolations","category":"page"},{"location":"interpolation/","page":"Data interpolation","title":"Data interpolation","text":"High-level interpolation of gridded data using B-splines.","category":"page"},{"location":"interpolation/#Functions","page":"Data interpolation","title":"Functions","text":"","category":"section"},{"location":"interpolation/","page":"Data interpolation","title":"Data interpolation","text":"interpolate\ninterpolate!","category":"page"},{"location":"interpolation/#Interpolations.interpolate","page":"Data interpolation","title":"Interpolations.interpolate","text":"interpolate(x, y, BSplineOrder(k), [bc = nothing])\n\nInterpolate values y at locations x using B-splines of order k.\n\nGrid points x must be real-valued and are assumed to be in increasing order.\n\nReturns a SplineInterpolation which can be evaluated at any intermediate point.\n\nOptionally, one may pass one of the boundary conditions listed in the Boundary conditions section. For now, only the Natural boundary condition is available.\n\nSee also interpolate!.\n\nMultidimensional interpolations\n\nMultidimensional (tensor-product) interpolations are supported on arbitrary dimensions N. For that, the following syntax should be used:\n\ninterpolate(xs, y, BSplineOrder(k), [bc = nothing])\n\nwhere xs = (x1, x2, …, xN) is a tuple of vectors containing the grid points along each direction, and y is an N-dimensional array containing the data to be interpolated. See further below for some examples.\n\nFor now, the B-spline order and the boundary conditions are the same along all dimensions. This constraint may be generalised in the future.\n\nExamples\n\nOne-dimensional interpolations\n\njulia> xs = -1:0.1:1;\n\njulia> ys = cospi.(xs);\n\njulia> itp = interpolate(xs, ys, BSplineOrder(4))\nSplineInterpolation containing the 21-element Spline{1, Float64}:\n basis: 21-element BSplineBasis of order 4, domain [-1.0, 1.0]\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3  …  0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1.0, 1.0, 1.0, 1.0]\n coefficients: [-1.0, -1.00111, -0.8975, -0.597515, -0.314147, 1.3265e-6, 0.314142, 0.597534, 0.822435, 0.96683  …  0.96683, 0.822435, 0.597534, 0.314142, 1.3265e-6, -0.314147, -0.597515, -0.8975, -1.00111, -1.0]\n interpolation points: -1.0:0.1:1.0\n\njulia> itp(-1)\n-1.0\n\njulia> (Derivative(1) * itp)(-1)\n-0.01663433622896893\n\njulia> (Derivative(2) * itp)(-1)\n10.52727328755495\n\njulia> Snat = interpolate(xs, ys, BSplineOrder(4), Natural())\nSplineInterpolation containing the 21-element Spline{1, Float64}:\n basis: 21-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0], BCs {left => (D{2},), right => (D{2},)}\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4  …  0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0]\n coefficients: [-0.833333, -0.647516, -0.821244, -0.597853, -0.314057, -2.29076e-5, 0.314148, 0.597532, 0.822435, 0.96683  …  0.96683, 0.822435, 0.597532, 0.314148, -2.29076e-5, -0.314057, -0.597853, -0.821244, -0.647516, -0.833333]\n interpolation points: -1.0:0.1:1.0\n\njulia> Snat(-1)\n-1.0\n\njulia> (Derivative(1) * Snat)(-1)\n0.28726186708894824\n\njulia> (Derivative(2) * Snat)(-1)\n0.0\n\n\nTwo-dimensional interpolations\n\njulia> x₁ = -1:0.2:1; x₂ = 0:0.1:0.8;\n\njulia> ydata = @. cospi(x₁) * sinpi(x₂');\n\njulia> summary(ydata)\n\"11×9 Matrix{Float64}\"\n\njulia> itp = interpolate((x₁, x₂), ydata, BSplineOrder(4), Natural())\nSplineInterpolation containing the 11×9 Spline{2, Float64}:\n bases:\n   (1) 11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0], BCs {left => (D{2},), right => (D{2},)}\n   (2) 9-element RecombinedBSplineBasis of order 4, domain [0.0, 0.8], BCs {left => (D{2},), right => (D{2},)}\n knots:\n   (1) [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n   (2) [0.0, 0.0, 0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.8]\n coefficients: [0.0 -0.174524 … -0.458359 -0.408184; 0.0 -0.123177 … -0.323506 -0.288093; … ; 0.0 -0.123177 … -0.323506 -0.288093; 0.0 -0.174524 … -0.458359 -0.408184]\n interpolation points:\n  (1) -1.0:0.2:1.0\n  (2) 0.0:0.1:0.8\n\njulia> itp(0.12, 0.4242)\n0.9032397652177311\n\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#Interpolations.interpolate!","page":"Data interpolation","title":"Interpolations.interpolate!","text":"interpolate!(I::SplineInterpolation{N}, y::AbstractArray{T,N})\n\nUpdate spline interpolation with new data.\n\nThis function allows to reuse a SplineInterpolation returned by a previous call to interpolate, using new data on the same locations x.\n\nSee interpolate for details.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#Types","page":"Data interpolation","title":"Types","text":"","category":"section"},{"location":"interpolation/","page":"Data interpolation","title":"Data interpolation","text":"SplineInterpolation","category":"page"},{"location":"interpolation/#BSplineKit.SplineInterpolations.SplineInterpolation","page":"Data interpolation","title":"BSplineKit.SplineInterpolations.SplineInterpolation","text":"SplineInterpolation\n\nSpline interpolation.\n\nThis is the type returned by interpolate.\n\nA SplineInterpolation I can be evaluated at any point x using the I(x) syntax.\n\nIt can also be updated with new data on the same data points using interpolate!.\n\n\n\nSplineInterpolation(undef, B::AbstractBSplineBasis, x::AbstractVector, [T = eltype(x)])\n\nInitialise a SplineInterpolation from B-spline basis and a set of interpolation (or collocation) points x.\n\nNote that the length of x must be equal to the number of B-splines.\n\nUse interpolate! to actually interpolate data known on the x locations.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplines-api","page":"B-splines","title":"B-splines","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"CurrentModule = BSplineKit.BSplines","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"BSplines","category":"page"},{"location":"bsplines/#BSplineKit.BSplines","page":"B-splines","title":"BSplineKit.BSplines","text":"BSplines\n\nModule defining B-spline bases and B-spline related functions.\n\n\n\n\n\n","category":"module"},{"location":"bsplines/#B-spline-bases","page":"B-splines","title":"B-spline bases","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"AbstractBSplineBasis\nBSplineBasis\nboundaries\norder\nknots\ngetindex\nlength(::BSplineBasis)","category":"page"},{"location":"bsplines/#BSplineKit.BSplines.AbstractBSplineBasis","page":"B-splines","title":"BSplineKit.BSplines.AbstractBSplineBasis","text":"AbstractBSplineBasis{k,T}\n\nAbstract type defining a B-spline basis, or more generally, a functional basis defined from B-splines.\n\nThe basis is represented by a B-spline order k and a knot element type T.\n\n\n\n(B::AbstractBSplineBasis)(\n    x::Real, [op = Derivative(0)], [T = float(typeof(x))];\n    [ileft = nothing],\n) -> (i, bs)\n\nEvaluates all basis functions which are non-zero at x.\n\nThis is a convenience alias for evaluate_all. See evaluate_all for details on optional arguments and on the returned values.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.1:1)\n23-element BSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4  …  0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0]\n\njulia> i, bs = B(0.42)\n(18, (0.0013333333333333268, 0.28266666666666657, 0.6306666666666667, 0.08533333333333339))\n\njulia> sum(bs)\n1.0\n\njulia> bs[1] - B[i](0.42)\n0.0\n\njulia> bs[2] - B[i - 1](0.42)\n-5.551115123125783e-17\n\njulia> B(0.44; ileft = i)\n(18, (0.01066666666666666, 0.4146666666666667, 0.5386666666666665, 0.03599999999999999))\n\njulia> B(0.42, Float32)\n(18, (0.0013333336f0, 0.28266668f0, 0.6306667f0, 0.085333325f0))\n\njulia> B(0.42, Derivative(1))\n(18, (0.19999999999999937, 6.4, -3.3999999999999977, -3.200000000000001))\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.BSplineBasis","page":"B-splines","title":"BSplineKit.BSplines.BSplineBasis","text":"BSplineBasis{k}\n\nB-spline basis for splines of order k.\n\nThe basis is defined by a set of knots and by the B-spline order.\n\n\n\nBSplineBasis(k, breakpoints::AbstractVector; augment = Val(true))\n\nCreate B-spline basis of order k with the given breakpoints.\n\nIf augment = Val(true), breakpoints will be \"augmented\" so that boundary knots have multiplicity k. Note that, if they are passed as a regular Vector, the input may be modified. See augment_knots! for details.\n\nExamples\n\njulia> breaks = range(-1, 1, length = 21)\n-1.0:0.1:1.0\n\njulia> B = BSplineBasis(5, breaks)\n24-element BSplineBasis of order 5, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5  …  0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0, 1.0]\n\nThis is equivalent to the above:\n\njulia> B = BSplineBasis(BSplineOrder(5), breaks)\n24-element BSplineBasis of order 5, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5  …  0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0, 1.0]\n\nNote that first and last knots are repeated k = 5 times.\n\nIf augment = Val(false), input breakpoints are taken without modification as the knots t_i of the B-spline basis. Note that the valid domain is reduced to -06 06. The domain is always defined as the range t_k t_N + 1, where N is the length of the basis (below, N = 16).\n\njulia> Bn = BSplineBasis(5, breaks, augment = Val(false))\n16-element BSplineBasis of order 5, domain [-0.6, 0.6]\n knots: -1.0:0.1:1.0\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.boundaries","page":"B-splines","title":"BSplineKit.BSplines.boundaries","text":"boundaries(B::AbstractBSplineBasis)\n\nReturns (xmin, xmax) tuple with the boundaries of the domain supported by the basis.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.order","page":"B-splines","title":"BSplineKit.BSplines.order","text":"order(::Type{BSplineBasis}) -> Int\norder(::Type{Spline}) -> Int\norder(::BSplineOrder) -> Int\n\nReturns order of B-splines as an integer.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.knots","page":"B-splines","title":"BSplineKit.BSplines.knots","text":"knots(g::BSplineBasis)\nknots(g::Spline1D)\n\nReturns the knots of the B-spline basis.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Base.getindex","page":"B-splines","title":"Base.getindex","text":"getindex(B::AbstractBSplineBasis, i, [T = Float64])\n\nGet i-th basis function.\n\nThis is an alias for BasisFunction(B, i, T) (see BasisFunction for details).\n\nThe returned object can be evaluated at any point within the boundaries defined by the basis.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.1:1)\n23-element BSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4  …  0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0]\n\njulia> B[6]\nBasis function i = 6\n  from 23-element BSplineBasis of order 4, domain [-1.0, 1.0]\n  support: [-0.8, -0.4) (knots 6:10)\n\njulia> B[6](-0.5)\n0.16666666666666666\n\njulia> B[6, Float32](-0.5)\n0.16666667f0\n\njulia> B[6](-0.5, Derivative(1))\n-5.000000000000001\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Base.length-Tuple{BSplineBasis}","page":"B-splines","title":"Base.length","text":"length(g::BSplineBasis)\n\nReturns the number of B-splines composing a spline.\n\n\n\n\n\n","category":"method"},{"location":"bsplines/#Basis-functions","page":"B-splines","title":"Basis functions","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"BasisFunction\nsupport\ncommon_support\nfind_knot_interval\nevaluate_all\nevaluate\nevaluate!\nnonzero_in_segment","category":"page"},{"location":"bsplines/#BSplineKit.BSplines.BasisFunction","page":"B-splines","title":"BSplineKit.BSplines.BasisFunction","text":"BasisFunction{B <: AbstractBSplineBasis, T}\n\nDescribes a single basis function.\n\nThe basis function may belong to a BSplineBasis (in which case it's effectively a B-spline), or to a basis derived from a B-spline basis (such as a RecombinedBSplineBasis).\n\n\n\nBasisFunction(basis::AbstractBSplineBasis, i::Int, [T = Float64])\n\nConstruct i-th basis function of the given basis.\n\nThe constructed function can be evaluated as b(x), returning a value of type T.\n\n\n\n(b::BasisFunction)(x, [op::AbstractDifferentialOp])\n\nEvaluate basis function at coordinate x.\n\nTo evaluate a derivative, pass Derivative(n) as the op argument, with n the derivative order.\n\nTo evaluate multiple derivatives, pass a derivative range Derivative(m:n). In particular, Derivative(m:n) evaluates the basis function itself and its first n derivatives.\n\nMore general differential operators, such as Derivative(n) + λ Derivative(m), are also supported.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.support","page":"B-splines","title":"BSplineKit.BSplines.support","text":"support(b::BasisFunction) -> UnitRange{Int}\n\nGet range of knots supported by the basis function.\n\nReturns the knot range i:j such that the basis function support is t  t_i t_j).\n\n\n\n\n\nsupport(B::AbstractBSplineBasis, i::Integer) -> UnitRange{Int}\n\nGet range of knots supported by the i-th basis function.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.common_support","page":"B-splines","title":"BSplineKit.BSplines.common_support","text":"common_support(b1::BasisFunction, b2::BasisFunction, ...) -> UnitRange{Int}\n\nGet range of knots commonly supported by different basis functions.\n\nIf the supports don't intersect, an empty range is returned (e.g. 6:5), following the behaviour of intersect. The lack of intersection can be checked using isempty, which returns true for such a range.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.find_knot_interval","page":"B-splines","title":"BSplineKit.BSplines.find_knot_interval","text":"find_knot_interval(ts::AbstractVector, x::Real) -> (i, zone)\n\nFinds the index i corresponding to the knot interval t_i t_i + 1 that should be used to evaluate B-splines at location x.\n\nThe knot vector is assumed to be sorted in non-decreasing order.\n\nIt also returns a zone integer, which is:\n\n0  if x is within the knot domain (ts[begin] ≤ x ≤ ts[end]),\n-1 if x < ts[begin],\n1  if x > ts[end].\n\nThis function is functionally equivalent to de Boor's INTERV routine (de Boor 2001, p. 74).\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate_all","page":"B-splines","title":"BSplineKit.BSplines.evaluate_all","text":"evaluate_all(\n    B::BSplineBasis, x::Real,\n    [op = Derivative(0)], [T = float(typeof(x))];\n    [ileft = nothing],\n) -> i, bs\n\nEvaluate all B-splines which are non-zero at coordinate x.\n\nReturns a tuple (i, bs), where i is an index identifying the basis functions that were computed, and bs is a tuple with the actual values.\n\nMore precisely:\n\ni is the index of the first B-spline knot t_i when going from x towards the left. In other words, it is such that t_i  x  t_i + 1.\nIt is effectively computed as i = searchsortedlast(knots(B), x). If the correct value of i is already known, one can avoid this computation by manually passing this index via the optional ileft keyword argument.\nbs is a tuple of B-splines evaluated at x:\n(b_i(x) b_i - 1(x)  b_i - k + 1(x))\nIt contains k values, where k is the order of the B-spline basis. Note that values are returned in backwards order starting from the i-th B-spline.\n\nComputing derivatives\n\nOne can pass the optional op argument to compute B-spline derivatives instead of the actual B-spline values.\n\nExamples\n\nSee AbstractBSplineBasis for some examples using the alternative evaluation syntax B(x, [op], [T]; [ileft]), which calls this function.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate","page":"B-splines","title":"BSplineKit.BSplines.evaluate","text":"evaluate(B::AbstractBSplineBasis, i::Integer, x,\n         [op::AbstractDifferentialOp], [T=Float64])\n\nEvaluate i-th basis function in the given basis at x (can be a coordinate or a vector of coordinates).\n\nTo evaluate a derivative, pass Derivative(n) as the op argument, with n the derivative order.\n\nMore general differential operators, such as Derivative(n) + λ Derivative(m), are also supported.\n\nSee also evaluate!.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate!","page":"B-splines","title":"BSplineKit.BSplines.evaluate!","text":"evaluate!(b::AbstractVector, B::BSplineBasis, i::Integer,\n          x::AbstractVector, args...)\n\nEvaluate i-th basis function at positions x and write result to b.\n\nSee also evaluate.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.nonzero_in_segment","page":"B-splines","title":"BSplineKit.BSplines.nonzero_in_segment","text":"nonzero_in_segment(B::AbstractBSplineBasis, n::Int) -> UnitRange{Int}\n\nReturns the range of basis functions that are non-zero in a given knot segment.\n\nThe n-th knot segment is defined by Ω_n = t_n t_n + 1.\n\nFor BSplineBasis and RecombinedBSplineBasis, the number of non-zero functions in any given segment is generally equal to the B-spline order k. This number decreases near the borders, but this is not significant when B-spline knots have multiplicity k there (as is the default).\n\nFor B-spline bases, and excepting the borders, the non-zero B-splines are left b_i right_i = n - k + 1^n. This function thus returns (n - k + 1):N when B is a BSplineBasis.\n\nSee also support for the inverse operation.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Internals","page":"B-splines","title":"Internals","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"BSplineOrder\nAugmentedKnots\naugment_knots!\nmultiplicity","category":"page"},{"location":"bsplines/#BSplineKit.BSplines.BSplineOrder","page":"B-splines","title":"BSplineKit.BSplines.BSplineOrder","text":"BSplineOrder(k::Integer)\n\nSpecifies the B-spline order k.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.AugmentedKnots","page":"B-splines","title":"BSplineKit.BSplines.AugmentedKnots","text":"AugmentedKnots{T,k} <: AbstractVector{T}\n\nPads from both sides a vector of B-spline breakpoints, making sure that the first and last values are repeated k times.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.augment_knots!","page":"B-splines","title":"BSplineKit.BSplines.augment_knots!","text":"augment_knots!(breaks::AbstractVector, k::Union{Integer,BSplineOrder})\n\nModifies the input breakpoints to make sure that the first and last knot have multiplicity k for splines of order k.\n\nTo prevent allocations, this function will modify the input when this is a standard Vector. Otherwise, the input will be wrapped inside an AugmentedKnots object.\n\nIt is assumed that the input breakpoints have multiplicity 1 at the borders. That is, border coordinates should not be repeated in the input.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.multiplicity","page":"B-splines","title":"BSplineKit.BSplines.multiplicity","text":"multiplicity(knots, i)\n\nDetermine multiplicity of knot knots[i].\n\n\n\n\n\n","category":"function"},{"location":"diffops/#Differential-operators","page":"Differential operators","title":"Differential operators","text":"","category":"section"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"CurrentModule = BSplineKit.DifferentialOps","category":"page"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"DifferentialOps","category":"page"},{"location":"diffops/#BSplineKit.DifferentialOps","page":"Differential operators","title":"BSplineKit.DifferentialOps","text":"DifferentialOps\n\nModule defining types describing differential operators and compositions thereof.\n\n\n\n\n\n","category":"module"},{"location":"diffops/#Operators","page":"Differential operators","title":"Operators","text":"","category":"section"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"AbstractDifferentialOp\nDerivative\nDerivativeUnitRange\nScaledDerivative\nDifferentialOpSum\nmax_order","category":"page"},{"location":"diffops/#BSplineKit.DifferentialOps.AbstractDifferentialOp","page":"Differential operators","title":"BSplineKit.DifferentialOps.AbstractDifferentialOp","text":"AbstractDifferentialOp\n\nRepresents a general differential operator.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.Derivative","page":"Differential operators","title":"BSplineKit.DifferentialOps.Derivative","text":"Derivative{n} <: AbstractDifferentialOp\n\nSpecifies the n-th derivative of a function.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.DerivativeUnitRange","page":"Differential operators","title":"BSplineKit.DifferentialOps.DerivativeUnitRange","text":"DerivativeUnitRange{m, n} <: AbstractDifferentialOp\n\nSpecifies a range of derivatives.\n\nExamples\n\nTwo ways of constructing derivative ranges:\n\njulia> Derivative(2):Derivative(4)\nDerivative(2:4)\n\njulia> Derivative(2:4)\nDerivative(2:4)\n\njulia> Tuple(Derivative(2:4))\n(D{2}, D{3}, D{4})\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.ScaledDerivative","page":"Differential operators","title":"BSplineKit.DifferentialOps.ScaledDerivative","text":"ScaledDerivative{n} <: AbstractDifferentialOp\n\nn-th derivative of a function scaled by a constant coefficient.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.DifferentialOpSum","page":"Differential operators","title":"BSplineKit.DifferentialOps.DifferentialOpSum","text":"DifferentialOpSum <: AbstractDifferentialOp\n\nSum of two differential operators.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.max_order","page":"Differential operators","title":"BSplineKit.DifferentialOps.max_order","text":"max_order(op::AbstractDifferentialOp)\nmax_order(ops...)\n\nGet maximum derivative order of one or more differential operators.\n\n\n\n\n\n","category":"function"},{"location":"diffops/#Projections","page":"Differential operators","title":"Projections","text":"","category":"section"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"AbstractNormalDirection\nLeftNormal\nRightNormal\ndot(::AbstractDifferentialOp, ::AbstractNormalDirection)","category":"page"},{"location":"diffops/#BSplineKit.DifferentialOps.AbstractNormalDirection","page":"Differential operators","title":"BSplineKit.DifferentialOps.AbstractNormalDirection","text":"AbstractNormalDirection\n\nRepresents the normal direction on a given domain boundary.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.LeftNormal","page":"Differential operators","title":"BSplineKit.DifferentialOps.LeftNormal","text":"LeftNormal <: AbstractNormalDirection\n\nSpecifies the normal direction on the left boundary of a 1D domain.\n\nThe left normal direction goes opposite to the coordinate axis.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.RightNormal","page":"Differential operators","title":"BSplineKit.DifferentialOps.RightNormal","text":"RightNormal <: AbstractNormalDirection\n\nSpecifies the normal direction on the right boundary of a 1D domain.\n\nThe right normal direction is equal to that of the coordinate axis.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#LinearAlgebra.dot-Tuple{BSplineKit.DifferentialOps.AbstractDifferentialOp, BSplineKit.DifferentialOps.AbstractNormalDirection}","page":"Differential operators","title":"LinearAlgebra.dot","text":"dot(op::AbstractDifferentialOp, dir::AbstractNormalDirection) -> AbstractDifferentialOp\n\nProject derivative along a normal direction.\n\nThis should be used to convert from a normal derivative at the boundaries, to a derivative along the coordinate axes of the domain.\n\nIn practice, this returns op for RightNormal. For LeftNormal, it multiplies the odd-order derivatives by -1.\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#boundary-conditions-api","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"CurrentModule = BSplineKit.BoundaryConditions","category":"page"},{"location":"boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"BoundaryConditions","category":"page"},{"location":"boundary_conditions/#BSplineKit.BoundaryConditions","page":"Boundary conditions","title":"BSplineKit.BoundaryConditions","text":"BSplineKit.BoundaryConditions\n\nContains some boundary condition definitions.\n\n\n\n\n\n","category":"module"},{"location":"boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Natural","category":"page"},{"location":"boundary_conditions/#BSplineKit.BoundaryConditions.Natural","page":"Boundary conditions","title":"BSplineKit.BoundaryConditions.Natural","text":"Natural\n\nGeneralised natural boundary condition.\n\nThis boundary condition is convenient for spline interpolations, as it provides extra constraints enabling to equate the number of unique B-spline knots to the number of data points.\n\nFor cubic splines (order k = 4), this corresponds to natural cubic splines, imposing the second derivatives to be zero at the boundaries (S(a) = S(b) = 0).\n\nFor higher-order splines, this boundary condition generalises the standard natural cubic splines, by setting derivatives of order 2 3  k2 to be zero at the boundaries. For instance, for k = 6 (quintic splines), this imposes S = S = 0. In practice, BSplineKit.jl achieves this by using basis recombination.\n\nNote that, for symmetry reasons, only even-order splines are supported by this BC.\n\n\n\n\n\n","category":"type"},{"location":"galerkin/#galerkin-api","page":"Galerkin tools","title":"Galerkin tools","text":"","category":"section"},{"location":"galerkin/","page":"Galerkin tools","title":"Galerkin tools","text":"CurrentModule = BSplineKit","category":"page"},{"location":"galerkin/#Projections","page":"Galerkin tools","title":"Projections","text":"","category":"section"},{"location":"galerkin/","page":"Galerkin tools","title":"Galerkin tools","text":"galerkin_projection\ngalerkin_projection!","category":"page"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_projection","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_projection","text":"galerkin_projection(\n    f, B::AbstractBSplineBasis,\n    [deriv = Derivative(0)], [VectorType = Vector{Float64}],\n)\n\nPerform Galerkin projection of a function f onto the given basis.\n\nBy default, returns a vector with values\n\nφ_i =  b_i f \n= _a^b b_i(x)  f(x)  mathrmdx\n\nwhere a and b are the boundaries of the B-spline basis  b_i _i = 1^N.\n\nThe integrations are performed using Gauss–Legendre quadrature. The number of quadrature nodes is chosen so that the result is exact when f is a polynomial of degree k - 1 (or, more generally, a spline belonging to the space spanned by the basis B). Here k is the order of the B-spline basis. In the more general case, this function returns a quadrature approximation of the projection.\n\nSee also galerkin_projection! for the in-place operation, and galerkin_matrix for more details.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_projection!","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_projection!","text":"galerkin_projection!(\n    f, φ::AbstractVector, B::AbstractBSplineBasis, [deriv = Derivative(0)],\n)\n\nCompute Galerkin projection φ_i =  b_i f .\n\nSee galerkin_projection for details.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#Matrices","page":"Galerkin tools","title":"Matrices","text":"","category":"section"},{"location":"galerkin/","page":"Galerkin tools","title":"Galerkin tools","text":"galerkin_matrix\ngalerkin_matrix!","category":"page"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_matrix","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_matrix","text":"galerkin_matrix(\n    B::AbstractBSplineBasis,\n    [deriv = (Derivative(0), Derivative(0))],\n    [MatrixType = BandedMatrix{Float64}],\n)\n\nCompute Galerkin mass or stiffness matrix, as well as more general variants of these.\n\nExtended help\n\nThe Galerkin mass matrix is defined as\n\nM_ij =  ϕ_i ϕ_j  quad textfor quad\ni  1 N text and  j  1 N\n\nwhere ϕ_i(x) is the i-th basis function and N = length(B) is the number of functions in the basis B. Here, f g is the L^2 inner product between functions f and g.\n\nSince products of B-splines are themselves piecewise polynomials, integrals can be computed exactly using Gaussian quadrature rules. To do this, we use Gauss–Legendre quadratures via the FastGaussQuadrature package.\n\nMatrix layout and types\n\nThe mass matrix is banded with 2k - 1 bands. Moreover, the matrix is symmetric and positive definite, and only k bands are needed to fully describe the matrix. Hence, a Hermitian view of an underlying matrix is returned.\n\nBy default, the underlying matrix holding the data is a BandedMatrix that defines the upper part of the symmetric matrix. Other types of container are also supported, including regular sparse matrices (SparseMatrixCSC) and dense arrays (Matrix). See collocation_matrix for a discussion on matrix types.\n\nDerivatives of basis functions\n\nGalerkin matrices associated to the derivatives of basis functions may be constructed using the optional deriv parameter. For instance, if deriv = (Derivative(0), Derivative(2)), the matrix  ϕ_i ϕ_j  is constructed, where primes denote derivatives. Note that, if the derivative orders are different, the resulting matrix is not symmetric, and a Hermitian view is not returned in those cases.\n\nCombining different bases\n\nMore generally, it is possible to compute matrices of the form  ψ_i^(n) ϕ_j^(m) , where n and m are derivative orders, and ψ_i and ϕ_j belong to two different (but related) bases B₁ and B₂. For this, instead of the B parameter, one must pass a tuple of bases (B₁, B₂). The restriction is that the bases must have the same parent B-spline basis. That is, they must share the same set of B-spline knots and be of equal polynomial order.\n\nNote that, if both bases are different, the matrix will not be symmetric, and will not even be square if the bases have different lengths.\n\nIn practice, this feature may be used to combine a B-spline basis B, with a recombined basis R generated from B (see Basis recombination).\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_matrix!","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_matrix!","text":"galerkin_matrix!(A::AbstractMatrix, B::AbstractBSplineBasis,\n                 deriv = (Derivative(0), Derivative(0)))\n\nFill preallocated Galerkin matrix.\n\nThe matrix may be a Hermitian view, in which case only one half of the matrix will be filled. Note that, for the matrix to be symmetric, both derivative orders in deriv must be the same.\n\nMore generally, it is possible to combine different functional bases by passing a tuple of AbstractBSplineBasis as B.\n\nSee galerkin_matrix for details.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#Banded-3D-tensors","page":"Galerkin tools","title":"Banded 3D tensors","text":"","category":"section"},{"location":"galerkin/","page":"Galerkin tools","title":"Galerkin tools","text":"galerkin_tensor\ngalerkin_tensor!","category":"page"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_tensor","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_tensor","text":"galerkin_tensor(\n    B::AbstractBSplineBasis,\n    (D₁::Derivative, D₂::Derivative, D₃::Derivative),\n    [T = Float64],\n)\n\nCompute 3D banded tensor appearing from quadratic terms in Galerkin method.\n\nAs with galerkin_matrix, it is also possible to combine different functional bases by passing, instead of B, a tuple (B₁, B₂, B₃) of three AbstractBSplineBasis. For now, the first two bases, B₁ and B₂, must have the same length.\n\nThe tensor is efficiently stored in a BandedTensor3D object.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_tensor!","page":"Galerkin tools","title":"BSplineKit.Galerkin.galerkin_tensor!","text":"galerkin_tensor!(\n    A::BandedTensor3D,\n    B::AbstractBSplineBasis,\n    (D₁::Derivative, D₂::Derivative, D₃::Derivative),\n)\n\nCompute 3D Galerkin tensor in-place.\n\nSee galerkin_tensor for details.\n\n\n\n\n\n","category":"function"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"EditURL = \"https://github.com/jipolanco/BSplineKit.jl/blob/master/examples/approximation.jl\"","category":"page"},{"location":"generated/approximation/#function-approximation-example","page":"Function approximation","title":"Function approximation","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"The objective of this example is to approximate a known function f by a spline.","category":"page"},{"location":"generated/approximation/#Exact-function","page":"Function approximation","title":"Exact function","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"We consider the function f(x) = e^-x cos(8πx) in the interval x  0 1.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")\n\nx_interval = 0..1\nf(x) = exp(-x) * cospi(8x)\n\nfig = Figure(resolution = (800, 600))\nax = Axis(fig[1, 1]; xlabel = \"x\")\nlines!(ax, x_interval, f)\nfig","category":"page"},{"location":"generated/approximation/#Approximation-space","page":"Function approximation","title":"Approximation space","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"To approximate this function using a spline, we first need to define a B-spline basis  b_i _i = 1^N describing a spline space. The approximating spline can then be written as","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"g(x) = _i = 1^N c_i b_i(x)","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"where the c_i are the B-spline coefficients describing the spline. The objective is thus to find the coefficients c_i that result in the best possible approximation of the function f.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Here we use splines of order k = 4 (polynomial degree d = 3, i.e. cubic splines). For simplicity, we choose the B-spline knots to be uniformly distributed.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"using BSplineKit\n\nξs = range(x_interval; length = 15)\nB = BSplineBasis(BSplineOrder(4), ξs)","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"We plot below the knots and the basis functions describing the spline space. Note that knots are represented by grey crosses.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"function plot_knots!(ax, ts; ybase = 0, knot_offset = 0.03, kws...)\n    ys = zero(ts) .+ ybase\n    # Add offset to distinguish knots with multiplicity > 1\n    if knot_offset !== nothing\n        for i in eachindex(ts)[(begin + 1):end]\n            if ts[i] == ts[i - 1]\n                ys[i] = ys[i - 1] + knot_offset\n            end\n        end\n    end\n    scatter!(ax, ts, ys; marker = :x, color = :gray, markersize = 16, kws...)\n    ax\nend\n\nfunction plot_basis!(ax, B; eval_args = (), kws...)\n    cmap = cgrad(:tab20)\n    N = length(B)\n    ts = knots(B)\n    hlines!(ax, 0; color = :gray)\n    for (n, bi) in enumerate(B)\n        color = cmap[(n - 1) / (N - 1)]\n        i, j = extrema(support(bi))\n        lines!(ax, ts[i]..ts[j], x -> bi(x, eval_args...); color, linewidth = 2.5)\n    end\n    plot_knots!(ax, ts; kws...)\n    ax\nend\n\nfig = Figure(resolution = (800, 600))\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"bᵢ(x)\")\nplot_basis!(ax, B; knot_offset = 0.05)\nfig","category":"page"},{"location":"generated/approximation/#Approximating-the-function","page":"Function approximation","title":"Approximating the function","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Three different methods are implemented in BSplineKit to approximate functions. In increasing order of accuracy and complexity, these are:","category":"page"},{"location":"generated/approximation/#.-[VariationDiminishing](@ref)","page":"Function approximation","title":"1. VariationDiminishing","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Implements Schoenberg's variation diminishing approximation. This simply consists on estimating the spline coefficients as c_i = f(x_i), where the x_i are the Greville sites. These are obtained by window-averaging the B-spline knots t_j:","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"x_i = frac1k - 1 _j = 1^k - 1 t_i + j","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"This approximation is expected to preserve the shape of the function. However, as shown below, it is usually very inaccurate as an actual approximation, and should only be used when a qualitative estimation of f is sufficient.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"S_vd = approximate(f, B, VariationDiminishing())","category":"page"},{"location":"generated/approximation/#.-[ApproxByInterpolation](@ref)","page":"Function approximation","title":"2. ApproxByInterpolation","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Approximates the original function by interpolating on a discrete set of interpolation points. In other words, the resulting spline exactly matches f at those points.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"By default, the interpolation points are chosen as the Greville sites associated to the B-spline basis (using collocation_points; see also Collocation.AvgKnots). For more control, the interpolation points may also be directly set via the ApproxByInterpolation constructor.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"In the below example, we pass the B-spline basis to the ApproxByInterpolation constructor, which automatically determines the collocation points as explained above.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"S_interp = approximate(f, B, ApproxByInterpolation(B))  # or simply approximate(f, B)","category":"page"},{"location":"generated/approximation/#.-[MinimiseL2Error](@ref)","page":"Function approximation","title":"3. MinimiseL2Error","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Approximates the function by minimising the L^2 distance between f and its spline approximation g.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"In other words, it minimises","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"mathcalLg = leftlVert f - g rightrVert^2 = left f - g f - g right","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"where","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"left u v right = _a^b u(x)  v(x)  mathrmdx","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"is the inner product between two functions, and a and b are the boundaries of the prescribed B-spline basis.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"One can show that the optimal coefficients c_i minimising the L^2 error are the solution to the linear system bmM bmc = bmφ, where M_ij = left b_i b_j right and φ_i = left b_i f right. These two terms are respectively computed by galerkin_matrix and galerkin_projection.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Indeed, this can be shown by taking the differential","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"δmathcalLg = mathcalLg + δg - mathcalLg\n= 2 left δg g - f right","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"where δg is a small perturbation of the spline g. The optimal spline g^*, minimising the L^2 distance, is such that δmathcalLg^* = 0.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Noting that g = c_i b_i (where summing is implicitly performed over repeated indices), the perturbation is given by δg = δc_i b_i, as the B-spline basis is assumed fixed. The optimal spline then satisfies","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"left b_i g^* - f right δc_i\n= left left b_i b_j right c_j^* - left b_i f right right δc_i\n= left M_ij c_j^* - φ_i right δc_i\n= 0","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"for all perturbations δbmc, leading to the linear system stated above.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"As detailed in galerkin_projection, integrals are computed via Gauss–Legendre quadratures, in a way that ensures that the result is exact when f is a polynomial of degree up to k - 1 (or more generally, a spline belonging to the space spanned by the chosen B-spline basis).","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"S_minL2 = approximate(f, B, MinimiseL2Error())","category":"page"},{"location":"generated/approximation/#Method-comparison","page":"Function approximation","title":"Method comparison","text":"","category":"section"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Below, the approximations using the three methods are compared to the actual function f.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"fig = Figure(resolution = (1000, 750))\ncolours = theme(fig.scene).palette.color[]\nstyle_vd = (color = colours[3], label = \"Variation diminishing\")\nstyle_interp = (color = colours[2], label = \"Interpolation\")\nstyle_minL2 = (color = colours[1], label = \"L² minimisation\")\nlet ax = Axis(fig[1:2, 1]; xlabel = \"x\", ylabel = \"Approximation\")\n    plot_knots!(ax, knots(B); knot_offset = nothing)\n    lines!(ax, x_interval, f; color = :black, linewidth = 2, label = \"Original\")\n    lines!(ax, x_interval, x -> S_vd(x); style_vd...)\n    lines!(ax, x_interval, x -> S_interp(x); style_interp...)\n    lines!(ax, x_interval, x -> S_minL2(x); style_minL2...)\n    axislegend(ax)\nend\nlet ax = Axis(fig[1, 2]; ylabel = \"Difference with original\")\n    plot_knots!(ax, knots(B); knot_offset = nothing)\n    lines!(ax, x_interval, x -> S_interp(x) - f(x); style_interp...)\n    lines!(ax, x_interval, x -> S_minL2(x) - f(x); style_minL2...)\n    hidexdecorations!(ax; grid = false)\n    axislegend(ax; position = :rt, orientation = :horizontal)\nend\nlet ax = Axis(fig[2, 2]; xlabel = \"x\", ylabel = \"Squared difference\", yscale = log10)\n    ylims!(1e-8, 1e-2)\n    plot_knots!(ax, knots(B); knot_offset = nothing, ybase = 1e-6)\n    lines!(ax, x_interval, x -> abs2(S_interp(x) - f(x)); style_interp...)\n    lines!(ax, x_interval, x -> abs2(S_minL2(x) - f(x)); style_minL2...)\nend\nfig","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"As seen above, the variation diminishing approximation, while capturing the shape of the original function, doesn't really provide an accurate approximation of it.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"The other two methods are much more accurate. On the right half of the figure, a detailed comparison of the two is provided, by plotting the difference between each approximation and the actual f function.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"The interpolation method works pretty well, matching exactly the actual function at the interpolation points. Note that, in this example, most interpolation points match the spline knots. This is because we're using splines of even degree (k = 4) and because knots are uniformly spaced.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"Nevertheless, when looking at the global error, the L^2 minimisation method works best, as expected. In particular, as seen above, it reduces the maximum approximation error (i.e. the L^ distance, leftlVert f - g rightrVert_ = max f(x) - g(x)) compared to the interpolation approach.","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"","category":"page"},{"location":"generated/approximation/","page":"Function approximation","title":"Function approximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tensors/#banded-tensors-api","page":"Banded tensors","title":"Banded tensors","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"CurrentModule = BSplineKit.BandedTensors","category":"page"},{"location":"tensors/#Banded-tensors","page":"Banded tensors","title":"Banded tensors","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"BandedTensor3D\nbandshift\nbandwidth\nband_indices","category":"page"},{"location":"tensors/#BSplineKit.BandedTensors.BandedTensor3D","page":"Banded tensors","title":"BSplineKit.BandedTensors.BandedTensor3D","text":"BandedTensor3D{T,b}\n\nThree-dimensional banded tensor with element type T.\n\nExtended help\n\nBand structure\n\nThe band structure is assumed to be symmetric, and is defined in terms of the band width b. For a cubic banded tensor of dimensions N  N  N, the element A_ijk may be non-zero only if i - j  b, i - k  b and j - k  b.\n\nStorage\n\nThe data is stored as a Vector of small matrices, each with size r  r, where r = 2b + 1 is the total number of bands. Each submatrix holds the non-zero values of a slice of the form A[:, :, k].\n\nFor b = 2, one of these matrices looks like the following, where dots indicate out-of-bands values (equal to zero):\n\n| x  x  x  ⋅  ⋅ |\n| x  x  x  x  ⋅ |\n| x  x  x  x  x |\n| ⋅  x  x  x  x |\n| ⋅  ⋅  x  x  x |\n\nThese submatrices are stored as static matrices (SMatrix).\n\nSetting elements\n\nTo define the elements of the tensor, each slice A[:, :, k] must be set at once. For instance:\n\nA = BandedTensor3D(undef, 20, Val(2))  # tensor of size 20×20×20 and band width b = 2\nfor k in axes(A, 3)\n    A[:, :, k] = rand(5, 5)\nend\n\nSee setindex! for more details.\n\nNon-cubic tensors\n\nA slight departure from cubic tensors is currently supported, with dimensions of the form N  N  M. Moreover, bands may be shifted along the third dimension by an offset δ. In this case, the bands are given by i - j  b, i - (k + δ)  b and j - (k + δ)  b.\n\n\n\nBandedTensor3D{T}(undef, (Ni, Nj, Nk), Val(b); [bandshift = (0, 0, 0)])\nBandedTensor3D{T}(undef, N, Val(b); ...)\n\nConstruct 3D banded tensor with band widths b.\n\nRight now, the first two dimension sizes Ni and Nj of the tensor must be equal. In the second variant, the tensor dimensions are N × N × N.\n\nThe tensor is constructed uninitialised. Each submatrix A[:, :, k] of size (2b + 1, 2b + 1), for k ∈ 1:Nk, should be initialised as in the following example:\n\nA[:, :, k] = rand(2b + 1, 2b + 1)\n\nThe optional bandshift argument should be a tuple of the form (δi, δj, δk) describing a band shift. Right now, band shifts are limited to δi = δj = 0, so this argument should actually look like (0, 0, δk).\n\n\n\n\n\n","category":"type"},{"location":"tensors/#BSplineKit.BandedTensors.bandshift","page":"Banded tensors","title":"BSplineKit.BandedTensors.bandshift","text":"bandshift(A::BandedTensor3D) -> (δi, δj, δk)\n\nReturn tuple with band shifts along each dimension.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#BandedMatrices.bandwidth","page":"Banded tensors","title":"BandedMatrices.bandwidth","text":"bandwidth(A::BandedTensor3D)\n\nGet band width b of BandedTensor3D.\n\nThe band width is defined here such that the element A[i, j, k] may be non-zero only if i - j  b, i - k  b and j - k  b. This definition is consistent with the specification of the upper and lower band widths in BandedMatrices.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#BSplineKit.BandedTensors.band_indices","page":"Banded tensors","title":"BSplineKit.BandedTensors.band_indices","text":"band_indices(A::BandedTensor3D, k)\n\nReturn the range of indices a:b for subarray A[:, :, k] where values may be non-zero.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#Slices","page":"Banded tensors","title":"Slices","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"SubMatrix\nsetindex!","category":"page"},{"location":"tensors/#BSplineKit.BandedTensors.SubMatrix","page":"Banded tensors","title":"BSplineKit.BandedTensors.SubMatrix","text":"SubMatrix{T} <: AbstractMatrix{T}\n\nRepresents the submatrix A[:, :, k] of a BandedTensor3D A.\n\nWraps the SMatrix holding the submatrix.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#Base.setindex!","page":"Banded tensors","title":"Base.setindex!","text":"setindex!(A::BandedTensor3D, Ak::AbstractMatrix, :, :, k)\n\nSet submatrix A[:, :, k] to the matrix Ak.\n\nThe Ak matrix must have dimensions (r, r), where r = 2b + 1 is the total number of bands of A.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#Linear-algebra","page":"Banded tensors","title":"Linear algebra","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"dot(::AbstractVector, ::SubMatrix, ::AbstractVector)\nBandedTensors.muladd!","category":"page"},{"location":"tensors/#LinearAlgebra.dot-Tuple{AbstractVector, BSplineKit.BandedTensors.SubMatrix, AbstractVector}","page":"Banded tensors","title":"LinearAlgebra.dot","text":"dot(x, Asub::SubMatrix, y)\n\nEfficient implementation of the generalised dot product dot(x, Asub * y).\n\nTo be used with a submatrix Asub = A[:, :, k] of a BandedTensor3D A.\n\n\n\n\n\n","category":"method"},{"location":"tensors/#BSplineKit.BandedTensors.muladd!","page":"Banded tensors","title":"BSplineKit.BandedTensors.muladd!","text":"muladd!(Y::AbstractMatrix, A::BandedTensor3D, b::AbstractVector)\n\nPerform contraction Y[i, j] += ∑ₖ A[i, j, k] * b[k].\n\nNote that the result is added to previously existent values of Y.\n\nAs an (allocating) alternative, one can use Y = A * b, which returns Y as a BandedMatrix.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Splines-api","page":"Splines","title":"Splines","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"CurrentModule = BSplineKit.Splines","category":"page"},{"location":"splines/#Splines","page":"Splines","title":"Splines","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"Spline\nSpline1D\ncoefficients\neltype(::Spline)\nlength(::Spline)\nsize(::Spline)\nndims(::Spline)\nbases(::Spline)\nbasis(::Spline1D)","category":"page"},{"location":"splines/#BSplineKit.Splines.Spline","page":"Splines","title":"BSplineKit.Splines.Spline","text":"Spline{N, T}\n\nRepresents an N-dimensional spline function which returns values of type T.\n\nFor N  2, this is a tensor-product spline. That is, the spline space is given by the tensor product of N one-dimensional spline spaces.\n\n\n\nSpline(B::AbstractBSplineBasis, coefs::AbstractVector)\n\nConstruct a 1D spline from a B-spline basis and a vector of B-spline coefficients.\n\nThe spline can be then evaluated at any point x within the domain.\n\nExamples\n\n1D splines\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.2:1);\n\njulia> coefs = rand(length(B));\n\njulia> S = Spline(B, coefs)\n13-element Spline{1, Float64}:\n basis: 13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.173575, 0.321662, 0.258585, 0.166439, 0.527015, 0.483022, 0.390663, 0.802763, 0.721983, 0.372347, 0.0301856, 0.0793339, 0.663758]\n\njulia> S(0.42)  # evaluate spline\n0.6543543311366747\n\njulia> S′ = Derivative(1) * S  # spline derivative\n12-element Spline{1, Float64}:\n basis: 12-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0]\n coefficients: [2.22131, -0.473071, -0.460734, 1.80288, -0.219964, -0.461794, 2.0605, -0.403899, -1.74818, -1.71081, 0.368613, 8.76636]\n\njulia> Sint = integral(S)  # spline integral\n14-element Spline{1, Float64}:\n basis: 14-element BSplineBasis of order 5, domain [-1.0, 1.0]\n order: 5\n knots: [-1.0, -1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.0, 0.00867873, 0.0408449, 0.0796327, 0.11292, 0.218323, 0.314928, 0.393061, 0.553613, 0.69801, 0.772479, 0.777007, 0.78494, 0.818128]\n\nMultidimensional (tensor-product) splines\n\njulia> Bx = BSplineBasis(BSplineOrder(4), -1:0.2:1)\n13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n\njulia> By = BSplineBasis(BSplineOrder(6), 0:0.05:1)\n25-element BSplineBasis of order 6, domain [0.0, 1.0]\n knots: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05, 0.1, 0.15, 0.2  …  0.8, 0.85, 0.9, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n\njulia> coefs = rand(length(Bx), length(By));\n\njulia> S = Spline((Bx, By), coefs)\n13×25 Spline{2, Float64}:\n bases:\n   (1) 13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n   (2) 25-element BSplineBasis of order 6, domain [0.0, 1.0]\n knots:\n   (1) [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n   (2) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05, 0.1, 0.15, 0.2  …  0.8, 0.85, 0.9, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.173575 0.183429 … 0.00993008 0.320248; 0.321662 0.347508 … 0.251083 0.346025; … ; 0.433914 0.895838 … 0.483176 0.0793339; 0.211228 0.580212 … 0.425628 0.663758]\n\njulia> S(-0.32, 0.54)\n0.38520723534067336\n\n\n\nSpline(undef, B::AbstractBSplineBasis, [T = Float64])\nSpline(undef, (Bx, By, …), [T = Float64])\n\nConstruct a spline with uninitialised vector of coefficients.\n\nIn the second case, a tensor-product multidimensional spline is constructed.\n\nThe optional parameter T corresponds to the returned type when the spline is evaluated.\n\n\n\n\n\n","category":"type"},{"location":"splines/#BSplineKit.Splines.Spline1D","page":"Splines","title":"BSplineKit.Splines.Spline1D","text":"Spline1D\n\nAlias for Spline{1}, representing a one-dimensional spline.\n\n\n\n\n\n","category":"type"},{"location":"splines/#BSplineKit.Splines.coefficients","page":"Splines","title":"BSplineKit.Splines.coefficients","text":"coefficients(S::Spline{N,T}) -> AbstractArray{T,N}\n\nReturns the array of B-spline coefficients of the spline.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Base.eltype-Tuple{Spline}","page":"Splines","title":"Base.eltype","text":"eltype(::Type{<:Spline})\neltype(S::Spline)\n\nReturns type of element returned when evaluating the Spline.\n\n\n\n\n\n","category":"method"},{"location":"splines/#Base.length-Tuple{Spline}","page":"Splines","title":"Base.length","text":"length(S::Spline)\n\nReturns the number of coefficients in the spline.\n\nFor 1D splines, this is equal to the number of basis functions, length(first(bases(S))).\n\n\n\n\n\n","category":"method"},{"location":"splines/#Base.size-Tuple{Spline}","page":"Splines","title":"Base.size","text":"size(S::Spline)\n\nSame as size(coefficients(S)).\n\n\n\n\n\n","category":"method"},{"location":"splines/#Base.ndims-Tuple{Spline}","page":"Splines","title":"Base.ndims","text":"ndims(::Type{<:Spline})\nndims(S::Spline)\n\nReturns the dimensionality of the spline.\n\n\n\n\n\n","category":"method"},{"location":"splines/#BSplineKit.Splines.bases-Tuple{Spline}","page":"Splines","title":"BSplineKit.Splines.bases","text":"bases(S::Spline) -> (B₁, B₂, …)\n\nReturns the B-spline bases associated to the spline.\n\nThe number of bases is equal to the dimensionality of the spline. In particular, for 1D splines, this returns a one-element tuple.\n\nSee also basis(::Spline1D).\n\n\n\n\n\n","category":"method"},{"location":"splines/#BSplineKit.BSplines.basis-Tuple{Spline1D{T} where T}","page":"Splines","title":"BSplineKit.BSplines.basis","text":"basis(S::Spline1D)\n\nReturns the B-spline basis associated to the spline.\n\n\n\n\n\n","category":"method"},{"location":"splines/#Derivatives-and-integrals","page":"Splines","title":"Derivatives and integrals","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"*\ndiff\nintegral","category":"page"},{"location":"splines/#Base.:*","page":"Splines","title":"Base.:*","text":"*(op::Derivative, S::Spline1D) -> Spline1D\n\nReturns N-th derivative of spline S as a new spline.\n\nSee also diff.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.2:1);\n\njulia> S = Spline(B, rand(length(B)))\n13-element Spline{1, Float64}:\n basis: 13-element BSplineBasis of order 4, domain [-1.0, 1.0]\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.173575, 0.321662, 0.258585, 0.166439, 0.527015, 0.483022, 0.390663, 0.802763, 0.721983, 0.372347, 0.0301856, 0.0793339, 0.663758]\n\njulia> Derivative(0) * S === S\ntrue\n\njulia> Derivative(1) * S\n12-element Spline{1, Float64}:\n basis: 12-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0]\n coefficients: [2.22131, -0.473071, -0.460734, 1.80288, -0.219964, -0.461794, 2.0605, -0.403899, -1.74818, -1.71081, 0.368613, 8.76636]\n\njulia> Derivative(2) * S\n11-element Spline{1, Float64}:\n basis: 11-element BSplineBasis of order 2, domain [-1.0, 1.0]\n order: 2\n knots: [-1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0]\n coefficients: [-26.9438, 0.0616849, 11.3181, -10.1142, -1.20915, 12.6114, -12.322, -6.72141, 0.186876, 10.3971, 83.9775]\n\n\n\n\n\n","category":"function"},{"location":"splines/#Base.diff","page":"Splines","title":"Base.diff","text":"diff(S::Spline1D, [op::Derivative = Derivative(1)]) -> Spline1D\n\nSame as op * S.\n\nReturns N-th derivative of spline S as a new spline.\n\n\n\n\n\n","category":"function"},{"location":"splines/#BSplineKit.Splines.integral","page":"Splines","title":"BSplineKit.Splines.integral","text":"integral(S::Spline1D)\n\nReturns an antiderivative of the given spline as a new spline.\n\nThe algorithm is described in de Boor 2001, p. 127.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Spline-wrappers","page":"Splines","title":"Spline wrappers","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"SplineWrapper\nspline","category":"page"},{"location":"splines/#BSplineKit.Splines.SplineWrapper","page":"Splines","title":"BSplineKit.Splines.SplineWrapper","text":"SplineWrapper{S <: Spline}\n\nAbstract type representing a type that wraps a Spline.\n\nSuch a type implements all common operations on splines, including evaluation, differentiation, etc…\n\n\n\n\n\n","category":"type"},{"location":"splines/#BSplineKit.Splines.spline","page":"Splines","title":"BSplineKit.Splines.spline","text":"spline(w::SplineWrapper) -> Spline\n\nReturns the Spline wrapped by the object.\n\n\n\n\n\n","category":"function"},{"location":"approximation/#function-approximation-api","page":"Function approximation","title":"Function approximation","text":"","category":"section"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"CurrentModule = BSplineKit.SplineApproximations","category":"page"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"Function approximation using splines.","category":"page"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"SplineApproximations","category":"page"},{"location":"approximation/#BSplineKit.SplineApproximations","page":"Function approximation","title":"BSplineKit.SplineApproximations","text":"SplineApproximations\n\nModule for function approximation using splines.\n\nThe general idea is to find the spline g(x) in a given spline space that best approximates a known function f(x). In other words, given a predefined BSplineBasis, the objective is to find some appropriate B-spline coefficients such that the resulting spline appropriately approximates f. Different approximation approaches are implemented, trading accuracy and speed.\n\n\n\n\n\n","category":"module"},{"location":"approximation/#Functions","page":"Function approximation","title":"Functions","text":"","category":"section"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"approximate\napproximate!","category":"page"},{"location":"approximation/#BSplineKit.SplineApproximations.approximate","page":"Function approximation","title":"BSplineKit.SplineApproximations.approximate","text":"approximate(f, B::AbstractBSplineBasis, [method = ApproxByInterpolation(B)])\n\nApproximate function f in the given basis, using the chosen method.\n\nFrom lower to higher accuracy (and cost), the possible approximation methods are:\n\nVariationDiminishing,\nApproxByInterpolation,\nMinimiseL2Error.\n\nSee their respective documentations for details.\n\nNote that, once an approximation has been performed, it's possible to efficiently perform additional approximations (of other functions f) by calling the in-place interpolate!. This completely avoids allocations and strongly reduces computation time.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(3), -1:0.4:1);\n\n\njulia> S_interp = approximate(sin, B)\nSplineApproximation containing the 7-element Spline{1, Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [-0.841471, -0.731727, -0.39727, 2.85767e-17, 0.39727, 0.731727, 0.841471]\n approximation method: interpolation at [-1.0, -0.8, -0.4, 0.0, 0.4, 0.8, 1.0]\n\njulia> sin(0.3), S_interp(0.3)\n(0.29552020666133955, 0.2959895327282942)\n\njulia> approximate!(exp, S_interp)\nSplineApproximation containing the 7-element Spline{1, Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [0.367879, 0.440373, 0.65701, 0.980127, 1.46223, 2.18111, 2.71828]\n approximation method: interpolation at [-1.0, -0.8, -0.4, 0.0, 0.4, 0.8, 1.0]\n\njulia> exp(0.3), S_interp(0.3)\n(1.3498588075760032, 1.3491015490105396)\n\njulia> S_fast = approximate(exp, B, VariationDiminishing())\nSplineApproximation containing the 7-element Spline{1, Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [0.367879, 0.449329, 0.67032, 1.0, 1.49182, 2.22554, 2.71828]\n approximation method: VariationDiminishing()\n\njulia> S_opt = approximate(exp, B, MinimiseL2Error())\nSplineApproximation containing the 7-element Spline{1, Float64}:\n basis: 7-element BSplineBasis of order 3, domain [-1.0, 1.0]\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [0.368074, 0.440342, 0.657077, 0.980279, 1.46216, 2.18201, 2.71669]\n approximation method: MinimiseL2Error()\n\njulia> x = 0.34; exp(x), S_opt(x), S_interp(x), S_fast(x)\n(1.4049475905635938, 1.4044530324752076, 1.4044149581073813, 1.4328668494041878)\n\n\n\n\n\n","category":"function"},{"location":"approximation/#BSplineKit.SplineApproximations.approximate!","page":"Function approximation","title":"BSplineKit.SplineApproximations.approximate!","text":"approximate!(f, A::SplineApproximation)\n\nApproximate function f reusing a previous Spline approximation in a given basis.\n\nSee approximate for details.\n\n\n\n\n\n","category":"function"},{"location":"approximation/#Approximation-methods","page":"Function approximation","title":"Approximation methods","text":"","category":"section"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"SplineApproximations.AbstractApproxMethod\nVariationDiminishing\nApproxByInterpolation\nMinimiseL2Error","category":"page"},{"location":"approximation/#BSplineKit.SplineApproximations.AbstractApproxMethod","page":"Function approximation","title":"BSplineKit.SplineApproximations.AbstractApproxMethod","text":"AbstractApproxMethod\n\nAbstract type describing a type of approximation method.\n\n\n\n\n\n","category":"type"},{"location":"approximation/#BSplineKit.SplineApproximations.VariationDiminishing","page":"Function approximation","title":"BSplineKit.SplineApproximations.VariationDiminishing","text":"VariationDiminishing <: AbstractApproxMethod\n\nSchoenberg's variation diminishing spline approximation.\n\nApproximates a function f by setting the B-spline coefficients as c_i = f(x_i), where the locations x_i are chosen as the Greville sites:\n\nx_i = frac1k - 1 _j = 1^k - 1 t_i + j\n\nThis method is expected to preserve the shape of the function. However, it may be very inaccurate as an actual approximation of it.\n\nFor details, see e.g. de Boor 2001, chapter XI.\n\nwarning: Warning\nCurrently, this method is not guaranteed to work well with recombined B-spline bases (of type RecombinedBSplineBasis).\n\n\n\n\n\n","category":"type"},{"location":"approximation/#BSplineKit.SplineApproximations.ApproxByInterpolation","page":"Function approximation","title":"BSplineKit.SplineApproximations.ApproxByInterpolation","text":"ApproxByInterpolation <: AbstractApproxMethod\n\nApproximate function by a spline that passes through the given set of points.\n\nThe number of points must be equal to the length of the B-spline basis defining the approximation space.\n\nSee belows for different ways of specifying the interpolation points.\n\n\n\nApproxByInterpolation(xs::AbstractVector)\nApproxByInterpolation((xs, ys, …))\n\nSpecifies an approximation by interpolation at the given points xs.\n\nThe second variant is useful for approximation of multidimensional functions using tensor-product splines.\n\n\n\nApproxByInterpolation(B::AbstractBSplineBasis)\nApproxByInterpolation((Bx, By, …))\n\nSpecifies an approximation by interpolation at an automatically-determined set of points, which are expected to be appropriate for the given basis.\n\nThe second variant is useful for approximation of multidimensional functions using tensor-product splines.\n\nThe interpolation points are determined by calling collocation_points.\n\n\n\n\n\n","category":"type"},{"location":"approximation/#BSplineKit.SplineApproximations.MinimiseL2Error","page":"Function approximation","title":"BSplineKit.SplineApproximations.MinimiseL2Error","text":"MinimiseL2Error <: AbstractApproxMethod\n\nApproximate a given function f(x) by minimisation of the L^2 distance between f and its spline approximation g(x).\n\nExtended help\n\nMinimises the L^2 distance between the two functions:\n\nleftlVert f - g rightrVert^2 = left f - g f - g right\n\nwhere\n\nleft u v right = _a^b u(x)  v(x)  mathrmdx\n\nis the inner product between two functions, and a and b are the boundaries of the prescribed B-spline basis. Here, g is the spline g(x) = _i = 1^N c_i  b_i(x), and  b_i _i = 1^N is a prescribed B-spline basis.\n\nOne can show that the optimal coefficients c_i minimising the L^2 error are the solution to the linear system bmM bmc = bmφ, where M_ij = left b_i b_j right and φ_i = left b_i f right. These two terms are respectively computed by galerkin_matrix and galerkin_projection.\n\nThe integrals associated to bmM and bmφ are computed via Gauss–Legendre quadrature. The number of quadrature nodes is chosen as a function of the order k of the prescribed B-spline basis, ensuring that bmM is computed exactly (see also galerkin_matrix). In the particular case where f is a polynomial of degree k - 1, this also results in an exact computation of bmφ. In more general cases, as long as f is smooth enough, this is still expected to yield a very good approximation of the integral, and thus of the optimal coefficients c_i.\n\n\n\n\n\n","category":"type"},{"location":"#BSplineKit.jl","page":"Home","title":"BSplineKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for B-spline based Galerkin and collocation methods in Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides:","category":"page"},{"location":"","page":"Home","title":"Home","text":"B-spline bases of arbitrary order on uniform and non-uniform grids;\nevaluation of splines and their derivatives and integrals;\nspline interpolations and function approximation;\nbasis recombination, for generating bases satisfying homogeneous boundary conditions using linear combinations of B-splines. Supported boundary conditions include Dirichlet, Neumann, Robin, and generalisations of these;\nbanded Galerkin and collocation matrices for solving differential equations, using B-spline and recombined bases;\nefficient \"banded\" 3D arrays as an extension of banded matrices. These can store 3D tensors associated to quadratic terms in Galerkin methods.","category":"page"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following is a very brief overview of some of the functionality provided by this package. See the examples in the sidebar for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interpolate discrete data using cubic splines (B-spline order k = 4):\nxdata = (0:10).^2  # points don't need to be uniformly distributed\nydata = rand(length(xdata))\nitp = interpolate(xdata, ydata, BSplineOrder(4))\nitp(12.3)  # interpolation can be evaluated at any intermediate point\nCreate B-spline basis of order k = 6 (polynomial degree 5) from a given set of breakpoints:\nbreaks = log2.(1:16)  # breakpoints don't need to be uniformly distributed either\nB = BSplineBasis(BSplineOrder(6), breaks)\nApproximate known function by a spline in a previously constructed basis:\nf(x) = exp(-x) * sin(x)\nfapprox = approximate(f, B)\nf(2.3), fapprox(2.3)  # (0.07476354233090601, 0.0747642348243861)\nCreate derived basis satisfying homogeneous Robin boundary conditions on the two boundaries:\nbc = Derivative(0) + 3Derivative(1)\nR = RecombinedBSplineBasis(bc, B)  # satisfies u ∓ 3u' = 0 on the left/right boundary\nConstruct mass matrix and stiffness matrix for the Galerkin method in the recombined basis:\n# By default, M and L are Hermitian banded matrices\nM = galerkin_matrix(R)\nL = galerkin_matrix(R, (Derivative(1), Derivative(1)))\nConstruct banded 3D tensor associated to non-linear term of the Burgers equation:\nT = galerkin_tensor(R, (Derivative(0), Derivative(1), Derivative(0)))","category":"page"},{"location":"#Comparison-with-similar-packages","page":"Home","title":"Comparison with similar packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project presents several similarities with the excellent BSplines package. This includes various types and functions which have the same names (e.g. BSplineBasis, Spline, knots, order). In most cases this is pure coincidence, even though some inspiration was later taken from that package (for instance, the idea of a Derivative type).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some design differences with the BSplines package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"in BSplineKit, the B-spline order k is considered a compile-time constant, as it is encoded in the BSplineBasis type. This leads to important performance gains when evaluating splines. It also enables the construction of efficient 3D banded structures based on stack-allocated StaticArrays;\nwe do not assume that knots are repeated k times at the boundaries, even though this is still the default when creating a B-spline basis. This is to allow the possibility of imposing periodic boundary conditions on the basis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to the common functionality, BSplineKit provides easy to use tools for solving boundary-value problems using B-splines. This includes the generation of bases satisfying a chosen set of boundary conditions (basis recombination), as well as the construction of arrays for solving such problems using collocation and Galerkin methods.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"C. de Boor, A Practical Guide to Splines. New York: Springer-Verlag, 1978.\nJ. P. Boyd, Chebyshev and Fourier Spectral Methods, Second Edition. Mineola, N.Y: Dover Publications, 2001.\nO. Botella and K. Shariff, B-spline Methods in Fluid Dynamics, Int. J. Comput. Fluid Dyn. 17, 133 (2003).","category":"page"}]
}
