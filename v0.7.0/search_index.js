var documenterSearchIndex = {"docs":
[{"location":"collocation/#Collocation-arrays","page":"Collocation arrays","title":"Collocation arrays","text":"","category":"section"},{"location":"collocation/","page":"Collocation arrays","title":"Collocation arrays","text":"CurrentModule = BSplineKit.Collocation","category":"page"},{"location":"collocation/#Collocation-points","page":"Collocation arrays","title":"Collocation points","text":"","category":"section"},{"location":"collocation/","page":"Collocation arrays","title":"Collocation arrays","text":"collocation_points\ncollocation_points!","category":"page"},{"location":"collocation/#BSplineKit.Collocation.collocation_points","page":"Collocation arrays","title":"BSplineKit.Collocation.collocation_points","text":"collocation_points(B::AbstractBSplineBasis; method=Collocation.AvgKnots())\n\nDefine and return adapted collocation points for evaluation of splines.\n\nThe number of returned collocation points is equal to the number of functions in the basis.\n\nNote that if B is a RecombinedBSplineBasis (adapted for boundary value problems), collocation points are not included at the boundaries, since the boundary conditions are implicitly satisfied by the basis.\n\nIn principle, the choice of collocation points is not unique. The selection method can be chosen via the method argument. For now, only a single method is accepted:\n\nCollocation.AvgKnots()\n\nSee also collocation_points!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.collocation_points!","page":"Collocation arrays","title":"BSplineKit.Collocation.collocation_points!","text":"collocation_points!(x::AbstractVector, B::AbstractBSplineBasis;\n                    method::SelectionMethod=AvgKnots())\n\nFill vector with collocation points for evaluation of splines.\n\nSee collocation_points for details.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#Point-selection-methods","page":"Collocation arrays","title":"Point selection methods","text":"","category":"section"},{"location":"collocation/","page":"Collocation arrays","title":"Collocation arrays","text":"SelectionMethod\nAvgKnots","category":"page"},{"location":"collocation/#BSplineKit.Collocation.SelectionMethod","page":"Collocation arrays","title":"BSplineKit.Collocation.SelectionMethod","text":"SelectionMethod\n\nAbstract type defining a method for choosing collocation points from spline knots.\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.AvgKnots","page":"Collocation arrays","title":"BSplineKit.Collocation.AvgKnots","text":"AvgKnots <: SelectionMethod\n\nEach collocation point is chosen as a sliding average over k - 1 knots.\n\nThe resulting collocation points are sometimes called Greville sites (de Boor 2001) or Marsden–Schoenberg points (e.g. Botella & Shariff IJCFD 2003).\n\n\n\n\n\n","category":"type"},{"location":"collocation/#Matrices","page":"Collocation arrays","title":"Matrices","text":"","category":"section"},{"location":"collocation/","page":"Collocation arrays","title":"Collocation arrays","text":"CollocationMatrix\ncollocation_matrix\ncollocation_matrix!\nlu\nlu!","category":"page"},{"location":"collocation/#BSplineKit.Collocation.CollocationMatrix","page":"Collocation arrays","title":"BSplineKit.Collocation.CollocationMatrix","text":"CollocationMatrix{T} <: AbstractBandedMatrix{T}\n\nB-spline collocation matrix, defined by\n\nC_ij = b_j(x_i)\n\nwhere bmx is a set of collocation points.\n\nWraps a BandedMatrix, providing an efficient LU factorisation without pivoting adapted from de Boor (1978). The factorisation takes advantage of the total positivity of spline collocation matrices (de Boor 2001, p. 175).\n\nFactorisation\n\nCollocationMatrix supports in-place LU factorisation using lu!, as well as out-of-place factorisation using lu. LU decomposition may also be performed via factorize.\n\nwarning: Matrix shape\nFor now, LU factorisation is only supported for square collocation matrices.\n\n\n\n\n\n","category":"type"},{"location":"collocation/#BSplineKit.Collocation.collocation_matrix","page":"Collocation arrays","title":"BSplineKit.Collocation.collocation_matrix","text":"collocation_matrix(\n    B::AbstractBSplineBasis,\n    x::AbstractVector,\n    [deriv::Derivative = Derivative(0)],\n    [MatrixType = CollocationMatrix{Float64}];\n    clip_threshold = eps(eltype(MatrixType)),\n)\n\nReturn collocation matrix mapping B-spline coefficients to spline values at the collocation points x.\n\nExtended help\n\nThe matrix elements are given by the B-splines evaluated at the collocation points:\n\nC_ij = b_j(x_i) quad textfor quad\ni  1 N_x text and  j  1 N_b\n\nwhere Nx = length(x) is the number of collocation points, and Nb = length(B) is the number of B-splines in B.\n\nTo obtain a matrix associated to the B-spline derivatives, set the deriv argument to the order of the derivative.\n\nGiven the B-spline coefficients u_j 1  j  N_b, one can recover the values (or derivatives) of the spline at the collocation points as v = C * u. Conversely, if one knows the values v_i at the collocation points, the coefficients u of the spline passing by the collocation points may be obtained by inversion of the linear system u = C \\ v.\n\nThe clip_threshold argument allows one to ignore spurious, negligible values obtained when evaluating B-splines. These values are typically unwanted, as they artificially increase the number of elements (and sometimes the bandwidth) of the matrix. They may appear when a collocation point is located on a knot. By default, clip_threshold is set to the machine epsilon associated to the matrix element type (see eps in the Julia documentation). Set it to zero to disable this behaviour.\n\nMatrix types\n\nThe MatrixType optional argument allows to select the type of returned matrix.\n\nDue to the compact support of B-splines, the collocation matrix is banded if the collocation points are properly distributed. Therefore, it makes sense to store it in a BandedMatrix (from the BandedMatrices package), as this will lead to memory savings and especially to time savings if the matrix needs to be inverted.\n\nSupported matrix types\n\nCollocationMatrix{T}: thin wrapper over BandedMatrix{T}, with efficient LU factorisations without pivoting (see CollocationMatrix for details). This option performs much better than sparse matrices for inversion of linear systems. On the other hand, for matrix-vector or matrix-matrix multiplications, SparseMatrixCSC may perform better, especially when using OpenBLAS (see BandedMatrices issue). May fail with an error for non-square matrix shapes, or if the distribution of collocation points is not adapted. In these cases, the effective bandwidth of the matrix may be larger than the expected bandwidth.\nSparseMatrixCSC{T}: regular sparse matrix; correctly handles any matrix shape.\nMatrix{T}: a regular dense matrix. Generally performs worse than the alternatives, especially for large problems.\n\nSee also collocation_matrix!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#BSplineKit.Collocation.collocation_matrix!","page":"Collocation arrays","title":"BSplineKit.Collocation.collocation_matrix!","text":"collocation_matrix!(\n    C::AbstractMatrix{T}, B::AbstractBSplineBasis, x::AbstractVector,\n    [deriv::Derivative = Derivative(0)]; clip_threshold = eps(T))\n\nFill preallocated collocation matrix.\n\nSee collocation_matrix for details.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#LinearAlgebra.lu","page":"Collocation arrays","title":"LinearAlgebra.lu","text":"LinearAlgebra.lu(C::CollocationMatrix, pivot = Val(false); check = true)\n\nReturns LU factorisation of collocation matrix.\n\nSee also lu!.\n\n\n\n\n\n","category":"function"},{"location":"collocation/#LinearAlgebra.lu!","page":"Collocation arrays","title":"LinearAlgebra.lu!","text":"LinearAlgebra.lu!(C::CollocationMatrix, pivot = Val(false); check = true)\n\nPerform in-place LU factorisation of collocation matrix without pivoting.\n\nTakes advantage of the totally positive property of collocation matrices appearing in spline calculations (de Boor 1978).\n\nThe code is ported from Carl de Boor's BANFAC routine in FORTRAN77, via its FORTRAN90 version by John Burkardt.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#Galerkin-arrays","page":"Galerkin arrays","title":"Galerkin arrays","text":"","category":"section"},{"location":"galerkin/","page":"Galerkin arrays","title":"Galerkin arrays","text":"CurrentModule = BSplineKit","category":"page"},{"location":"galerkin/#Matrices","page":"Galerkin arrays","title":"Matrices","text":"","category":"section"},{"location":"galerkin/","page":"Galerkin arrays","title":"Galerkin arrays","text":"galerkin_matrix\ngalerkin_matrix!","category":"page"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_matrix","page":"Galerkin arrays","title":"BSplineKit.Galerkin.galerkin_matrix","text":"galerkin_matrix(\n    B::AbstractBSplineBasis,\n    [deriv = (Derivative(0), Derivative(0))],\n    [MatrixType = BandedMatrix{Float64}],\n)\n\nCompute Galerkin mass or stiffness matrix, as well as more general variants of these.\n\nExtended help\n\nThe Galerkin mass matrix is defined as\n\nM_ij =  ϕ_i ϕ_j  quad textfor quad\ni  1 N text and  j  1 N\n\nwhere ϕ_i(x) is the i-th basis function and N = length(B) is the number of functions in the basis B. Here, f g is the L^2 inner product between functions f and g.\n\nSince products of B-splines are themselves piecewise polynomials, integrals can be computed exactly using Gaussian quadrature rules. To do this, we use Gauss–Legendre quadratures via the FastGaussQuadrature package.\n\nMatrix layout and types\n\nThe mass matrix is banded with 2k - 1 bands. Moreover, the matrix is symmetric and positive definite, and only k bands are needed to fully describe the matrix. Hence, a Hermitian view of an underlying matrix is returned.\n\nBy default, the underlying matrix holding the data is a BandedMatrix that defines the upper part of the symmetric matrix. Other types of container are also supported, including regular sparse matrices (SparseMatrixCSC) and dense arrays (Matrix). See collocation_matrix for a discussion on matrix types.\n\nDerivatives of basis functions\n\nGalerkin matrices associated to the derivatives of basis functions may be constructed using the optional deriv parameter. For instance, if deriv = (Derivative(0), Derivative(2)), the matrix  ϕ_i ϕ_j  is constructed, where primes denote derivatives. Note that, if the derivative orders are different, the resulting matrix is not symmetric, and a Hermitian view is not returned in those cases.\n\nCombining different bases\n\nMore generally, it is possible to compute matrices of the form  ψ_i^(n) ϕ_j^(m) , where n and m are derivative orders, and ψ_i and ϕ_j belong to two different (but related) bases B₁ and B₂. For this, instead of the B parameter, one must pass a tuple of bases (B₁, B₂). The restriction is that the bases must have the same parent B-spline basis. That is, they must share the same set of B-spline knots and be of equal polynomial order.\n\nNote that, if both bases are different, the matrix will not be symmetric, and will not even be square if the bases have different lengths.\n\nIn practice, this feature may be used to combine a B-spline basis B, with a recombined basis R generated from B (see Basis recombination).\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_matrix!","page":"Galerkin arrays","title":"BSplineKit.Galerkin.galerkin_matrix!","text":"galerkin_matrix!(A::AbstractMatrix, B::AbstractBSplineBasis,\n                 deriv = (Derivative(0), Derivative(0)))\n\nFill preallocated Galerkin matrix.\n\nThe matrix may be a Hermitian view, in which case only one half of the matrix will be filled. Note that, for the matrix to be symmetric, both derivative orders in deriv must be the same.\n\nMore generally, it is possible to combine different functional bases by passing a tuple of AbstractBSplineBasis as B.\n\nSee galerkin_matrix for details.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#Banded-3D-tensors","page":"Galerkin arrays","title":"Banded 3D tensors","text":"","category":"section"},{"location":"galerkin/","page":"Galerkin arrays","title":"Galerkin arrays","text":"galerkin_tensor\ngalerkin_tensor!","category":"page"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_tensor","page":"Galerkin arrays","title":"BSplineKit.Galerkin.galerkin_tensor","text":"galerkin_tensor(\n    B::AbstractBSplineBasis,\n    (D₁::Derivative, D₂::Derivative, D₃::Derivative),\n    [T = Float64],\n)\n\nCompute 3D banded tensor appearing from quadratic terms in Galerkin method.\n\nAs with galerkin_matrix, it is also possible to combine different functional bases by passing, instead of B, a tuple (B₁, B₂, B₃) of three AbstractBSplineBasis. For now, the first two bases, B₁ and B₂, must have the same length.\n\nThe tensor is efficiently stored in a BandedTensor3D object.\n\n\n\n\n\n","category":"function"},{"location":"galerkin/#BSplineKit.Galerkin.galerkin_tensor!","page":"Galerkin arrays","title":"BSplineKit.Galerkin.galerkin_tensor!","text":"galerkin_tensor!(\n    A::BandedTensor3D,\n    B::AbstractBSplineBasis,\n    (D₁::Derivative, D₂::Derivative, D₃::Derivative),\n)\n\nCompute 3D Galerkin tensor in-place.\n\nSee galerkin_tensor for details.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Splines","page":"Splines","title":"Splines","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"CurrentModule = BSplineKit.Splines","category":"page"},{"location":"splines/#Splines-2","page":"Splines","title":"Splines","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"Spline\ncoefficients\neltype(::Spline)\nlength(::Spline)\nbasis(::Spline)","category":"page"},{"location":"splines/#BSplineKit.Splines.Spline","page":"Splines","title":"BSplineKit.Splines.Spline","text":"Spline{T}\n\nRepresents a spline function.\n\n\n\nSpline(B::AbstractBSplineBasis, coefs::AbstractVector)\n\nConstruct a spline from a B-spline basis and a vector of B-spline coefficients.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.2:1);\n\njulia> coefs = rand(length(B));\n\njulia> S = Spline(B, coefs)\n13-element Spline{Float64}:\n order: 4\n knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]\n coefficients: [0.18588655648969699, 0.9029166384444702, 0.9260613807703459, 0.8547964724816131, 0.39474318453198, 0.7014911606231877, 0.7532136707230797, 0.9360833341053749, 0.23429394964461725, 0.8755953969471848, 0.8421116493609568, 0.6943510993657007, 0.3825519047441852]\n\n\n\nSpline(undef, B::AbstractBSplineBasis, [T=Float64])\n\nConstruct a spline with uninitialised vector of coefficients.\n\n\n\n(S::Spline)(x)\n\nEvaluate spline at coordinate x.\n\n\n\n\n\n","category":"type"},{"location":"splines/#BSplineKit.Splines.coefficients","page":"Splines","title":"BSplineKit.Splines.coefficients","text":"coefficients(S::Spline)\n\nGet B-spline coefficients of the spline.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Base.eltype-Tuple{Spline}","page":"Splines","title":"Base.eltype","text":"eltype(S::Spline)\n\nReturns type of element returned when evaluating the Spline.\n\n\n\n\n\n","category":"method"},{"location":"splines/#Base.length-Tuple{Spline}","page":"Splines","title":"Base.length","text":"length(S::Spline)\n\nReturns the number of coefficients in the spline.\n\nNote that this is equal to the number of basis functions, length(basis(S)).\n\n\n\n\n\n","category":"method"},{"location":"splines/#BSplineKit.BSplines.basis-Tuple{Spline}","page":"Splines","title":"BSplineKit.BSplines.basis","text":"basis(S::Spline) -> AbstractBSplineBasis\n\nReturns the associated B-spline basis.\n\n\n\n\n\n","category":"method"},{"location":"splines/#Derivatives-and-integrals","page":"Splines","title":"Derivatives and integrals","text":"","category":"section"},{"location":"splines/","page":"Splines","title":"Splines","text":"diff\nintegral","category":"page"},{"location":"splines/#Base.diff","page":"Splines","title":"Base.diff","text":"diff(S::Spline, [deriv::Derivative = Derivative(1)]) -> Spline\n\nReturn N-th derivative of spline S as a new spline.\n\n\n\n\n\n","category":"function"},{"location":"splines/#BSplineKit.Splines.integral","page":"Splines","title":"BSplineKit.Splines.integral","text":"integral(S::Spline)\n\nReturns an antiderivative of the given spline as a new spline.\n\nThe algorithm is described in de Boor 2001, p. 127.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#Banded-tensors","page":"Banded tensors","title":"Banded tensors","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"CurrentModule = BSplineKit.BandedTensors","category":"page"},{"location":"tensors/#Banded-tensors-2","page":"Banded tensors","title":"Banded tensors","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"BandedTensor3D\nbandshift\nbandwidth\nband_indices","category":"page"},{"location":"tensors/#BSplineKit.BandedTensors.BandedTensor3D","page":"Banded tensors","title":"BSplineKit.BandedTensors.BandedTensor3D","text":"BandedTensor3D{T,b}\n\nThree-dimensional banded tensor with element type T.\n\nExtended help\n\nBand structure\n\nThe band structure is assumed to be symmetric, and is defined in terms of the band width b. For a cubic banded tensor of dimensions N  N  N, the element A_ijk may be non-zero only if i - j  b, i - k  b and j - k  b.\n\nStorage\n\nThe data is stored as a Vector of small matrices, each with size r  r, where r = 2b + 1 is the total number of bands. Each submatrix holds the non-zero values of a slice of the form A[:, :, k].\n\nFor b = 2, one of these matrices looks like the following, where dots indicate out-of-bands values (equal to zero):\n\n| x  x  x  ⋅  ⋅ |\n| x  x  x  x  ⋅ |\n| x  x  x  x  x |\n| ⋅  x  x  x  x |\n| ⋅  ⋅  x  x  x |\n\nThese submatrices are stored as static matrices (SMatrix).\n\nSetting elements\n\nTo define the elements of the tensor, each slice A[:, :, k] must be set at once. For instance:\n\nA = BandedTensor3D(undef, 20, Val(2))  # tensor of size 20×20×20 and band width b = 2\nfor k in axes(A, 3)\n    A[:, :, k] = rand(5, 5)\nend\n\nSee setindex! for more details.\n\nNon-cubic tensors\n\nA slight departure from cubic tensors is currently supported, with dimensions of the form N  N  M. Moreover, bands may be shifted along the third dimension by an offset δ. In this case, the bands are given by i - j  b, i - (k + δ)  b and j - (k + δ)  b.\n\n\n\nBandedTensor3D{T}(undef, (Ni, Nj, Nk), Val(b); [bandshift = (0, 0, 0)])\nBandedTensor3D{T}(undef, N, Val(b); ...)\n\nConstruct 3D banded tensor with band widths b.\n\nRight now, the first two dimension sizes Ni and Nj of the tensor must be equal. In the second variant, the tensor dimensions are N × N × N.\n\nThe tensor is constructed uninitialised. Each submatrix A[:, :, k] of size (2b + 1, 2b + 1), for k ∈ 1:Nk, should be initialised as in the following example:\n\nA[:, :, k] = rand(2b + 1, 2b + 1)\n\nThe optional bandshift argument should be a tuple of the form (δi, δj, δk) describing a band shift. Right now, band shifts are limited to δi = δj = 0, so this argument should actually look like (0, 0, δk).\n\n\n\n\n\n","category":"type"},{"location":"tensors/#BSplineKit.BandedTensors.bandshift","page":"Banded tensors","title":"BSplineKit.BandedTensors.bandshift","text":"bandshift(A::BandedTensor3D) -> (δi, δj, δk)\n\nReturn tuple with band shifts along each dimension.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#BandedMatrices.bandwidth","page":"Banded tensors","title":"BandedMatrices.bandwidth","text":"bandwidth(A::BandedTensor3D)\n\nGet band width b of BandedTensor3D.\n\nThe band width is defined here such that the element A[i, j, k] may be non-zero only if i - j  b, i - k  b and j - k  b. This definition is consistent with the specification of the upper and lower band widths in BandedMatrices.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#BSplineKit.BandedTensors.band_indices","page":"Banded tensors","title":"BSplineKit.BandedTensors.band_indices","text":"band_indices(A::BandedTensor3D, k)\n\nReturn the range of indices a:b for subarray A[:, :, k] where values may be non-zero.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#Slices","page":"Banded tensors","title":"Slices","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"SubMatrix\nsetindex!","category":"page"},{"location":"tensors/#BSplineKit.BandedTensors.SubMatrix","page":"Banded tensors","title":"BSplineKit.BandedTensors.SubMatrix","text":"SubMatrix{T} <: AbstractMatrix{T}\n\nRepresents the submatrix A[:, :, k] of a BandedTensor3D A.\n\nWraps the SMatrix holding the submatrix.\n\n\n\n\n\n","category":"type"},{"location":"tensors/#Base.setindex!","page":"Banded tensors","title":"Base.setindex!","text":"setindex!(A::BandedTensor3D, Ak::AbstractMatrix, :, :, k)\n\nSet submatrix A[:, :, k] to the matrix Ak.\n\nThe Ak matrix must have dimensions (r, r), where r = 2b + 1 is the total number of bands of A.\n\n\n\n\n\n","category":"function"},{"location":"tensors/#Linear-algebra","page":"Banded tensors","title":"Linear algebra","text":"","category":"section"},{"location":"tensors/","page":"Banded tensors","title":"Banded tensors","text":"dot(::AbstractVector, ::SubMatrix, ::AbstractVector)\nBandedTensors.muladd!","category":"page"},{"location":"tensors/#LinearAlgebra.dot-Tuple{AbstractVector{T} where T, BSplineKit.BandedTensors.SubMatrix, AbstractVector{T} where T}","page":"Banded tensors","title":"LinearAlgebra.dot","text":"dot(x, Asub::SubMatrix, y)\n\nEfficient implementation of the generalised dot product dot(x, Asub * y).\n\nTo be used with a submatrix Asub = A[:, :, k] of a BandedTensor3D A.\n\n\n\n\n\n","category":"method"},{"location":"tensors/#BSplineKit.BandedTensors.muladd!","page":"Banded tensors","title":"BSplineKit.BandedTensors.muladd!","text":"muladd!(Y::AbstractMatrix, A::BandedTensor3D, b::AbstractVector)\n\nPerform contraction Y[i, j] += ∑ₖ A[i, j, k] * b[k].\n\nNote that the result is added to previously existent values of Y.\n\nAs an (allocating) alternative, one can use Y = A * b, which returns Y as a BandedMatrix.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#Basis-recombination","page":"Basis recombination","title":"Basis recombination","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"CurrentModule = BSplineKit.Recombinations","category":"page"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"Recombinations","category":"page"},{"location":"recombination/#BSplineKit.Recombinations","page":"Basis recombination","title":"BSplineKit.Recombinations","text":"Recombinations\n\nBasis recombination module.\n\nDefines RecombinedBSplineBasis and RecombineMatrix types.\n\n\n\n\n\n","category":"module"},{"location":"recombination/#Recombined-bases","page":"Basis recombination","title":"Recombined bases","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"RecombinedBSplineBasis\nparent(::RecombinedBSplineBasis)\nlength(::RecombinedBSplineBasis)\nconstraints\nnum_constraints\nnum_recombined\nrecombination_matrix","category":"page"},{"location":"recombination/#BSplineKit.Recombinations.RecombinedBSplineBasis","page":"Basis recombination","title":"BSplineKit.Recombinations.RecombinedBSplineBasis","text":"RecombinedBSplineBasis{k, T}\n\nFunctional basis defined from the recombination of a BSplineBasis in order to satisfy certain homogeneous boundary conditions (BCs).\n\nExtended help\n\nThe basis recombination technique is a common way of applying BCs in Galerkin methods. It is described for instance in Boyd 2000 (ch. 6), in the context of a Chebyshev basis. In this approach, the original basis, b_i(x) 1  i  N, is \"recombined\" into a new basis, ϕ_j(x) 1  j  M, so that each basis function ϕ_j individually satisfies the chosen BCs.\n\nThe length M of the recombined basis is always smaller than the length N of the original basis. The difference, δ = N - M, is equal to the number of boundary conditions. In the simplest (and most common) case, a single BC is applied on each boundary, leading to δ = 2. More generally, as described further below, it is possible to simultaneously impose different BCs, which further decreases the number of degrees of freedom (increasing δ).\n\nThanks to the local support of B-splines, basis recombination involves only a little portion of the original B-spline basis. For instance, since there is only one B-spline that is non-zero at each boundary, removing that function from the basis is enough to apply homogeneous Dirichlet BCs. Imposing BCs for derivatives is slightly more complex, but still possible.\n\nNote that, when combining basis recombination with collocation methods, there must be no collocation points at the boundaries, or the resulting collocation matrices may not be invertible.\n\nOrder of the boundary condition\n\nIn this section, we consider the simplest case where a single homogeneous boundary condition, mathrmd^n u  mathrmdx^n = 0, is to be satisfied by the basis.\n\nThe recombined basis requires the specification of a Derivative object determining the order of the homogeneous BCs to be applied at the two boundaries. Linear combinations of Derivatives are also supported. The order of the B-spline needs to be k  n + 1, since a B-spline of order k is a C^k - 1-continuous function (except on the knots where it is C^k - 1 - p, with p the knot multiplicity).\n\nSome usual choices are:\n\nDerivative(0) sets homogeneous Dirichlet BCs (u = 0 at the boundaries) by removing the first and last B-splines, i.e. ϕ_1 = b_2;\nDerivative(1) sets homogeneous Neumann BCs (u = 0 at the boundaries) by adding the two first (and two last) B-splines, i.e. ϕ_1 = b_1 + b_2.\nmore generally, α Derivative(0) + β Derivative(1) sets homogeneous Robin BCs by defining ϕ_1 as a linear combination of b_1 and b_2. Here it's important to note that Derivative(1) denotes the normal derivative at the boundary, fracun, which is equal to -fracux on the left boundary.\n\nHigher order BCs are also possible. For instance, Derivative(2) recombines the first three B-splines into two basis functions that satisfy ϕ_1 = ϕ_2 = 0 at the left boundary, while ensuring that lower and higher-order derivatives keep degrees of freedom at the boundary. Note that simply adding the first three B-splines, as in ϕ_1 = b_1 + b_2 + b_3, makes the first derivative vanish as well as the second one, which is unwanted.\n\nFor Derivative(2), the chosen solution is to set ϕ_i = α_i b_i + β_i b_i + 1 for i  1 2. The α_i and β_i coefficients are chosen such that ϕ_i = 0 at the boundary. Moreover, they satisfy the (somewhat arbitrary) constraint α_i + β_i = 2 for each i, for consistency with the Neumann case described above. This generalises to higher order BCs. Note that, since each boundary function ϕ_i is defined from only two neighbouring B-splines, its local support stays minimal, hence preserving the small bandwidth of the resulting matrices.\n\nFinally, note that in the current implementation, it is not possible to impose different boundary conditions on both boundaries.\n\nMultiple boundary conditions\n\nAs an option, the recombined basis may simultaneously satisfy homogeneous BCs of different orders. In this case, a tuple of Derivatives must be passed.\n\nFor more details on the supported combinations of BCs, see the different RecombinedBSplineBasis constructors documented further below.\n\n\n\nRecombinedBSplineBasis(op::AbstractDifferentialOp, B::BSplineBasis)\n\nConstruct RecombinedBSplineBasis from B-spline basis B, satisfying homogeneous boundary conditions associated to the given differential operator.\n\nFor instance, op = Derivative(0) and op = Derivative(1) correspond to homogeneous Dirichlet and Neumann BCs, respectively.\n\nLinear combinations of differential operators are also supported. For instance, op = Derivative(0) + λ Derivative(1) corresponds to homogeneous Robin BCs.\n\nHigher-order derivatives are also allowed, being only limited by the order of the B-spline basis.\n\n\n\nRecombinedBSplineBasis(ops::Tuple{Vararg{AbstractDifferentialOp}},\n                       B::BSplineBasis)\n\nConstruct RecombinedBSplineBasis simultaneously satisfying homogeneous BCs associated to multiple differential operators.\n\nCurrently, the following specific combinations of differential operators are supported:\n\nall derivatives up to order m:\n ops = (Derivative(0), ..., Derivative(m))\nThis boundary condition is obtained by removing the first m + 1 B-splines from the original basis.\nFor instance, if (Derivative(0), Derivative(1)) is passed, then the basis simultaneously satisfies homogeneous Dirichlet and Neumann BCs at the two boundaries. The resulting basis is ϕ_1 = b_3 ϕ_2 = b_4  ϕ_N - 4 = b_N - 2.\nan extension of the above, with an additional differential operator of order n at the end:\n ops = (Derivative(0), ..., Derivative(m), D(n))\nThe operator D(n) may be a Derivative, or a linear combination of derivatives. The only restriction is that its maximum degree must satisfy n ≥ m + 1.\nOne example is the combination of homogeneous Dirichlet BCs, u = 0 on the boundaries, with Robin BCs for the derivative, u + λ u = 0, which corresponds to ops = (Derivative(0), Derivative(1) + λ Derivative(2)).\n\nIn all cases, the degrees of the differential operators must be in increasing order. For instance, ops = (Derivative(1), Derivative(0)) fails with an error.\n\n\n\n\n\n","category":"type"},{"location":"recombination/#Base.parent-Tuple{RecombinedBSplineBasis}","page":"Basis recombination","title":"Base.parent","text":"parent(R::RecombinedBSplineBasis)\n\nGet original B-spline basis.\n\n\n\n\n\n","category":"method"},{"location":"recombination/#Base.length-Tuple{RecombinedBSplineBasis}","page":"Basis recombination","title":"Base.length","text":"length(R::RecombinedBSplineBasis)\n\nReturns the number of functions in the recombined basis.\n\n\n\n\n\n","category":"method"},{"location":"recombination/#BSplineKit.Recombinations.constraints","page":"Basis recombination","title":"BSplineKit.Recombinations.constraints","text":"constraints(R::AbstractBSplineBasis) -> (left, right)\nconstraints(A::RecombineMatrix) -> (left, right)\n\nReturn the constraints (homogeneous boundary conditions) that the basis satisfies on each boundary.\n\nConstraints are returned as a tuple (left, right) indicating the BCs that are satisfied on each boundary. Each element is a tuple of differential operators specifying the BCs.\n\nFor example, if both Dirichlet and Neumann BCs are satisfied on the left boundary, then left = (Derivative(0), Derivative(1)).\n\nFor non-recombined bases such as BSplineBasis, this returns a tuple of empty tuples: ((), ()), since no BCs are satisfied on either boundary.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.num_constraints","page":"Basis recombination","title":"BSplineKit.Recombinations.num_constraints","text":"num_constraints(R::AbstractBSplineBasis) -> (Int, Int)\nnum_constraints(A::RecombineMatrix) -> (Int, Int)\n\nReturns the number of constraints (number of BCs to satisfy) on each boundary.\n\nFor instance, if R simultaneously satisfies Dirichlet and Neumann boundary conditions on each boundary, this returns (2, 2).\n\nNote that for non-recombined bases such as BSplineBasis, the number of constraints is zero, and this returns (0, 0).\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.num_recombined","page":"Basis recombination","title":"BSplineKit.Recombinations.num_recombined","text":"num_recombined(R::AbstractBSplineBasis) -> (Int, Int)\nnum_recombined(A::RecombineMatrix) -> (Int, Int)\n\nReturns the number of recombined functions in the recombined basis for each boundary.\n\nFor instance, if R satisfies Neumann boundary conditions on both boundaries, then only the first and last basis functions are different from the original B-spline basis, e.g. ϕ_1 = b_1 + b_2, and this returns (1, 1).\n\nFor non-recombined bases such as BSplineBasis, this returns zero.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#BSplineKit.Recombinations.recombination_matrix","page":"Basis recombination","title":"BSplineKit.Recombinations.recombination_matrix","text":"recombination_matrix(R::AbstractBSplineBasis)\n\nGet RecombineMatrix associated to the recombined basis.\n\nFor non-recombined bases such as BSplineBasis, this returns the identity matrix (LinearAlgebra.I).\n\n\n\n\n\n","category":"function"},{"location":"recombination/#Recombination-matrix","page":"Basis recombination","title":"Recombination matrix","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"RecombineMatrix\nnzrows","category":"page"},{"location":"recombination/#BSplineKit.Recombinations.RecombineMatrix","page":"Basis recombination","title":"BSplineKit.Recombinations.RecombineMatrix","text":"RecombineMatrix{T} <: AbstractMatrix{T}\n\nMatrix for transformation from coefficients of the recombined basis, to the corresponding B-spline basis coefficients.\n\nExtended help\n\nThe transformation matrix M is defined by\n\nϕ_j = M_ij b_i\n\nwhere b_j(x) and ϕ_i(x) are elements of the B-spline and recombined bases, respectively.\n\nThis matrix allows to pass from known coefficients u_j in the recombined basis ϕ_j, to the respective coefficients v_i in the B-spline basis b_i:\n\nbmv = mathbfM bmu\n\nNote that the matrix is not square: it has dimensions N  M, where N is the length of the B-spline basis, and M = N - δ is that of the recombined basis (see RecombinedBSplineBasis for details).\n\nDue to the local support of B-splines, basis recombination can be performed by combining just a small set of B-splines near the boundaries (as discussed in RecombinedBSplineBasis). This leads to a recombination matrix which is almost a diagonal of ones, plus a few extra super- and sub-diagonal elements in the upper left and lower right corners, respectively. The matrix is stored in a memory-efficient way that also allows fast access to its elements.\n\nEfficient implementations of matrix-vector products (using the * operator or LinearAlgebra.mul!) and of left division of vectors (using \\ or LinearAlgebra.ldiv!) are included. These two operations can be used to transform between coefficients in the original and recombined bases.\n\nNote that, since the recombined basis forms a subspace of the original basis (which is related to the rectangular shape of the matrix), it is generally not possible to obtain recombined coefficients from original coefficients, unless the latter already satisfy the constraints encoded in the recombined basis. The left division operation will throw a NoUniqueSolutionError if that is not the case.\n\n\n\nRecombineMatrix(ops::Tuple{Vararg{AbstractDifferentialOp}},\n                B::BSplineBasis, [T])\n\nConstruct recombination matrix describing a B-spline basis recombination.\n\nThe default element type T is generally Float64, except for specific differential operators which yield a matrix of zeroes and ones, for which Bool is the default.\n\nSee the RecombinedBSplineBasis constructor for details on the ops argument.\n\n\n\n\n\n","category":"type"},{"location":"recombination/#BSplineKit.Recombinations.nzrows","page":"Basis recombination","title":"BSplineKit.Recombinations.nzrows","text":"nzrows(A::RecombineMatrix, col::Integer) -> UnitRange{Int}\n\nReturns the range of row indices i such that A[i, col] is non-zero.\n\n\n\n\n\n","category":"function"},{"location":"recombination/#Internals","page":"Basis recombination","title":"Internals","text":"","category":"section"},{"location":"recombination/","page":"Basis recombination","title":"Basis recombination","text":"NoUniqueSolutionError\nparent_coefficients","category":"page"},{"location":"recombination/#BSplineKit.Recombinations.NoUniqueSolutionError","page":"Basis recombination","title":"BSplineKit.Recombinations.NoUniqueSolutionError","text":"NoUniqueSolutionError <: Exception\n\nException thrown when solving linear system using RecombineMatrix, when the system has no unique solution.\n\n\n\n\n\n","category":"type"},{"location":"recombination/#BSplineKit.Recombinations.parent_coefficients","page":"Basis recombination","title":"BSplineKit.Recombinations.parent_coefficients","text":"parent_coefficients(R::RecombinedBSplineBasis, coefs::AbstractVector)\n\nReturns the coefficients associated to the parent B-spline basis, from the coefficients coefs in the recombined basis.\n\nNote that this function doesn't allocate, since it returns a lazy concatenation (via LazyArrays.jl) of two StaticArrays and a view of the coefs vector.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = BSplineKit.SplineInterpolations","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"High-level interpolation of gridded data and function approximation using B-splines.","category":"page"},{"location":"interpolation/#Functions","page":"Interpolation","title":"Functions","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"interpolate\ninterpolate!\napproximate\napproximate!\nspline","category":"page"},{"location":"interpolation/#Interpolations.interpolate","page":"Interpolation","title":"Interpolations.interpolate","text":"interpolate(x, y, BSplineOrder(k))\n\nInterpolate values y at locations x using B-splines of order k.\n\nGrid points x must be real-valued and are assumed to be in increasing order.\n\nReturns a SplineInterpolation which can be evaluated at any intermediate point.\n\nSee also interpolate!.\n\nExamples\n\njulia> xs = -1:0.1:1;\n\njulia> ys = cospi.(xs);\n\njulia> itp = interpolate(xs, ys, BSplineOrder(4));\n\njulia> itp(-1)\n-1.0\n\njulia> itp(0)\n1.0\n\njulia> itp(0.42)\n0.2486897676885842\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#Interpolations.interpolate!","page":"Interpolation","title":"Interpolations.interpolate!","text":"interpolate!(I::SplineInterpolation, y::AbstractVector)\n\nUpdate spline interpolation with new data.\n\nThis function allows to reuse a SplineInterpolation returned by a previous call to interpolate, using new data on the same locations x.\n\nSee interpolate for details.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#BSplineKit.SplineInterpolations.approximate","page":"Interpolation","title":"BSplineKit.SplineInterpolations.approximate","text":"approximate(f, B::AbstractBSplineBasis, [x = collocation_points(B)]) -> SplineInterpolation\n\nApproximate function f in the given basis.\n\nThe approximation is performed by interpolation of a discrete set of evaluated values y_i = f(x_i), where the data points x_i may be given as input.\n\nThe returned SplineInterpolation approximates the given function.\n\nExample\n\njulia> B = BSplineBasis(BSplineOrder(3), -1:0.4:1);\n\njulia> S = approximate(sin, B)\nSplineInterpolation containing the 7-element Spline{Float64}:\n order: 3\n knots: [-1.0, -1.0, -1.0, -0.6, -0.2, 0.2, 0.6, 1.0, 1.0, 1.0]\n coefficients: [-0.8414709848078965, -0.7317273726556252, -0.39726989430226317, 0.0, 0.39726989430226317, 0.7317273726556252, 0.8414709848078965]\n interpolation points: [-1.0, -0.8, -0.4, 0.0, 0.4, 0.8, 1.0]\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#BSplineKit.SplineInterpolations.approximate!","page":"Interpolation","title":"BSplineKit.SplineInterpolations.approximate!","text":"approximate!(f, S::SplineInterpolation)\n\nApproximate function f in the basis associated to the SplineInterpolation S.\n\nSee also approximate.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#BSplineKit.SplineInterpolations.spline","page":"Interpolation","title":"BSplineKit.SplineInterpolations.spline","text":"spline(I::SplineInterpolation) -> Spline\n\nReturns the Spline associated to the interpolation.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#Types","page":"Interpolation","title":"Types","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"SplineInterpolation","category":"page"},{"location":"interpolation/#BSplineKit.SplineInterpolations.SplineInterpolation","page":"Interpolation","title":"BSplineKit.SplineInterpolations.SplineInterpolation","text":"SplineInterpolation\n\nSpline interpolation.\n\nThis is the type returned by interpolate.\n\nA SplineInterpolation I can be evaluated at any point x using the I(x) syntax.\n\nIt can also be updated with new data on the same data points using interpolate!.\n\n\n\nSplineInterpolation(undef, B::AbstractBSplineBasis, x::AbstractVector, [T = eltype(x)])\n\nInitialise a SplineInterpolation from B-spline basis and a set of interpolation (or collocation) points x.\n\nNote that the length of x must be equal to the number of B-splines.\n\nUse interpolate! to actually interpolate data known on the x locations.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#B-splines","page":"B-splines","title":"B-splines","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"CurrentModule = BSplineKit.BSplines","category":"page"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"BSplines","category":"page"},{"location":"bsplines/#BSplineKit.BSplines","page":"B-splines","title":"BSplineKit.BSplines","text":"BSplines\n\nModule defining B-spline bases and B-spline related functions.\n\n\n\n\n\n","category":"module"},{"location":"bsplines/#B-spline-bases","page":"B-splines","title":"B-spline bases","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"AbstractBSplineBasis\nBSplineBasis\nboundaries\norder\nknots\ngetindex\nlength(::BSplineBasis)","category":"page"},{"location":"bsplines/#BSplineKit.BSplines.AbstractBSplineBasis","page":"B-splines","title":"BSplineKit.BSplines.AbstractBSplineBasis","text":"AbstractBSplineBasis{k,T}\n\nAbstract type defining a B-spline basis, or more generally, a functional basis defined from B-splines.\n\nThe basis is represented by a B-spline order k and a knot element type T.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.BSplineBasis","page":"B-splines","title":"BSplineKit.BSplines.BSplineBasis","text":"BSplineBasis{k}\n\nB-spline basis for splines of order k.\n\nThe basis is defined by a set of knots and by the B-spline order.\n\n\n\nBSplineBasis(k, breakpoints::AbstractVector; augment = Val(true))\n\nCreate B-spline basis of order k with the given breakpoints.\n\nIf augment = Val(true), breakpoints will be \"augmented\" so that boundary knots have multiplicity k. Note that, if they are passed as a regular Vector, the input may be modified. See augment_knots! for details.\n\nExamples\n\njulia> breaks = range(-1, 1, length = 21)\n-1.0:0.1:1.0\n\njulia> B = BSplineBasis(5, breaks)\n24-element BSplineBasis: order 5, domain [-1.0, 1.0]\n\nThis is equivalent to the above:\n\njulia> B = BSplineBasis(BSplineOrder(5), breaks)\n24-element BSplineBasis: order 5, domain [-1.0, 1.0]\n\nNote that first and last knots have multiplicity k = 5:\n\njulia> show(knots(B))\n[-1.0, -1.0, -1.0, -1.0, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0, 1.0, 1.0]\n\nIf augment = Val(false), input breakpoints are taken without modification as the knots t_i of the B-spline basis. Note that the valid domain is reduced to -06 06. The domain is always defined as the range t_k t_N + 1, where N is the length of the basis (below, N = 16).\n\njulia> Bn = BSplineBasis(5, breaks, augment = Val(false))\n16-element BSplineBasis: order 5, domain [-0.6, 0.6]\n\njulia> show(knots(Bn))\n-1.0:0.1:1.0\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.boundaries","page":"B-splines","title":"BSplineKit.BSplines.boundaries","text":"boundaries(B::AbstractBSplineBasis)\n\nReturns (xmin, xmax) tuple with the boundaries of the domain supported by the basis.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.order","page":"B-splines","title":"BSplineKit.BSplines.order","text":"order(::Type{BSplineBasis}) -> Int\norder(::Type{Spline}) -> Int\norder(::BSplineOrder) -> Int\n\nReturns order of B-splines as an integer.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.knots","page":"B-splines","title":"BSplineKit.BSplines.knots","text":"knots(g::BSplineBasis)\nknots(g::Spline)\n\nReturns the knots of the B-spline basis.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Base.getindex","page":"B-splines","title":"Base.getindex","text":"getindex(B::AbstractBSplineBasis, i, [T = Float64])\n\nGet i-th basis function.\n\nThis is an alias for BasisFunction(B, i, T) (see BasisFunction for details).\n\nThe returned object can be evaluated at any point within the boundaries defined by the basis.\n\nExamples\n\njulia> B = BSplineBasis(BSplineOrder(4), -1:0.1:1)\n23-element BSplineBasis: order 4, domain [-1.0, 1.0]\n\njulia> B[6]\nBasis function i = 6\n  from 23-element BSplineBasis: order 4, domain [-1.0, 1.0]\n  support: [-0.8, -0.4) (knots 6:10)\n\njulia> B[6](-0.5)\n0.16666666666666666\n\njulia> B[6, Float32](-0.5)\n0.16666667f0\n\njulia> B[6](-0.5, Derivative(1))\n-5.000000000000001\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Base.length-Tuple{BSplineBasis}","page":"B-splines","title":"Base.length","text":"length(g::BSplineBasis)\n\nReturns the number of B-splines composing a spline.\n\n\n\n\n\n","category":"method"},{"location":"bsplines/#Basis-functions","page":"B-splines","title":"Basis functions","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"BasisFunction\nsupport\ncommon_support\nevaluate\nevaluate!\nnonzero_in_segment","category":"page"},{"location":"bsplines/#BSplineKit.BSplines.BasisFunction","page":"B-splines","title":"BSplineKit.BSplines.BasisFunction","text":"BasisFunction{B <: AbstractBSplineBasis, T}\n\nDescribes a single basis function.\n\nThe basis function may belong to a BSplineBasis (in which case it's effectively a B-spline), or to a basis derived from a B-spline basis (such as a RecombinedBSplineBasis).\n\n\n\nBasisFunction(basis::AbstractBSplineBasis, i::Int, [T = Float64])\n\nConstruct i-th basis function of the given basis.\n\nThe constructed function can be evaluated as b(x), returning a value of type T.\n\n\n\n(b::BasisFunction)(x, [op::AbstractDifferentialOp])\n\nEvaluate basis function at coordinate x.\n\nTo evaluate a derivative, pass Derivative(n) as the op argument, with n the derivative order.\n\nMore general differential operators, such as Derivative(n) + λ Derivative(m), are also supported.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.support","page":"B-splines","title":"BSplineKit.BSplines.support","text":"support(b::BasisFunction) -> UnitRange{Int}\n\nGet range of knots supported by the basis function.\n\nReturns the knot range i:j such that the basis function support is t  t_i t_j).\n\n\n\n\n\nsupport(B::AbstractBSplineBasis, i::Integer) -> UnitRange{Int}\n\nGet range of knots supported by the i-th basis function.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.common_support","page":"B-splines","title":"BSplineKit.BSplines.common_support","text":"common_support(b1::BasisFunction, b2::BasisFunction, ...) -> UnitRange{Int}\n\nGet range of knots commonly supported by different basis functions.\n\nIf the supports don't intersect, an empty range is returned (e.g. 6:5), following the behaviour of intersect. The lack of intersection can be checked using isempty, which returns true for such a range.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate","page":"B-splines","title":"BSplineKit.BSplines.evaluate","text":"evaluate(B::AbstractBSplineBasis, i::Integer, x,\n         [op::AbstractDifferentialOp], [T=Float64])\n\nEvaluate i-th basis function in the given basis at x (can be a coordinate or a vector of coordinates).\n\nTo evaluate a derivative, pass Derivative(n) as the op argument, with n the derivative order.\n\nMore general differential operators, such as Derivative(n) + λ Derivative(m), are also supported.\n\nSee also evaluate!.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.evaluate!","page":"B-splines","title":"BSplineKit.BSplines.evaluate!","text":"evaluate!(b::AbstractVector, B::BSplineBasis, i::Integer,\n          x::AbstractVector, args...)\n\nEvaluate i-th basis function at positions x and write result to b.\n\nSee also evaluate.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.nonzero_in_segment","page":"B-splines","title":"BSplineKit.BSplines.nonzero_in_segment","text":"nonzero_in_segment(B::AbstractBSplineBasis, n::Int) -> UnitRange{Int}\n\nReturns the range of basis functions that are non-zero in a given knot segment.\n\nThe n-th knot segment is defined by Ω_n = t_n t_n + 1.\n\nFor BSplineBasis and RecombinedBSplineBasis, the number of non-zero functions in any given segment is generally equal to the B-spline order k. This number decreases near the borders, but this is not significant when B-spline knots have multiplicity k there (as is the default).\n\nFor B-spline bases, and excepting the borders, the non-zero B-splines are left b_i right_i = n - k + 1^n. This function thus returns (n - k + 1):N when B is a BSplineBasis.\n\nSee also support for the inverse operation.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#Internals","page":"B-splines","title":"Internals","text":"","category":"section"},{"location":"bsplines/","page":"B-splines","title":"B-splines","text":"BSplineOrder\nAugmentedKnots\naugment_knots!\nmultiplicity","category":"page"},{"location":"bsplines/#BSplineKit.BSplines.BSplineOrder","page":"B-splines","title":"BSplineKit.BSplines.BSplineOrder","text":"BSplineOrder(k::Integer)\n\nSpecifies the B-spline order k.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.AugmentedKnots","page":"B-splines","title":"BSplineKit.BSplines.AugmentedKnots","text":"AugmentedKnots{T,k} <: AbstractVector{T}\n\nPads from both sides a vector of B-spline breakpoints, making sure that the first and last values are repeated k times.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/#BSplineKit.BSplines.augment_knots!","page":"B-splines","title":"BSplineKit.BSplines.augment_knots!","text":"augment_knots!(breaks::AbstractVector, k::Union{Integer,BSplineOrder})\n\nModifies the input breakpoints to make sure that the first and last knot have multiplicity k for splines of order k.\n\nTo prevent allocations, this function will modify the input when this is a standard Vector. Otherwise, the input will be wrapped inside an AugmentedKnots object.\n\nIt is assumed that the input breakpoints have multiplicity 1 at the borders. That is, border coordinates should not be repeated in the input.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/#BSplineKit.BSplines.multiplicity","page":"B-splines","title":"BSplineKit.BSplines.multiplicity","text":"multiplicity(knots, i)\n\nDetermine multiplicity of knot knots[i].\n\n\n\n\n\n","category":"function"},{"location":"diffops/#Differential-operators","page":"Differential operators","title":"Differential operators","text":"","category":"section"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"CurrentModule = BSplineKit.DifferentialOps","category":"page"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"DifferentialOps","category":"page"},{"location":"diffops/#BSplineKit.DifferentialOps","page":"Differential operators","title":"BSplineKit.DifferentialOps","text":"DifferentialOps\n\nModule defining types describing differential operators and compositions thereof.\n\n\n\n\n\n","category":"module"},{"location":"diffops/#Operators","page":"Differential operators","title":"Operators","text":"","category":"section"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"AbstractDifferentialOp\nDerivative\nScaledDerivative\nDifferentialOpSum\nmax_order","category":"page"},{"location":"diffops/#BSplineKit.DifferentialOps.AbstractDifferentialOp","page":"Differential operators","title":"BSplineKit.DifferentialOps.AbstractDifferentialOp","text":"AbstractDifferentialOp\n\nRepresents a general differential operator.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.Derivative","page":"Differential operators","title":"BSplineKit.DifferentialOps.Derivative","text":"Derivative{n} <: AbstractDifferentialOp\n\nSpecifies the n-th derivative of a function.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.ScaledDerivative","page":"Differential operators","title":"BSplineKit.DifferentialOps.ScaledDerivative","text":"ScaledDerivative{n} <: AbstractDifferentialOp\n\nn-th derivative of a function scaled by a constant coefficient.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.DifferentialOpSum","page":"Differential operators","title":"BSplineKit.DifferentialOps.DifferentialOpSum","text":"DifferentialOpSum <: AbstractDifferentialOp\n\nSum of two differential operators.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.max_order","page":"Differential operators","title":"BSplineKit.DifferentialOps.max_order","text":"max_order(op::AbstractDifferentialOp)\nmax_order(ops...)\n\nGet maximum derivative order of one or more differential operators.\n\n\n\n\n\n","category":"function"},{"location":"diffops/#Projections","page":"Differential operators","title":"Projections","text":"","category":"section"},{"location":"diffops/","page":"Differential operators","title":"Differential operators","text":"AbstractNormalDirection\nLeftNormal\nRightNormal\ndot(::AbstractDifferentialOp, ::AbstractNormalDirection)","category":"page"},{"location":"diffops/#BSplineKit.DifferentialOps.AbstractNormalDirection","page":"Differential operators","title":"BSplineKit.DifferentialOps.AbstractNormalDirection","text":"AbstractNormalDirection\n\nRepresents the normal direction on a given domain boundary.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.LeftNormal","page":"Differential operators","title":"BSplineKit.DifferentialOps.LeftNormal","text":"LeftNormal <: AbstractNormalDirection\n\nSpecifies the normal direction on the left boundary of a 1D domain.\n\nThe left normal direction goes opposite to the coordinate axis.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#BSplineKit.DifferentialOps.RightNormal","page":"Differential operators","title":"BSplineKit.DifferentialOps.RightNormal","text":"RightNormal <: AbstractNormalDirection\n\nSpecifies the normal direction on the right boundary of a 1D domain.\n\nThe right normal direction is equal to that of the coordinate axis.\n\n\n\n\n\n","category":"type"},{"location":"diffops/#LinearAlgebra.dot-Tuple{BSplineKit.DifferentialOps.AbstractDifferentialOp, BSplineKit.DifferentialOps.AbstractNormalDirection}","page":"Differential operators","title":"LinearAlgebra.dot","text":"dot(op::AbstractDifferentialOp, dir::AbstractNormalDirection) -> AbstractDifferentialOp\n\nProject derivative along a normal direction.\n\nThis should be used to convert from a normal derivative at the boundaries, to a derivative along the coordinate axes of the domain.\n\nIn practice, this returns op for RightNormal. For LeftNormal, it multiplies the odd-order derivatives by -1.\n\n\n\n\n\n","category":"method"},{"location":"#BSplineKit.jl","page":"Home","title":"BSplineKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for B-spline based Galerkin and collocation methods in Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides:","category":"page"},{"location":"","page":"Home","title":"Home","text":"B-spline bases of arbitrary order on uniform and non-uniform grids;\nevaluation of splines and their derivatives and integrals;\nspline interpolations;\nbasis recombination, for generating bases satisfying homogeneous boundary conditions using linear combinations of B-splines. Supported boundary conditions include Dirichlet, Neumann, Robin, and more complex variants;\nbanded Galerkin and collocation matrices for solving differential equations, using B-spline and recombined bases;\nefficient \"banded\" 3D arrays as an extension of banded matrices. These can store 3D tensors associated to quadratic terms in Galerkin methods.","category":"page"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following is a very brief overview of some of the functionality provided by this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create B-spline basis of order k = 4 (polynomial degree 3) from a given set of breakpoints:\nbreaks = -1:0.1:1\nB = BSplineBasis(4, breaks)\nCreate derived basis satisfying the homogeneous Robin boundary conditions u + 3 fracun = 0 on the two boundaries:\nbc = Derivative(0) + 3Derivative(1)\nR = RecombinedBSplineBasis(bc, B)  # satisfies u ∓ 3u' = 0 on the left/right boundary\nConstruct mass matrix and stiffness matrix for the Galerkin method in the recombined basis:\n# By default, M and L are Hermitian banded matrices\nM = galerkin_matrix(R)\nL = galerkin_matrix(R, (Derivative(1), Derivative(1)))\nConstruct banded 3D tensor associated to non-linear term of the Burgers equation:\nT = galerkin_tensor(R, (Derivative(0), Derivative(1), Derivative(0)))","category":"page"},{"location":"","page":"Home","title":"Home","text":"A tutorial showcasing this and much more functionality is coming in the future.","category":"page"},{"location":"#Comparison-with-similar-packages","page":"Home","title":"Comparison with similar packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project presents several similarities with the excellent BSplines package. This includes various types and functions which have the same names (e.g. BSplineBasis, Spline, knots, order). In most cases this is pure coincidence, as I wasn't aware of BSplines when development of BSplineKit started. Some inspiration was later taken from that package (including, for instance, the idea of a Derivative type).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some design differences with the BSplines package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"in BSplineKit, the B-spline order k is considered a compile-time constant, as it is encoded in the BSplineBasis type. This leads to important performance gains when evaluating splines. It also enables the construction of efficient 3D banded structures based on stack-allocated StaticArrays;\nwe do not assume that knots are repeated k times at the boundaries, even though this is still the default when creating a B-spline basis. This is to allow the possibility of imposing periodic boundary conditions on the basis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to the common functionality, BSplineKit provides easy to use tools for solving boundary-value problems using B-splines. This includes the generation of bases satisfying a chosen set of boundary conditions (basis recombination), as well as the construction of arrays for solving such problems using collocation and Galerkin methods.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"C. de Boor, A Practical Guide to Splines. New York: Springer-Verlag, 1978.\nJ. P. Boyd, Chebyshev and Fourier Spectral Methods, Second Edition. Mineola, N.Y: Dover Publications, 2001.\nO. Botella and K. Shariff, B-spline Methods in Fluid Dynamics, Int. J. Comput. Fluid Dyn. 17, 133 (2003).","category":"page"}]
}
