<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heat equation · BSplineKit.jl</title><meta name="title" content="Heat equation · BSplineKit.jl"/><meta property="og:title" content="Heat equation · BSplineKit.jl"/><meta property="twitter:title" content="Heat equation · BSplineKit.jl"/><meta name="description" content="Documentation for BSplineKit.jl."/><meta property="og:description" content="Documentation for BSplineKit.jl."/><meta property="twitter:description" content="Documentation for BSplineKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/tomate.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BSplineKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../interpolation/">Spline interpolations</a></li><li><a class="tocitem" href="../approximation/">Function approximation</a></li><li class="is-active"><a class="tocitem" href>Heat equation</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-B-spline-basis"><span>Defining a B-spline basis</span></a></li><li><a class="tocitem" href="#Imposing-boundary-conditions"><span>Imposing boundary conditions</span></a></li><li><a class="tocitem" href="#Initial-condition"><span>Initial condition</span></a></li><li><a class="tocitem" href="#Solving-the-heat-equation"><span>Solving the heat equation</span></a></li><li><a class="tocitem" href="#Collocation-method"><span>Collocation method</span></a></li><li><a class="tocitem" href="#Galerkin-method"><span>Galerkin method</span></a></li><li><a class="tocitem" href="#Result-comparison"><span>Result comparison</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../bsplines/">B-splines</a></li><li><a class="tocitem" href="../../splines/">Splines</a></li><li><a class="tocitem" href="../../interpolation/">Data interpolation</a></li><li><a class="tocitem" href="../../extrapolation/">Extrapolation</a></li><li><a class="tocitem" href="../../approximation/">Function approximation</a></li><li><a class="tocitem" href="../../recombination/">Basis recombination</a></li><li><a class="tocitem" href="../../tensors/">Banded tensors</a></li><li><a class="tocitem" href="../../galerkin/">Galerkin tools</a></li><li><a class="tocitem" href="../../collocation/">Collocation tools</a></li><li><a class="tocitem" href="../../boundary_conditions/">Boundary conditions</a></li><li><input class="collapse-toggle" id="menuitem-3-11" type="checkbox"/><label class="tocitem" for="menuitem-3-11"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../diffops/">Differential operators</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Heat equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heat equation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/BSplineKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/BSplineKit.jl/blob/master/examples/heat.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Heat-equation"><a class="docs-heading-anchor" href="#Heat-equation">Heat equation</a><a id="Heat-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Heat-equation" title="Permalink"></a></h1><p>In this example, we numerically solve the 1D <a href="https://en.wikipedia.org/wiki/Heat_equation">heat equation</a></p><p class="math-container">\[\frac{∂θ}{∂t} = ν \frac{∂^2 θ}{∂x^2},\]</p><p>in a bounded domain <span>$x ∈ [-1, 1]$</span> with homogeneous Neumann boundary conditions, <span>$∂_x θ(±1, t) = 0$</span>.</p><h2 id="Defining-a-B-spline-basis"><a class="docs-heading-anchor" href="#Defining-a-B-spline-basis">Defining a B-spline basis</a><a id="Defining-a-B-spline-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-B-spline-basis" title="Permalink"></a></h2><p>The general idea is to approximate the unknown solution by a spline of order <span>$k$</span>. For this, we first define a B-spline basis <span>$\{ b_i(x), \, i = 1, …, N \}$</span>, such that the solution at a given time <span>$t$</span> is approximated by</p><p class="math-container">\[θ(x, t) = ∑_{i = 1}^N v_i(t) b_i(x),\]</p><p>where the <span>$v_i$</span> are the B-spline coefficients.</p><p>A B-spline basis is uniquely defined by its order <span>$k$</span> and by a choice of <em>knot</em> locations within the spatial domain, which form the spatial grid.</p><p>For this example, we take a uniform repartition of knots in <span>$[-1, 1]$</span>.</p><pre><code class="language-julia hljs">knots_in = range(-1, 1; length = 11)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-1.0:0.2:1.0</code></pre><p>We then create a B-spline basis of order <span>$k = 4$</span> using these knots.</p><pre><code class="language-julia hljs">using BSplineKit
B = BSplineBasis(BSplineOrder(4), knots_in)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13-element BSplineBasis of order 4, domain [-1.0, 1.0]
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]</code></pre><p>Note that the generated basis includes an <em>augmented</em> set of knots, in which each boundary is repeated <span>$k$</span> times:</p><pre><code class="language-julia hljs">knots(B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">17-element BSplineKit.BSplines.AugmentedKnots{Float64, 4, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}:
 -1.0
 -1.0
 -1.0
 -1.0
 -0.8
 -0.6
 -0.4
 -0.2
  0.0
  0.2
  0.4
  0.6
  0.8
  1.0
  1.0
  1.0
  1.0</code></pre><p>In other words, the boundary knots have multiplicity <span>$k$</span>, while interior knots have multiplicity 1. This is common practice in bounded domains, and translates the fact that the solution does not need to be continuous at the boundaries. This provides additional degrees of freedom notably for the boundary conditions. This behaviour can be disabled via the <code>augment</code> argument of <a href="../../bsplines/#BSplineKit.BSplines.BSplineBasis"><code>BSplineBasis</code></a>.</p><p>We can now plot the knot locations (crosses) and the generated B-spline basis:</p><pre><code class="language-julia hljs">using CairoMakie
using LaTeXStrings
CairoMakie.activate!(type = &quot;svg&quot;, pt_per_unit = 2.0)

function plot_knots!(ax, ts; knot_offset = 0.05, kws...)
    ys = zero(ts)
    # Add offset to distinguish knots with multiplicity &gt; 1
    for i in eachindex(ts)[(begin + 1):end]
        if ts[i] == ts[i - 1]
            ys[i] = ys[i - 1] + knot_offset
        end
    end
    scatter!(ax, ts, ys; marker = &#39;×&#39;, markersize = 24, color = :gray, kws...)
    ax
end

function plot_basis!(ax, B; eval_args = (), kws...)
    cmap = cgrad(:tab20)
    N = length(B)
    ts = knots(B)
    hlines!(ax, 0; color = :gray)
    for (n, bi) in enumerate(B)
        color = cmap[(n - 1) / (N - 1)]
        i, j = extrema(support(bi))
        lines!(ax, ts[i]..ts[j], x -&gt; bi(x, eval_args...); color, linewidth = 2.5)
    end
    plot_knots!(ax, ts; kws...)
    ax
end

fig = Figure()
ax = Axis(
    fig[1, 1];
    xlabel = rich(&quot;x&quot;; font = :italic),
    ylabel = rich(&quot;b&quot;, subscript(&quot;i&quot;), rich(&quot;(x)&quot;; offset = (0.1, 0.0)); font = :italic),
)
plot_basis!(ax, B)
fig</code></pre><img src="a9ef1b65.svg" alt="Example block output"/><h2 id="Imposing-boundary-conditions"><a class="docs-heading-anchor" href="#Imposing-boundary-conditions">Imposing boundary conditions</a><a id="Imposing-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Imposing-boundary-conditions" title="Permalink"></a></h2><p>In BSplineKit, the recommended approach for solving boundary value problems is to use the <strong>basis recombination</strong> method. That is, to expand the solution onto a new basis consisting on linear combinations of B-splines <span>$b_i(x)$</span>, such that each recombined basis function <span>$ϕ_j(x)$</span> individually satisfies the required homogeneous boundary conditions (BCs). Thanks to the local support of B-splines, basis recombination only involves a small number of B-splines near the boundaries.</p><p>Using the <a href="../../recombination/#BSplineKit.Recombinations.RecombinedBSplineBasis"><code>RecombinedBSplineBasis</code></a> type, we can easily define such recombined bases for many different BCs. In this example we generate a basis satisfying homogeneous Neumann BCs:</p><pre><code class="language-julia hljs">R = RecombinedBSplineBasis(B, Derivative(1))

fig = Figure()
ax = Axis(
    fig[1, 1];
    xlabel = rich(&quot;x&quot;; font = :italic),
    ylabel = rich(&quot;ϕ&quot;, subscript(&quot;i&quot;), rich(&quot;(x)&quot;; offset = (0.1, 0.0)); font = :italic),
)
plot_basis!(ax, R)
fig</code></pre><img src="1871e2d6.svg" alt="Example block output"/><p>We notice that, on each of the two boundaries, the two initial (or final) B-splines of the original basis have been combined to produce a single basis function that has zero derivative at each respective boundary. To verify this, we can plot the basis function derivatives:</p><pre><code class="language-julia hljs">fig = Figure()
ax = Axis(
    fig[1, 1];
    xlabel = rich(&quot;x&quot;; font = :italic),
    ylabel = rich(&quot;ϕ′&quot;, subscript(&quot;i&quot;; offset = (-0.3, 0.0)), rich(&quot;(x)&quot;; offset = (0.1, 0.0)); font = :italic),
)
plot_basis!(ax, R; eval_args = (Derivative(1), ), knot_offset = 0.4)
fig</code></pre><img src="812869ab.svg" alt="Example block output"/><p>Note that the new basis has two less functions than the original one, reflecting a loss of two degrees of freedom corresponding to the new constraints on each boundary:</p><pre><code class="language-julia hljs">length(B), length(R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(13, 11)</code></pre><h3 id="Recombination-matrix"><a class="docs-heading-anchor" href="#Recombination-matrix">Recombination matrix</a><a id="Recombination-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Recombination-matrix" title="Permalink"></a></h3><p>As stated above, the basis recombination approach consists in performing linear combinations of B-splines <span>$b_i$</span> to obtain a derived basis of functions <span>$ϕ_j$</span> satisfying certain boundary conditions. This can be conveniently expressed using a transformation matrix <span>$\mathbf{T}$</span> relating the two bases:</p><p class="math-container">\[ϕ_j(x) = ∑_{i = 1}^N T_{ij} b_i(x)
\quad \text{for } j = 1, 2, …, M,\]</p><p>where <span>$N$</span> is the number of B-splines <span>$b_i$</span>, and <span>$M &lt; N$</span> is the number of <span>$ϕ_j$</span> functions (in this example, <span>$M = N - 2$</span>).</p><p>The recombination matrix associated to the generated basis can be obtained using <a href="../../recombination/#BSplineKit.Recombinations.recombination_matrix"><code>recombination_matrix</code></a>:</p><pre><code class="language-julia hljs">T = recombination_matrix(R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13×11 RecombineMatrix{Bool, Pair{Tuple{Derivative{1}}, StaticArraysCore.SMatrix{2, 1, Bool, 2}}, Pair{Tuple{Derivative{1}}, StaticArraysCore.SMatrix{2, 1, Bool, 2}}}:
 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅
 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1
 ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1</code></pre><p>Note that the matrix is almost an identity matrix, since most B-splines are kept intact in the new basis. This simple structure allows for very efficient computations using this matrix. The first and last columns indicate that Neumann BCs are imposed by adding the two first (and two last) B-splines, i.e.</p><p class="math-container">\[ϕ_1(x) = b_1(x) + b_2(x),
\qquad
ϕ_M(x) = b_{N - 1}(x) + b_N(x).\]</p><h3 id="Representation-of-the-solution"><a class="docs-heading-anchor" href="#Representation-of-the-solution">Representation of the solution</a><a id="Representation-of-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Representation-of-the-solution" title="Permalink"></a></h3><p>Note that the solution <span>$θ(x, t)$</span> can be represented in the original and in the recombined B-spline bases as</p><p class="math-container">\[θ(x, t) = ∑_{i = 1}^N v_i(t) b_i(x) = ∑_{j = 1}^M u_j(t) ϕ_j(x),\]</p><p>where the <span>$u_j$</span> are the coefficients in the recombined basis.</p><p>The recombination matrix introduced above can be used to transform between the coefficients <span>$u_j$</span> and <span>$v_i$</span> in both bases, via the linear relation <span>$\bm{v} = \mathbf{T} \bm{u}$</span>.</p><h2 id="Initial-condition"><a class="docs-heading-anchor" href="#Initial-condition">Initial condition</a><a id="Initial-condition-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-condition" title="Permalink"></a></h2><p>We come back now to our problem. We want to impose the following initial condition:</p><p class="math-container">\[θ(x, 0) = θ_0(x) = 1 + \cos(π x).\]</p><p>First, we approximate this initial condition in the recombined B-spline basis that we have just constructed. This may be easily done using <a href="../../approximation/#BSplineKit.SplineApproximations.approximate"><code>approximate</code></a>:</p><pre><code class="language-julia hljs">θ₀(x) = 1 + cos(π * x)
θ₀_spline = approximate(θ₀, R, MinimiseL2Error())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SplineApproximation containing the 11-element Spline{Float64}:
 basis: 11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0], BCs {left =&gt; (D{1},), right =&gt; (D{1},)}
 order: 4
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]
 coefficients: [-0.000237504, 0.135773, 0.669895, 1.33011, 1.86423, 2.06824, 1.86423, 1.33011, 0.669895, 0.135773, -0.000237504]
 approximation method: MinimiseL2Error()</code></pre><p>To see that everything went well, we can plot the exact initial condition and its spline approximation, which show no important differences.</p><pre><code class="language-julia hljs">fig = Figure(size = (800, 400))
let ax = Axis(fig[1, 1]; xlabel = rich(&quot;x&quot;; font = :italic), ylabel = rich(&quot;θ&quot;; font = :italic))
    lines!(ax, -1..1, θ₀; label = rich(&quot;θ&quot;, subscript(&quot;0&quot;), rich(&quot;(x)&quot;; offset = (0.1, 0.0)); font = :italic), color = :blue)
    lines!(ax, -1..1, θ₀_spline; label = &quot;Approximation&quot;, color = :orange, linestyle = :dash)
    axislegend(ax; position = :cb)
end
let ax = Axis(fig[1, 2]; xlabel = rich(&quot;x&quot;; font = :italic), ylabel = &quot;Difference&quot;)
    lines!(ax, -1..1, x -&gt; θ₀(x) - θ₀_spline(x))
    plot_knots!(ax, knots(R); knot_offset = 0)
end
fig</code></pre><img src="bcd05374.svg" alt="Example block output"/><p>Note that we have access to the recombined B-spline coefficients <span>$u_j$</span> associated to the initial condition, which we will use further below:</p><pre><code class="language-julia hljs">u_init = coefficients(θ₀_spline)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11-element Vector{Float64}:
 -0.0002375040182477487
  0.135773324850954
  0.6698947840773792
  1.3301052159226208
  1.8642266751490477
  2.068242918452847
  1.8642266751490457
  1.3301052159226219
  0.6698947840773782
  0.13577332485095484
 -0.00023750401824791596</code></pre><h2 id="Solving-the-heat-equation"><a class="docs-heading-anchor" href="#Solving-the-heat-equation">Solving the heat equation</a><a id="Solving-the-heat-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-heat-equation" title="Permalink"></a></h2><p>To solve the governing equation, the strategy is to project the unknown solution onto the chosen recombined basis. That is, we approximate the solution as</p><p class="math-container">\[θ(x, t) = \sum_{j = 1}^M u_j(t) \, ϕ_j(x).\]</p><p>Plugging this representation into the heat equation, we find</p><p class="math-container">\[\newcommand{\dd}{\mathrm{d}}
∑_j \frac{\dd u_j}{\dd t} \, ϕ_j(x) = ν ∑_j u_j \, ϕ_j&#39;&#39;(x),\]</p><p>where primes denote spatial derivatives.</p><p>We can now use the <a href="https://en.wikipedia.org/wiki/Method_of_mean_weighted_residuals">method of mean weighted residuals</a> to find the coefficients <span>$u_j$</span>, by projecting the above equation onto a chosen set of <em>test</em> functions <span>$φ_i$</span>:</p><p class="math-container">\[∑_j \frac{\mathrm{d} u_j}{\mathrm{d} t} \, ⟨φ_i, ϕ_j⟩ = ν ∑_j u_j \, ⟨φ_i, ϕ_j&#39;&#39;⟩,\]</p><p>where <span>$⟨ f, g ⟩ = ∫_{-1}^1 f(x) \, g(x) \, \mathrm{d} x$</span> is the inner product between functions.</p><p>By choosing <span>$M$</span> different test functions <span>$φ_i$</span>, the above problem can be written as the linear system</p><p class="math-container">\[\mathbf{A} \frac{\mathrm{d} \bm{u}(t)}{\mathrm{d} t} =
ν \mathbf{L} \bm{u}(t),\]</p><p>where the matrices are defined by <span>$A_{ij} = ⟨ φ_i, ϕ_j ⟩$</span> and <span>$L_{ij} = ⟨ φ_i, ϕ_j&#39;&#39; ⟩$</span>.</p><p>Two of the most common choices of test functions <span>$φ_i$</span> are:</p><ul><li><p><span>$φ_i(x) = δ(x - x_i)$</span>, where <span>$δ$</span> is Dirac&#39;s delta, and <span>$x_i$</span> are a set of <em>collocation</em> points where the equation will be satisfied. This approach is known as the <strong>collocation</strong> method.</p></li><li><p><span>$φ_i(x) = ϕ_i(x)$</span>, in which case this is the <strong>Galerkin</strong> method.</p></li></ul><p>We describe the solution using both methods in the following.</p><h2 id="Collocation-method"><a class="docs-heading-anchor" href="#Collocation-method">Collocation method</a><a id="Collocation-method-1"></a><a class="docs-heading-anchor-permalink" href="#Collocation-method" title="Permalink"></a></h2><p>For the collocation method, we need to choose a set of <span>$M$</span> grid points <span>$x_j$</span>. Since the basis functions implicitly satisfy the boundary conditions, these points must be chosen <em>inside</em> of the domain.</p><p>The collocation points may be automatically generated by calling <a href="../../collocation/#BSplineKit.Collocation.collocation_points"><code>collocation_points</code></a>. Note that, since we pass the recombined basis <code>R</code>, the boundaries are not included in the chosen points:</p><pre><code class="language-julia hljs">xcol = collocation_points(R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11-element Vector{Float64}:
 -0.9333333333333332
 -0.7999999999999999
 -0.6
 -0.39999999999999997
 -0.19999999999999998
  1.850371707708594e-17
  0.20000000000000004
  0.4000000000000001
  0.6
  0.7999999999999999
  0.9333333333333332</code></pre><p>We can now construct the matrices <span>$\mathbf{A}$</span> and <span>$\mathbf{L}$</span> associated to the collocation method. By definition, these matrices simply contain the evaluations of all basis functions <span>$ϕ_j$</span> and their derivatives at the collocation points: <span>$A_{ij} = ϕ_j(x_i)$</span> and <span>$L_{ij} = ϕ_j&#39;&#39;(x_i)$</span>. Both these matrices can be constructed in BSplineKit using <a href="../../collocation/#BSplineKit.Collocation.collocation_matrix"><code>collocation_matrix</code></a>. Note that both matrices are of type <a href="../../collocation/#BSplineKit.Collocation.CollocationMatrix"><code>CollocationMatrix</code></a>, which wrap matrices defined in <a href="https://github.com/JuliaLinearAlgebra/BandedMatrices.jl">BandedMatrices.jl</a>.</p><pre><code class="language-julia hljs">Acol = collocation_matrix(R, xcol)
Lcol = collocation_matrix(R, xcol, Derivative(2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11×11 CollocationMatrix{Float64} with bandwidths (2, 2):
 -37.5   29.1667    8.33333  …    0.0            0.0            0.0
  37.5  -62.5      25.0           0.0            0.0            0.0
   0.0   25.0     -50.0           0.0            0.0            0.0
   0.0    0.0      25.0           0.0            0.0            0.0
   0.0    0.0       0.0           0.0            0.0            0.0
   0.0    0.0       0.0      …    0.0            0.0            0.0
   0.0    0.0       0.0           3.46945e-15    0.0            0.0
   0.0    0.0       0.0          25.0            6.93889e-15    0.0
   0.0    0.0       0.0         -50.0           25.0            0.0
   0.0    0.0       0.0          25.0          -62.5           37.5
   0.0    0.0       0.0      …    8.33333       29.1667       -37.5</code></pre><p>For convenience and performance, we can incorporate the heat diffusivity <span>$ν$</span> in the <span>$\mathbf{L}$</span> matrix:</p><pre><code class="language-julia hljs">ν = 0.01
Lcol *= ν</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11×11 BandedMatrix{Float64} with bandwidths (2, 2):
 -0.375   0.291667   0.0833333  …    ⋅             ⋅             ⋅ 
  0.375  -0.625      0.25            ⋅             ⋅             ⋅ 
  0.0     0.25      -0.5             ⋅             ⋅             ⋅ 
   ⋅      0.0        0.25            ⋅             ⋅             ⋅ 
   ⋅       ⋅         0.0             ⋅             ⋅             ⋅ 
   ⋅       ⋅          ⋅         …    ⋅             ⋅             ⋅ 
   ⋅       ⋅          ⋅             3.46945e-17    ⋅             ⋅ 
   ⋅       ⋅          ⋅             0.25          6.93889e-17    ⋅ 
   ⋅       ⋅          ⋅            -0.5           0.25          0.0
   ⋅       ⋅          ⋅             0.25         -0.625         0.375
   ⋅       ⋅          ⋅         …   0.0833333     0.291667     -0.375</code></pre><p>Finally, for the time integration, we use OrdinaryDiffEq.jl from the <a href="https://diffeq.sciml.ai/stable/">DifferentialEquations.jl suite</a>.</p><pre><code class="language-julia hljs">using LinearAlgebra
using OrdinaryDiffEq

function heat_rhs!(du, u, params, t)
    mul!(du, params.L, u)    # du = ν * L * u
    ldiv!(du, params.A, du)  # du = A \ (ν * L * u)
    du
end

# Solver parameters
params_col = (
    A = lu(Acol),  # we pass the factorised matrix A for performance
    L = Lcol,
)

tspan = (0.0, 10.0)
prob = ODEProblem(heat_rhs!, u_init, tspan, params_col)
prob = ODEProblem{true}(heat_rhs!, u_init, tspan, params_col)
sol_collocation = solve(prob, Tsit5(); saveat = 0.5)

function plot_heat_solution(sol, R)
    fig = Figure()
    ax = Axis(fig[1, 1]; xlabel = rich(&quot;x&quot;; font = :italic), ylabel = rich(&quot;θ(x,t)&quot;; font = :italic))
    colormap = cgrad(:viridis)
    tspan = sol.prob.tspan
    Δt = tspan[2] - tspan[1]
    for (u, t) in tuples(sol)
        S = Spline(R, u)
        color = colormap[(t - tspan[1]) / Δt]
        lines!(ax, -1..1, S; label = string(t), color, linewidth = 2)
    end
    Colorbar(fig[1, 2]; colormap, limits = tspan, label = &quot;Time&quot;)
    fig
end

# NOTE: there&#39;s an issue in CairoMakie 0.11.10 when saving SVGs with colourbars, so we fall
# back to PNG output.
# See https://github.com/MakieOrg/Makie.jl/issues/3016
CairoMakie.activate!(type = &quot;png&quot;, px_per_unit = 2.0)
plot_heat_solution(sol_collocation, R)</code></pre><img src="52166795.png" alt="Example block output"/><h2 id="Galerkin-method"><a class="docs-heading-anchor" href="#Galerkin-method">Galerkin method</a><a id="Galerkin-method-1"></a><a class="docs-heading-anchor-permalink" href="#Galerkin-method" title="Permalink"></a></h2><p>We start by constructing the Galerkin matrices <span>$\mathbf{A}$</span> and <span>$\mathbf{L}$</span>. The first of these matrices, <span>$A_{ij} = ⟨ ϕ_i, ϕ_j ⟩$</span>, is usually known as the <em>mass matrix</em> of the system. It is a positive definite symmetric matrix, which enables the use of Cholesky factorisation to solve the resulting linear system. Moreover, here it is banded thanks to the local support of the B-splines. The mass matrix can be constructed by calling <a href="../../galerkin/#BSplineKit.Galerkin.galerkin_matrix"><code>galerkin_matrix</code></a>:</p><pre><code class="language-julia hljs">Agal = galerkin_matrix(R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11×11 LinearAlgebra.Hermitian{Float64, BandedMatrices.BandedMatrix{Float64, Matrix{Float64}, Base.OneTo{Int64}}}:
 0.107857    0.0349405   0.00714286  …   ⋅           ⋅           ⋅ 
 0.0349405   0.0653571   0.0449206       ⋅           ⋅           ⋅ 
 0.00714286  0.0449206   0.095873        ⋅           ⋅           ⋅ 
 5.95238e-5  0.00474206  0.0472619       ⋅           ⋅           ⋅ 
  ⋅          3.96825e-5  0.0047619       ⋅           ⋅           ⋅ 
  ⋅           ⋅          3.96825e-5  …  3.96825e-5   ⋅           ⋅ 
  ⋅           ⋅           ⋅             0.0047619   3.96825e-5   ⋅ 
  ⋅           ⋅           ⋅             0.0472619   0.00474206  5.95238e-5
  ⋅           ⋅           ⋅             0.095873    0.0449206   0.00714286
  ⋅           ⋅           ⋅             0.0449206   0.0653571   0.0349405
  ⋅           ⋅           ⋅          …  0.00714286  0.0349405   0.107857</code></pre><p>Note that, unlike the collocation method, in the Galerkin method we don&#39;t need to specify a set of grid points, as functions are not evaluated at collocation points (they are instead integrated over the whole domain). The integration is performed using Gauss–Legendre quadrature, which can be made exact up to numerical precision, taking advantage of the fact that the product of two B-splines is a piecewise polynomial.</p><p>As for the matrix <span>$\mathbf{L}$</span> representing the second derivative operator, we can write it using integration by parts as</p><p class="math-container">\[L_{ij} = ⟨ ϕ_i, ϕ_j&#39;&#39; ⟩
= -⟨ ϕ_i&#39;, ϕ_j&#39; ⟩ + \left[ ϕ_i ϕ_j&#39; \right]_{-1}^1  = -R_{ij},\]</p><p>where <span>$R_{ij} = ⟨ ϕ_i&#39;, ϕ_j&#39; ⟩$</span> is a positive definite symmetric matrix. Note that the boundary terms all vanish since all basis functions individually satisfy homogeneous Neumann boundary conditions, <span>$ϕ_i&#39;(±1) = 0$</span>. (The same result would be obtained with homogeneous Dirichlet boundary conditions.)</p><p>As can be seen above, one well-known advantage of the Galerkin method is that the basis functions can satisfy weaker continuity conditions than in the collocation method, as high-order derivatives can be reduced using integration by parts.</p><p>The matrix <span>$\mathbf{R}$</span> can be constructed using <a href="../../galerkin/#BSplineKit.Galerkin.galerkin_matrix"><code>galerkin_matrix</code></a>:</p><pre><code class="language-julia hljs">Rgal = galerkin_matrix(R, (Derivative(1), Derivative(1)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11×11 LinearAlgebra.Hermitian{Float64, BandedMatrices.BandedMatrix{Float64, Matrix{Float64}, Base.OneTo{Int64}}}:
  3.75    -2.1875     -1.5        …    ⋅           ⋅           ⋅ 
 -2.1875   3.375      -0.166667        ⋅           ⋅           ⋅ 
 -1.5     -0.166667    3.33333         ⋅           ⋅           ⋅ 
 -0.0625  -0.979167   -0.625           ⋅           ⋅           ⋅ 
   ⋅      -0.0416667  -1.0             ⋅           ⋅           ⋅ 
   ⋅        ⋅         -0.0416667  …  -0.0416667    ⋅           ⋅ 
   ⋅        ⋅           ⋅            -1.0        -0.0416667    ⋅ 
   ⋅        ⋅           ⋅            -0.625      -0.979167   -0.0625
   ⋅        ⋅           ⋅             3.33333    -0.166667   -1.5
   ⋅        ⋅           ⋅            -0.166667    3.375      -2.1875
   ⋅        ⋅           ⋅         …  -1.5        -2.1875      3.75</code></pre><p>Note that, instead, we could have constructed the original matrix <span>$\mathbf{L}$</span>, which, as expected, is equal to <span>$\mathbf{R}$</span> up to a sign:</p><pre><code class="language-julia hljs">Lgal = galerkin_matrix(R, (Derivative(0), Derivative(2)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11×11 BandedMatrix{Float64} with bandwidths (3, 3):
 -3.75     2.1875      1.5        …    ⋅           ⋅           ⋅ 
  2.1875  -3.375       0.166667        ⋅           ⋅           ⋅ 
  1.5      0.166667   -3.33333         ⋅           ⋅           ⋅ 
  0.0625   0.979167    0.625           ⋅           ⋅           ⋅ 
   ⋅       0.0416667   1.0             ⋅           ⋅           ⋅ 
   ⋅        ⋅          0.0416667  …   0.0416667    ⋅           ⋅ 
   ⋅        ⋅           ⋅             1.0         0.0416667    ⋅ 
   ⋅        ⋅           ⋅             0.625       0.979167    0.0625
   ⋅        ⋅           ⋅            -3.33333     0.166667    1.5
   ⋅        ⋅           ⋅             0.166667   -3.375       2.1875
   ⋅        ⋅           ⋅         …   1.5         2.1875     -3.75</code></pre><p>As in the collocation example, we include the heat diffusivity <span>$ν$</span> in the <span>$\mathbf{R}$</span> matrix:</p><pre><code class="language-julia hljs">parent(Rgal) .*= -ν  # we can&#39;t directly multiply Rgal, as it&#39;s a Hermitian wrapper</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11×11 BandedMatrix{Float64} with bandwidths (0, 3):
 -0.0375   0.021875   0.015        0.000625    …    ⋅             ⋅ 
   ⋅      -0.03375    0.00166667   0.00979167       ⋅             ⋅ 
   ⋅        ⋅        -0.0333333    0.00625          ⋅             ⋅ 
   ⋅        ⋅          ⋅          -0.0333333        ⋅             ⋅ 
   ⋅        ⋅          ⋅            ⋅               ⋅             ⋅ 
   ⋅        ⋅          ⋅            ⋅          …    ⋅             ⋅ 
   ⋅        ⋅          ⋅            ⋅              0.000416667    ⋅ 
   ⋅        ⋅          ⋅            ⋅              0.00979167    0.000625
   ⋅        ⋅          ⋅            ⋅              0.00166667    0.015
   ⋅        ⋅          ⋅            ⋅             -0.03375       0.021875
   ⋅        ⋅          ⋅            ⋅          …    ⋅           -0.0375</code></pre><p>We finally solve using DifferentialEquations.jl. Note that not much is changed compared to the collocation example. The only difference is that we use a Cholesky factorisation for the mass matrix <span>$\mathbf{A}$</span>.</p><pre><code class="language-julia hljs">params_gal = (
    A = cholesky(Agal),
    L = Rgal,
)

prob = ODEProblem{true}(heat_rhs!, u_init, tspan, params_gal)
sol_galerkin = solve(prob, Tsit5(); saveat = 0.5)

plot_heat_solution(sol_galerkin, R)</code></pre><img src="9f18653e.png" alt="Example block output"/><h2 id="Result-comparison"><a class="docs-heading-anchor" href="#Result-comparison">Result comparison</a><a id="Result-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Result-comparison" title="Permalink"></a></h2><p>The solution of the Galerkin method looks very similar to the one obtained with the collocation method. However, as seen below, there are non-negligible differences between the two.</p><pre><code class="language-julia hljs">fig = Figure(size = (800, 400))
let ax = Axis(fig[1, 1]; xlabel = rich(&quot;x&quot;; font = :italic), ylabel = rich(&quot;θ(x, t = $(tspan[end]))&quot;; font = :italic))
    for pair in (
            &quot;Collocation&quot; =&gt; sol_collocation,
            &quot;Galerkin&quot; =&gt; sol_galerkin,
        )
        label, sol = pair
        u = last(sol.u)
        S = Spline(R, u)
        lines!(ax, -1..1, S; label, linewidth = 2)
    end
    axislegend(ax; position = :cb)
end
let ax = Axis(fig[1, 2]; xlabel = rich(&quot;x&quot;; font = :italic), ylabel = &quot;Difference&quot;)
    Sc = Spline(R, last(sol_collocation.u))
    Sg = Spline(R, last(sol_galerkin.u))
    lines!(ax, -1..1, x -&gt; Sc(x) - Sg(x); linewidth = 2)
end
fig</code></pre><img src="3ac3033d.svg" alt="Example block output"/><p>Compared to the Galerkin method, there seems to be some additional dissipation in the domain interior when using the collocation method. This hints at the presence of numerical dissipation introduced by this method.</p><p>To finish, we compare the two solutions to a solution at a higher resolution, using a higher number of B-spline knots and a higher B-spline order. This last solution is obtained using the collocation method to allow for better comparisons between both methods.</p><pre><code class="language-julia hljs">hi_res = let
    knots_in = range(-1, 1; length = 101)
    B = BSplineBasis(BSplineOrder(6), knots_in)
    R = RecombinedBSplineBasis(B, Derivative(1))
    θ₀_spline = approximate(θ₀, R)
    u_init = coefficients(θ₀_spline)
    xcol = collocation_points(R)
    Acol = collocation_matrix(R, xcol)
    Lcol = ν .* collocation_matrix(R, xcol, Derivative(2))
    params_col = (A = lu(Acol), L = Lcol)
    prob = ODEProblem{true}(heat_rhs!, u_init, tspan, params_col)
    sol = solve(prob, Tsit5(); saveat = 0.5)
    (; R, sol)
end

fig = Figure(size = (800, 400))
let ax = Axis(fig[1, 1])
    ax.xlabel = rich(&quot;x&quot;; font = :italic)
    ax.ylabel = rich(&quot;θ(x, t = $(tspan[end]))&quot;; font = :italic)
    for pair in (
            &quot;Collocation&quot; =&gt; sol_collocation,
            &quot;Galerkin&quot; =&gt; sol_galerkin,
        )
        label, sol = pair
        u = last(sol.u)
        S = Spline(R, u)
        lines!(ax, -1..1, S; label, linewidth = 2)
    end
    let u = last(hi_res.sol.u)
        S = Spline(hi_res.R, u)
        lines!(ax, -1..1, S; label = &quot;Hi-res&quot;, linewidth = 2, linestyle = :dash, color = :gray)
    end
    axislegend(ax; position = :cb)
end
let ax = Axis(fig[1, 2]; ylabel = &quot;Difference with hi-res solution&quot;)
    ax.xlabel = rich(&quot;x&quot;; font = :italic)
    Sc = Spline(R, last(sol_collocation.u))
    Sg = Spline(R, last(sol_galerkin.u))
    S_hi = Spline(hi_res.R, last(hi_res.sol.u))
    lines!(ax, -1..1, x -&gt; Sc(x) - S_hi(x); label = rich(&quot;Collocation&quot;), linewidth = 2)
    lines!(ax, -1..1, x -&gt; Sg(x) - S_hi(x); label = rich(&quot;Galerkin&quot;), linewidth = 2)
    axislegend(ax; position = :rb)
end
fig</code></pre><img src="0a6bc339.svg" alt="Example block output"/><p>We see that the low-resolution solution with the Galerkin method matches the high-resolution solution. This confirms that the Galerkin method provides higher accuracy than the collocation method when both are used at the same resolution.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../approximation/">« Function approximation</a><a class="docs-footer-nextpage" href="../../bsplines/">B-splines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 27 June 2024 08:25">Thursday 27 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
