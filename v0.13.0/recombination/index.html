<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basis recombination · BSplineKit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/tomate.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BSplineKit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/interpolation/">Spline interpolations</a></li><li><a class="tocitem" href="../generated/approximation/">Function approximation</a></li><li><a class="tocitem" href="../generated/heat/">Heat equation</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../bsplines/">B-splines</a></li><li><a class="tocitem" href="../splines/">Splines</a></li><li><a class="tocitem" href="../interpolation/">Data interpolation</a></li><li><a class="tocitem" href="../approximation/">Function approximation</a></li><li class="is-active"><a class="tocitem" href>Basis recombination</a><ul class="internal"><li><a class="tocitem" href="#Recombined-bases"><span>Recombined bases</span></a></li><li><a class="tocitem" href="#Recombination-matrix"><span>Recombination matrix</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../tensors/">Banded tensors</a></li><li><a class="tocitem" href="../galerkin/">Galerkin tools</a></li><li><a class="tocitem" href="../collocation/">Collocation tools</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary conditions</a></li><li><input class="collapse-toggle" id="menuitem-3-10" type="checkbox"/><label class="tocitem" for="menuitem-3-10"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../diffops/">Differential operators</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Basis recombination</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basis recombination</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jipolanco/BSplineKit.jl/blob/master/docs/src/recombination.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="basis-recombination-api"><a class="docs-heading-anchor" href="#basis-recombination-api">Basis recombination</a><a id="basis-recombination-api-1"></a><a class="docs-heading-anchor-permalink" href="#basis-recombination-api" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations" href="#BSplineKit.Recombinations"><code>BSplineKit.Recombinations</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Recombinations</code></pre><p>Basis recombination module.</p><p>Defines <a href="#BSplineKit.Recombinations.RecombinedBSplineBasis"><code>RecombinedBSplineBasis</code></a> and <a href="#BSplineKit.Recombinations.RecombineMatrix"><code>RecombineMatrix</code></a> types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/Recombinations.jl#L1-L7">source</a></section></article><h2 id="Recombined-bases"><a class="docs-heading-anchor" href="#Recombined-bases">Recombined bases</a><a id="Recombined-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Recombined-bases" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.RecombinedBSplineBasis" href="#BSplineKit.Recombinations.RecombinedBSplineBasis"><code>BSplineKit.Recombinations.RecombinedBSplineBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecombinedBSplineBasis{k, T}</code></pre><p>Functional basis defined from the recombination of a <a href="../bsplines/#BSplineKit.BSplines.BSplineBasis"><code>BSplineBasis</code></a> in order to satisfy certain homogeneous boundary conditions (BCs).</p><p><strong>Extended help</strong></p><p>The basis recombination technique is a common way of applying BCs in Galerkin methods. It is described for instance in Boyd 2000 (ch. 6), in the context of a Chebyshev basis. In this approach, the original basis, <span>$\{b_i(x), 1 ≤ i ≤ N\}$</span>, is &quot;recombined&quot; into a new basis, <span>$\{ϕ_j(x), 1 ≤ j ≤ M\}$</span>, so that each basis function <span>$ϕ_j$</span> individually satisfies the chosen BCs.</p><p>The length <span>$M$</span> of the recombined basis is always smaller than the length <span>$N$</span> of the original basis. The difference, <span>$δ = N - M$</span>, is equal to the number of boundary conditions. In the simplest (and most common) case, a single BC is applied on each boundary, leading to <span>$δ = 2$</span>. More generally, as described further below, it is possible to simultaneously impose different BCs, which further decreases the number of degrees of freedom (increasing <span>$δ$</span>).</p><p>Thanks to the local support of B-splines, basis recombination involves only a little portion of the original B-spline basis. For instance, since there is only one B-spline that is non-zero at each boundary, removing that function from the basis is enough to apply homogeneous Dirichlet BCs. Imposing BCs for derivatives is slightly more complex, but still possible.</p><p>Note that, when combining basis recombination with <a href="../collocation/#collocation-api">collocation methods</a>, there must be <strong>no</strong> collocation points at the boundaries, or the resulting collocation matrices may not be invertible.</p><p><strong>Order of the boundary condition</strong></p><p>In this section, we consider the simplest case where a single homogeneous boundary condition, <span>$\mathrm{d}^n u / \mathrm{d}x^n = 0$</span>, is to be satisfied by the basis.</p><p>The recombined basis requires the specification of a <code>Derivative</code> object determining the order of the homogeneous BCs to be applied at the two boundaries. Linear combinations of <code>Derivative</code>s are also supported. The order of the B-spline needs to be <span>$k ≥ n + 1$</span>, since a B-spline of order <span>$k$</span> is a <span>$C^{k - 1}$</span>-continuous function (except on the knots where it is <span>$C^{k - 1 - p}$</span>, with <span>$p$</span> the knot multiplicity).</p><p>Some usual choices are:</p><ul><li><p><code>Derivative(0)</code> sets homogeneous <a href="https://en.wikipedia.org/wiki/Dirichlet_boundary_condition">Dirichlet BCs</a> (<span>$u = 0$</span> at the boundaries) by removing the first and last B-splines, i.e. <span>$ϕ_1 = b_2$</span>;</p></li><li><p><code>Derivative(1)</code> sets homogeneous <a href="https://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann BCs</a> (<span>$u&#39; = 0$</span> at the boundaries) by adding the two first (and two last) B-splines, i.e. <span>$ϕ_1 = b_1 + b_2$</span>.</p></li><li><p>more generally, <code>α Derivative(0) + β Derivative(1)</code> sets homogeneous <a href="https://en.wikipedia.org/wiki/Robin_boundary_condition">Robin BCs</a> by defining <span>$ϕ_1$</span> as a linear combination of <span>$b_1$</span> and <span>$b_2$</span>. Here it&#39;s important to note that <code>Derivative(1)</code> denotes the <a href="https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative">normal derivative</a> at the boundary, <span>$\frac{∂u}{∂n}$</span>, which is equal to <span>$-\frac{∂u}{∂x}$</span> on the left boundary.</p></li></ul><p>Higher order BCs are also possible. For instance, <code>Derivative(2)</code> recombines the first three B-splines into two basis functions that satisfy <span>$ϕ_1&#39;&#39; = ϕ_2&#39;&#39; = 0$</span> at the left boundary, while ensuring that lower and higher-order derivatives keep degrees of freedom at the boundary. Note that simply adding the first three B-splines, as in <span>$ϕ_1 = b_1 + b_2 + b_3$</span>, makes the first derivative vanish as well as the second one, which is unwanted.</p><p>For <code>Derivative(2)</code>, the chosen solution is to set <span>$ϕ_i = α_i b_i + β_i b_{i + 1}$</span> for <span>$i ∈ \{1, 2\}$</span>. The <span>$α_i$</span> and <span>$β_i$</span> coefficients are chosen such that <span>$ϕ_i&#39;&#39; = 0$</span> at the boundary. Moreover, they satisfy the (somewhat arbitrary) constraint <span>$α_i + β_i = 2$</span> for each <span>$i$</span>, for consistency with the Neumann case described above. This generalises to higher order BCs. Note that, since each boundary function <span>$ϕ_i$</span> is defined from only two neighbouring B-splines, its local support stays minimal, hence preserving the small bandwidth of the resulting matrices.</p><p>Finally, note that in the current implementation, it is not possible to impose different boundary conditions on both boundaries.</p><p><strong>Multiple boundary conditions</strong></p><p>As an option, the recombined basis may simultaneously satisfy homogeneous BCs of different orders. In this case, a tuple of <code>Derivative</code>s must be passed.</p><p>For more details on the supported combinations of BCs, see the different <code>RecombinedBSplineBasis</code> constructors documented further below.</p><hr/><pre><code class="nohighlight hljs">RecombinedBSplineBasis(op::AbstractDifferentialOp, B::BSplineBasis)</code></pre><p>Construct <code>RecombinedBSplineBasis</code> from B-spline basis <code>B</code>, satisfying homogeneous boundary conditions associated to the given differential operator.</p><p>For instance, <code>op = Derivative(0)</code> and <code>op = Derivative(1)</code> correspond to homogeneous Dirichlet and Neumann BCs, respectively.</p><p>Linear combinations of differential operators are also supported. For instance, <code>op = Derivative(0) + λ Derivative(1)</code> corresponds to homogeneous Robin BCs.</p><p>Higher-order derivatives are also allowed, being only limited by the order of the B-spline basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = BSplineBasis(BSplineOrder(4), -1:0.2:1)
13-element BSplineBasis of order 4, domain [-1.0, 1.0]
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]

julia&gt; R_neumann = RecombinedBSplineBasis(Derivative(1), B)
11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]
 BCs left:  (D{1},)
 BCs right: (D{1},)

julia&gt; R_robin = RecombinedBSplineBasis(Derivative(0) + 3Derivative(1), B)
11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]
 BCs left:  (D{0} + 3 * D{1},)
 BCs right: (D{0} + 3 * D{1},)</code></pre><hr/><pre><code class="nohighlight hljs">RecombinedBSplineBasis(ops, B::BSplineBasis)</code></pre><p>Construct <code>RecombinedBSplineBasis</code> simultaneously satisfying homogeneous BCs associated to multiple differential operators.</p><p>Currently, the following cases are supported:</p><ol><li><p>all derivatives up to order <code>m</code>:</p><pre><code class="nohighlight hljs"> ops = (Derivative(0), ..., Derivative(m))</code></pre><p>This boundary condition is obtained by removing the first <code>m + 1</code> B-splines from the original basis.</p><p>For instance, if <code>(Derivative(0), Derivative(1))</code> is passed, then the basis simultaneously satisfies homogeneous Dirichlet and Neumann BCs at the two boundaries. The resulting basis is <span>$ϕ_1 = b_3, ϕ_2 = b_4, …, ϕ_{N - 4} = b_{N - 2}$</span>.</p></li><li><p>an extension of the above, with an additional differential operator of order <code>n</code> at the end:</p><pre><code class="nohighlight hljs"> ops = (Derivative(0), ..., Derivative(m), D(n))</code></pre><p>The operator <code>D(n)</code> may be a <code>Derivative</code>, or a linear combination of derivatives. The only restriction is that its maximum degree must satisfy <code>n ≥ m + 1</code>.</p><p>One example is the combination of homogeneous Dirichlet BCs, <span>$u = 0$</span> on the boundaries, with Robin BCs for the derivative, <span>$u&#39; + λ u&#39;&#39; = 0$</span>, which corresponds to <code>ops = (Derivative(0), Derivative(1) + λ Derivative(2))</code>.</p></li><li><p>generalised natural boundary conditions:</p><pre><code class="nohighlight hljs"> ops = Natural()</code></pre><p>This is equivalent to <code>ops = (Derivative(2), Derivative(3), ..., Derivative(k ÷ 2))</code> where <code>k</code> is the spline order (which must be even). See <a href="../boundary_conditions/#BSplineKit.BoundaryConditions.Natural"><code>Natural</code></a> for details.</p></li></ol><p>In the first two cases, the degrees of the differential operators must be in increasing order. For instance, <code>ops = (Derivative(1), Derivative(0))</code> fails with an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ops = (Derivative(0), Derivative(1));


julia&gt; R1 = RecombinedBSplineBasis(ops, B)
9-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]
 BCs left:  (D{0}, D{1})
 BCs right: (D{0}, D{1})

julia&gt; ops = (Derivative(0), Derivative(1) - 4Derivative(2));


julia&gt; R2 = RecombinedBSplineBasis(ops, B)
9-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]
 BCs left:  (D{0}, D{1} + -4 * D{2})
 BCs right: (D{0}, D{1} + -4 * D{2})

julia&gt; R3 = RecombinedBSplineBasis(Natural(), B)
11-element RecombinedBSplineBasis of order 4, domain [-1.0, 1.0]
 knots: [-1.0, -1.0, -1.0, -1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.0, 1.0, 1.0]
 BCs left:  (D{2},)
 BCs right: (D{2},)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/bases.jl#L1-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parent-Tuple{RecombinedBSplineBasis}" href="#Base.parent-Tuple{RecombinedBSplineBasis}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent(R::RecombinedBSplineBasis)</code></pre><p>Get original B-spline basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/bases.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{RecombinedBSplineBasis}" href="#Base.length-Tuple{RecombinedBSplineBasis}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(R::RecombinedBSplineBasis)</code></pre><p>Returns the number of functions in the recombined basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/bases.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.constraints" href="#BSplineKit.Recombinations.constraints"><code>BSplineKit.Recombinations.constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constraints(R::AbstractBSplineBasis) -&gt; (left, right)
constraints(A::RecombineMatrix) -&gt; (left, right)</code></pre><p>Return the constraints (homogeneous boundary conditions) that the basis satisfies on each boundary.</p><p>Constraints are returned as a tuple <code>(left, right)</code> indicating the BCs that are satisfied on each boundary. Each element is a tuple of differential operators specifying the BCs.</p><p>For example, if both Dirichlet and Neumann BCs are satisfied on the left boundary, then <code>left = (Derivative(0), Derivative(1))</code>.</p><p>For non-recombined bases such as <a href="../bsplines/#BSplineKit.BSplines.BSplineBasis"><code>BSplineBasis</code></a>, this returns a tuple of empty tuples: <code>((), ())</code>, since no BCs are satisfied on either boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/bases.jl#L292-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.num_constraints" href="#BSplineKit.Recombinations.num_constraints"><code>BSplineKit.Recombinations.num_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_constraints(R::AbstractBSplineBasis) -&gt; (Int, Int)
num_constraints(A::RecombineMatrix) -&gt; (Int, Int)</code></pre><p>Returns the number of constraints (number of BCs to satisfy) on each boundary.</p><p>For instance, if <code>R</code> simultaneously satisfies Dirichlet and Neumann boundary conditions on each boundary, this returns <code>(2, 2)</code>.</p><p>Note that for non-recombined bases such as <a href="../bsplines/#BSplineKit.BSplines.BSplineBasis"><code>BSplineBasis</code></a>, the number of constraints is zero, and this returns <code>(0, 0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/bases.jl#L311-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.num_recombined" href="#BSplineKit.Recombinations.num_recombined"><code>BSplineKit.Recombinations.num_recombined</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_recombined(R::AbstractBSplineBasis) -&gt; (Int, Int)
num_recombined(A::RecombineMatrix) -&gt; (Int, Int)</code></pre><p>Returns the number of recombined functions in the recombined basis for each boundary.</p><p>For instance, if <code>R</code> satisfies Neumann boundary conditions on both boundaries, then only the first and last basis functions are different from the original B-spline basis, e.g. <span>$ϕ_1 = b_1 + b_2$</span>, and this returns <code>(1, 1)</code>.</p><p>For non-recombined bases such as <a href="../bsplines/#BSplineKit.BSplines.BSplineBasis"><code>BSplineBasis</code></a>, this returns zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/bases.jl#L325-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.recombination_matrix" href="#BSplineKit.Recombinations.recombination_matrix"><code>BSplineKit.Recombinations.recombination_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recombination_matrix(R::AbstractBSplineBasis)</code></pre><p>Get <a href="#BSplineKit.Recombinations.RecombineMatrix"><code>RecombineMatrix</code></a> associated to the recombined basis.</p><p>For non-recombined bases such as <a href="../bsplines/#BSplineKit.BSplines.BSplineBasis"><code>BSplineBasis</code></a>, this returns the identity matrix (<code>LinearAlgebra.I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/bases.jl#L267-L274">source</a></section></article><h2 id="Recombination-matrix"><a class="docs-heading-anchor" href="#Recombination-matrix">Recombination matrix</a><a id="Recombination-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Recombination-matrix" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.RecombineMatrix" href="#BSplineKit.Recombinations.RecombineMatrix"><code>BSplineKit.Recombinations.RecombineMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecombineMatrix{T} &lt;: AbstractMatrix{T}</code></pre><p>Matrix for transformation from coefficients of the recombined basis, to the corresponding B-spline basis coefficients.</p><p><strong>Extended help</strong></p><p>The transformation matrix <span>$M$</span> is defined by</p><p class="math-container">\[ϕ_j = M_{ij} b_i,\]</p><p>where <span>$b_j(x)$</span> and <span>$ϕ_i(x)$</span> are elements of the B-spline and recombined bases, respectively.</p><p>This matrix allows to pass from known coefficients <span>$u_j$</span> in the recombined basis <span>$ϕ_j$</span>, to the respective coefficients <span>$v_i$</span> in the B-spline basis <span>$b_i$</span>:</p><p class="math-container">\[\bm{v} = \mathbf{M} \bm{u}.\]</p><p>Note that the matrix is not square: it has dimensions <span>$N × M$</span>, where <span>$N$</span> is the length of the B-spline basis, and <span>$M = N - δ$</span> is that of the recombined basis (see <a href="#BSplineKit.Recombinations.RecombinedBSplineBasis"><code>RecombinedBSplineBasis</code></a> for details).</p><p>Due to the local support of B-splines, basis recombination can be performed by combining just a small set of B-splines near the boundaries (as discussed in <a href="#BSplineKit.Recombinations.RecombinedBSplineBasis"><code>RecombinedBSplineBasis</code></a>). This leads to a recombination matrix which is almost a diagonal of ones, plus a few extra super- and sub-diagonal elements in the upper left and lower right corners, respectively. The matrix is stored in a memory-efficient way that also allows fast access to its elements.</p><p>Efficient implementations of matrix-vector products (using the <code>*</code> operator or <code>LinearAlgebra.mul!</code>) and of left division of vectors (using <code>\</code> or <code>LinearAlgebra.ldiv!</code>) are included. These two operations can be used to transform between coefficients in the original and recombined bases.</p><p>Note that, since the recombined basis forms a subspace of the original basis (which is related to the rectangular shape of the matrix), it is generally not possible to obtain recombined coefficients from original coefficients, unless the latter already satisfy the constraints encoded in the recombined basis. The left division operation will throw a <a href="#BSplineKit.Recombinations.NoUniqueSolutionError"><code>NoUniqueSolutionError</code></a> if that is not the case.</p><hr/><pre><code class="nohighlight hljs">RecombineMatrix(ops::Tuple{Vararg{AbstractDifferentialOp}},
                B::BSplineBasis, [T])</code></pre><p>Construct recombination matrix describing a B-spline basis recombination.</p><p>The default element type <code>T</code> is generally <code>Float64</code>, except for specific differential operators which yield a matrix of zeroes and ones, for which <code>Bool</code> is the default.</p><p>See the <a href="#BSplineKit.Recombinations.RecombinedBSplineBasis"><code>RecombinedBSplineBasis</code></a> constructor for details on the <code>ops</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/matrices.jl#L3-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.nzrows" href="#BSplineKit.Recombinations.nzrows"><code>BSplineKit.Recombinations.nzrows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nzrows(A::RecombineMatrix, col::Integer) -&gt; UnitRange{Int}</code></pre><p>Returns the range of row indices <code>i</code> such that <code>A[i, col]</code> is non-zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/matrices.jl#L470-L474">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.NoUniqueSolutionError" href="#BSplineKit.Recombinations.NoUniqueSolutionError"><code>BSplineKit.Recombinations.NoUniqueSolutionError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoUniqueSolutionError &lt;: Exception</code></pre><p>Exception thrown when solving linear system using <a href="#BSplineKit.Recombinations.RecombineMatrix"><code>RecombineMatrix</code></a>, when the system has no unique solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/matrices.jl#L614-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSplineKit.Recombinations.parent_coefficients" href="#BSplineKit.Recombinations.parent_coefficients"><code>BSplineKit.Recombinations.parent_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parent_coefficients(R::RecombinedBSplineBasis, coefs::AbstractVector)</code></pre><p>Returns the coefficients associated to the parent B-spline basis, from the coefficients <code>coefs</code> in the recombined basis.</p><p>Note that this function doesn&#39;t allocate, since it returns a lazy concatenation (via LazyArrays.jl) of two StaticArrays and a view of the <code>coefs</code> vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/BSplineKit.jl/blob/2a71e955aa9bdf9f73479626dbc778a666ce1091/src/Recombinations/splines.jl#L3-L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../approximation/">« Function approximation</a><a class="docs-footer-nextpage" href="../tensors/">Banded tensors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 23 November 2022 07:29">Wednesday 23 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
